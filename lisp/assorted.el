;;; assorted.el --- assorted functions

;; $Id$

;; Emacs List Archive Entry
;; Filename: assorted.el
;; Version: $Revision$
;; Keywords:
;; Author: Alexis Roda <alexis.roda.villalonga@gmail.com>
;; Maintainer: Alexis Roda <alexis.roda.villalonga@gmail.com>
;; Created: 2014-08-04
;; Description:
;; URL:
;; Compatibility: Emacs24

;; COPYRIGHT NOTICE
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2 of the
;; License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; General Public License for more
;; details. http://www.gnu.org/copyleft/gpl.html

;;; Install:

;; Put this file on your Emacs-Lisp load path and add following into
;; emacs startup file.
;;
;;     (require 'assorted)
;;
;; Alternativeli, some functions are autoloaded so just use them.

;;; Commentary:
;;
;; Assorted functions that don't fit anywhere else.

;;; History:
;;

(defvar assorted-version-id
  "$Id$"
  "Latest modification time and version number.")

;;; Code:

(require 'cl-lib)
(require 'color)
(require 'subword)
(require 'superword)

;;;###autoload
(defun arv/generate-lab-faces (name count &optional lightness saturation group-name)
  "Generate `count' faces named `<name>-01-face' to
`<name>-nn-face' within the group `group-name'.

`name' and `group-name' must be strings, not symbols.

* `lightness' defaults to 45
* `saturation' defaults to 40
* `group-name' defaults to `<name>-faces'
"
  (let ((group-name (intern (or group-name (concat name "-faces"))))
        (lightness (or lightness 45))
        (saturation (or saturation 40))
        (format-string (concat name "-%02i-face")))
    (custom-declare-group group-name nil "Autogenerated faces" :group 'faces)
    (cl-loop for i from 1 to count do
          (let* ((angle (* 2 pi (/ i (float count))))
                 (a (* saturation (cos angle)))
                 (b (* saturation (sin angle)))
                 (name (intern (format format-string i))))
            (custom-declare-face name '((t nil))
             "Prova face."
             :group group-name)
            (set-face-attribute
             name nil
             :foreground (apply 'color-rgb-to-hex (color-lab-to-srgb lightness a b)))
            ))))

;;;###autoload
(defun arv/wm-cycle ()
  "Cycle word-mode:
subword-mode -> superword-mode -> nothing -> subword-mode"
  (interactive)
  (cond
   (subword-mode
    (subword-mode 0)
    (superword-mode 1))
   (superword-mode
    (subword-mode 0)
    (superword-mode 0))
   (t
    (subword-mode 1)
    (superword-mode 0))))

;;;###autoload
(defun arv/wm-cycle-2 ()
  "Cycle word-mode:
subword-mode <-> superword-mode"
  (interactive)
  (cond
   (subword-mode
    (subword-mode 0)
    (superword-mode 1))
   (t
    (subword-mode 1)
    (superword-mode 0))))

;;;###autoload
(defun arv/goto-line ()
  "Like `goto-line' but temporarily display absolute line
numbers."
  (interactive)
  (let ((linum-enabled linum-mode))
    (unwind-protect
        (let ((relative-linum-enabled nil))
          (linum-mode 1)
          (call-interactively 'goto-line))
      (unless linum-enabled
        (linum-mode -1)))))


;; smarter up/downcase-word
;; Idea stolen from: http://oremacs.com/2014/12/23/upcase-word-you-silly/

;;;###autoload
(defun arv/upcase-word (arg)
  (interactive "P")
  (when (looking-at-p "\\sw")
    (save-excursion
      (unless (looking-back "\\b")
        (backward-word))
      (call-interactively 'upcase-word))))

;;;###autoload
(defun arv/downcase-word (arg)
  (interactive "P")
  (when (looking-at-p "\\sw")
    (save-excursion
      (unless (looking-back "\\b")
        (backward-word))
      (call-interactively 'downcase-word))))

;;;###autoload
(defun arv/duplicate-line-dwim (arg)
  "Duplicate current line.

- Without prefix argument duplicate current line.

- Positive prefix ARG means include previous ARG lines plus the
  current one.

- If ARG is negative include current line plus next ARG lines.

- If the region is active duplicates all the complete lines
  intersecting with the region. ARG is ignored."
  (interactive "P")
  (let (start
        end
        where
        text)
    (cond
     ((region-active-p)
      (setq beg (save-excursion
                  (goto-char (min (point) (mark)))
                  (line-beginning-position)))
      (setq end (save-excursion
                  (goto-char (max (point) (mark)))
                  (forward-line)
                  (line-beginning-position)))
      (setq where end))
     ((null arg)
      (setq beg (line-beginning-position))
      (setq end (line-beginning-position 2))
      (setq where end))
     ((< arg 0)
      (setq beg (line-beginning-position))
      (setq end (line-beginning-position (+ (- arg) 2)))
      (setq where beg))
     (t
      (setq beg (line-beginning-position (+ (- arg) 1)))
      (setq end (line-beginning-position 2))
      (setq where end)))
    (save-excursion
      (goto-char end)
      (when (eobp)
        (newline)
        (setq end (1+ end))
        (unless (= where beg)
          (setq where end))))
    (setq text (buffer-substring-no-properties beg end))
    (goto-char where)
    (insert text)
    (goto-char where)
    (back-to-indentation)))


;;;###autoload
(defun arv/duplicate-region-and-comment-dwim (start stop)
  "Duplicate the whole lines i region and comment them.
Mostly equivalent to select region, copy, paste, select again and
comment region, but the region is not copied to the kill ring and
the text properties are removed."
  (interactive "r")
  (let* ((beg (progn (goto-char start) (line-beginning-position)))
         (end (progn (goto-char stop) (line-end-position)))
         (text (buffer-substring-no-properties beg end)))
    (goto-char end)
    (newline)
    (insert text)
    (comment-region beg end)
    ))


;; http://endlessparentheses.com/implementing-comment-line.html
;;;###autoload
(defun endless/comment-line-or-region (n)
  "Comment or uncomment current line and leave point after it.
With positive prefix, apply to N lines including current one.
With negative prefix, apply to -N lines above.
If region is active, apply to active region instead."
  (interactive "p")
  (if (use-region-p)
      (comment-or-uncomment-region
       (region-beginning) (region-end))
    (let ((range
           (list (line-beginning-position)
                 (goto-char (line-end-position n)))))
      (comment-or-uncomment-region
       (apply #'min range)
       (apply #'max range)))
    (forward-line 1)
    (back-to-indentation)))


;; http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html
;;;###autoload
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))


(provide 'assorted)

;;; assorted.el ends here
