;;; assorted.el --- assorted functions

;; $Id$

;; Emacs List Archive Entry
;; Filename: assorted.el
;; Version: $Revision$
;; Keywords:
;; Author: Alexis Roda <alexis.roda.villalonga@gmail.com>
;; Maintainer: Alexis Roda <alexis.roda.villalonga@gmail.com>
;; Created: 2014-08-04
;; Description:
;; URL:
;; Compatibility: Emacs24

;; COPYRIGHT NOTICE
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2 of the
;; License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
;; General Public License for more
;; details. http://www.gnu.org/copyleft/gpl.html

;;; Install:

;; Put this file on your Emacs-Lisp load path and add following into
;; emacs startup file.
;;
;;     (require 'assorted)
;;
;; Alternativeli, some functions are autoloaded so just use them.

;;; Commentary:
;;
;; Assorted functions that don't fit anywhere else.

;;; History:
;;

(defvar assorted-version-id
  "$Id$"
  "Latest modification time and version number.")

;;; Code:

(require 'color)
(require 'subword)
(require 'superword)

;;;###autoload
(defun arv/generate-lab-faces (name count &optional lightness saturation group-name)
  "Generate `count' faces named `<name>-01-face' to
`<name>-nn-face' within the group `group-name'.

`name' and `group-name' must be strings, not symbols.

* `lightness' defaults to 45
* `saturation' defaults to 40
* `group-name' defaults to `<name>-faces'
"
  (let ((group-name (intern (or group-name (concat name "-faces"))))
        (lightness (or lightness 45))
        (saturation (or saturation 40))
        (format-string (concat name "-%02i-face")))
    (custom-declare-group group-name nil "Autogenerated faces" :group 'faces)
    (loop for i from 1 to count do
          (let* ((angle (* 2 pi (/ i (float count))))
                 (a (* saturation (cos angle)))
                 (b (* saturation (sin angle)))
                 (name (intern (format format-string i))))
            (custom-declare-face name '((t nil))
             "Prova face."
             :group group-name)
            (set-face-attribute
             name nil
             :foreground (apply 'color-rgb-to-hex (color-lab-to-srgb lightness a b)))
            ))))

;;;###autoload
(defun arv/wm-cycle ()
  "Cycle word-mode:
subword-mode -> superword-mode -> nothing -> subword-mode"
  (interactive)
  (cond
   (subword-mode
    (subword-mode 0)
    (superword-mode 1))
   (superword-mode
    (subword-mode 0)
    (superword-mode 0))
   (t
    (subword-mode 1)
    (superword-mode 0))))

;;;###autoload
(defun arv/goto-line ()
  "Like `goto-line' but temporarily display absolute line
numbers."
  (interactive)
  (let ((linum-enabled linum-mode))
    (unwind-protect
        (let ((relative-linum-enabled nil))
          (linum-mode 1)
          (call-interactively 'goto-line))
      (unless linum-enabled
        (linum-mode -1)))))


;; smarter up/downcase-word
;; Idea stolen from: http://oremacs.com/2014/12/23/upcase-word-you-silly/

;;;###autoload
(defun arv/upcase-word (arg)
  (interactive "P")
  (save-excursion
    (unless (looking-back "\\b")
      (backward-word))
    (call-interactively 'upcase-word)))

;;;###autoload
(defun arv/downcase-word (arg)
  (interactive "P")
  (save-excursion
    (unless (looking-back "\\b")
      (backward-word))
    (call-interactively 'downcase-word)))


(provide 'assorted)

;;; assorted.el ends here
