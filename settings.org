#+TITLE: Configuració d'emacs d'Alexis Roda
#+OPTIONS: toc:4 h:4
#+STARTUP: overview

#+LANGUAGE: ca
#+LATEX_CLASS: informe

# Afegeix una referència en l'arxiu ".el" que apunta al bloc de codi
# org. Veure la funció "org-babel-tangle-jumpt-to-org".
#+PROPERTY: header-args:emacs-lisp    :padline true :comments link

#+begin_abstract
Aquesta és la tercera encarnació de la configuració d'emacs. Els
objectius que es volen aconsseguir són:

- reduir el temps de càrrega.

- prendre el control del caos en que havia esdevingut la segona
  encarnació i mantindre una baixa entropia.

- automatitzar el desplegament de la configuració a nous sistemes.

Però la veritat és que és divertit 😊.
#+end_abstract

* Instal·lació

En teoria aquesta configuració hauria de funcionar amb emacs 24.4 o
posterior. En la pràctica només està provada amb emacs 25.2.1 i
25.3.1.

Dependències: =git=, =make= i =makeinfo= (per instal·lar org). En
ubuntu el paquet /texinfo/ proveeix la comanda =makeinfo=.

#+begin_src sh :tangle no
  mkdir ~/.emacs.d
  cd ~/.emacs.d
  git clone https://github.com/patxoca/dot-emacs.git conf.d
  ln -s conf.d/init.el .
  emacs
#+end_src

#+begin_warning
Actualment és *imprescindible* que el directori on es clona el
repositori sigui =conf.d=. Aquest valor està fixat en algunes parts de
la configuració.
#+end_warning

Al executar /emacs/ sobre una copia de treball neta es generaran els
fitxers =settings.el= i =settings.sh=. El primer conté la configuració
d'/emacs/ i el segon comandes /sh/ per configurar l'entorn. A
continuació es carregarà =settings.el= i per acabar s'executarà
=settings.sh=.

El primer arranc pot trigar uns minuts, mentre es descarreguen i
instal·len tots els paquets.

En arrancs posteriors el fitxer =settings.el= s'actualitzarà
automàticament si s'ha fet cap canvi en aquest document.

El fitxer =settings.sh= mai s'actualitza, cal esborrar-lo i es
generarà i executarà novament en el següent arranc.

* Introducció

En aquest apartat es dona una visió general de la configuració i es
detallen algunes guies/recomanacions per ajudar a mantindre la
consistència i un nivell baix de caos.

** Versió de org

La configuració depèn de que /org/ estigui instal·lat, concretament el
mòdul /babel/, per extreure (/tangle/) els blocs de codi i generar
l'arxiu de configuració /real/ (=settings.el=).

Cal que aquesta configuració /sigui compatible/, almenys pel que
respecta a l'extracció dels blocs de codi, amb la versió de /org/ que
s'utilitzarà durant el /bootstrap/. En cas de problemes caldrà
actualitzar la versió de /org/.

Durant el primer arranc es descarregarà el codi font de /org/ i
s'instal·larà baix la jerarquia de directoris =~/.local=. En els
arrancs subseqüents s'utilitzarà la nova versió.

** Configuració de paquets

La configuració dels paquets només pot incloure modificació d'elements
definits pel propi paquet. No pot definir tecles globals, no pot
activar cap funcionalitat etc.

La idea és mantindre la localitat separant responsabilitats.

Actualment alguns paquets no ho compleixen.

** Configuració de modes

Un mode en essència és un paquet però en aquest punt encara no he
decidit com organitzar-ho.

Tampoc he decidit si tots paquets han d'anar a la mateixa secció o
poden apareixer en la secció del mode en que s'utilitzen (com està
ara).

** Blocs de codi sh

Un dels objectius és automatitzar la configuració inicial de l'entorn.
Una de les eines utilitzades per aconsseguir-ho són el blocs de codi
/sh/.

Els bloc /sh/ s'utilitzen en varis contexts:

- s'insereixen en un arxiu per formar un únic script =settings.sh=.
  Aquest script serà executat automàticament durant el primer arranc
  d'emacs.

- s'avaluen individualment des del propi document. Per exemple, quan
  s'afegeix un nou paquet a la configuració i cal instal·lar-lo
  avaluant el bloc de codi.

- en un sistema ja configurat en el que s'ha esborrat l'arxiu
  =settings.sh=. És igual que el punt 1 però l'entorn ja està
  configurat.

Cal tindre cura al escriure aquests blocs de codi per tal de garantir
que funcionin en tots els contexts:

- cal preservar l'entorn d'execució: si es modifica l'entorn
  d'execució, en la modalitat /script/ (contexts 1 i 3), els canvis
  afectaran als blocs que s'executin a continuació.

  En particular cal preservar el directori de treball. El codi pot
  assumir que el directori de treball és =~/.emacs.d/conf.d=. Al
  finalitzar ha de restaurar el directori de treball (utilitzant
  =pushd= i =popd= enlloc de =cd=, per exemple).

- cal que sigui independent: el codi ha de funcionar tant si s'executa
  en modalitat /script/ com en modalitat /bloc/.

- cal que sigui idempotent: el codi pot executar-se més d'una vegada i
  ha de funcionar corretament tant la primera com la resta.

El directori =scripts= conté alguns scripts per simplificar les
tasques més habituals:

- =clone_git=: =clone-git URL= clona un repositori git dins el
  directori =~/.emacs.d/site-lisp=. Si el repositori ja està clonat no
  fa res.

- =compile_package=: =compile_package NOM= compila els fitxers emacs
  lisp del directori =~/.emacs.d/site-lisp/<NOM>= i actualitza
  =~/.emacs.d/site-lisp/loaddefs.el=.

# Capçalera de l'arxiu generat a partir dels blocs de codi sh:

#+begin_src sh :tangle yes :exports none
  #!/bin/bash

  cd ~/.emacs.d/conf.d

#+end_src

** Tecles i /keymaps/ personalitzats

Cal definir els keymaps i regles generals per organitzar les
definicions de tecles globals i per modes.

Agrupar les tecles globals tenia sentit quan la configuració estava
repartida entre varis mòduls. Al agrupar-la tota en un únic document
=org= potser resulta més clar moure les assignacions de tecles al
corresponent =use-package=. No m'acaba d'agradar.

Pel que fa als keymaps /locals/ hi ha varies opcions:

- en =use-package= únicament es poden modificar tecles ja definides
  pel pròpi paquet.

- en =use-package= es pot modificar el /keymap/ local, sempre que el
  comandes siguin locals.

- altres?


#+BEGIN_QUOTE
Reconfiguracio de tecles globalment.  Per evitar conflictes, els
comandos personals els configuro sota el prefix C-c C-a i segueixo el
conveni de que els moduls que escric defineixen el seu propi
"subespai" de tecles (p.e. todo.el utilitza C-c C-a C-r).
#+END_QUOTE

** Directori =site-lisp=

Desenvolupar.

Dos directoris =site-lisp=, que ficar en cadascun, no abusar. Gestió.

* Configuració
** /Lexical binding/

El /lexical binding/ permet utilitzar clausures.

#+begin_src emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+end_src

** Depuració de la configuració

Ocasionalment açò pot ajudar a depurar errors en la configuració.

Per activar-ho cal canviar a =:tangle yes=.

#+begin_src emacs-lisp :tangle no
  (setq debug-on-error t)
#+end_src


** Inicialització

Aquesta secció definex la base sobre la que s'implementen la resta de
les seccions.

*** Funcions auxiliars

Funcions utilitzades en la pròpia configuració. Aquestes funcions no
poden dependre de biblioteques de tercers i no proveeixen
funcionalitat utilitzable directament per l'usuari, únicament per la
configuració. Les comandes d'usuari van en la secció [[id:02df8b30-de79-489f-b4c9-13162d5d2784][Comandes]].

**** =my/bind-keys=

No tinc clar quin /keymap/ es afectat per la clausula =:bind= de
=use-package=, la qüestió és que en alguns casos (configuració de
=paredit= p.e.) no acaba de funcionar com espero.

La funció =my/bind-keys= intenta fer menys verbosa la definició de
les tecles quan no queda més remei que fer-ho manualment.

#+begin_src emacs-lisp :tangle yes
  (defun my/bind-keys (map key-definitions)
    (dolist (item key-definitions)
      (let ((key (car item))
            (command (cadr item)))
        (define-key map (kbd key) command))))
#+end_src

Exemple:

#+begin_src emacs-lisp :tangle no
  (my/bind-keys some-mode-map
                '(("C-c f" do-foo)
                  ("C-c b" do-bar)))
#+end_src

**** =my/host-reachable=

Comprova si un host està disponible. La disponibilitat es determina
fent un ping.

S'utilitza principalment per condicionar parts de la configuració a la
disponibilitat de serveis en la xarxa local. Per exemple, a casa
executo un servidor privat de "melpa".

#+begin_src emacs-lisp :tangle yes
  (defun my/host-reachable (host)
    (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1" host)))
#+end_src

**** =arv/generate-lab-faces=

Genera /faces/:

#+begin_src emacs-lisp :tangle yes
  (require 'color)

  (defun arv/generate-lab-faces (name count &optional lightness saturation group-name)
    "Generate `count' faces named `<name>-01-face' to
  `<name>-nn-face' within the group `group-name'.

  `name' and `group-name' must be strings, not symbols.

  ,* `lightness' defaults to 45
  ,* `saturation' defaults to 40
  ,* `group-name' defaults to `<name>-faces'
  "
    (let ((group-name (intern (or group-name (concat name "-faces"))))
          (lightness (or lightness 45))
          (saturation (or saturation 40))
          (format-string (concat name "-%02i-face")))
      (custom-declare-group group-name nil "Autogenerated faces" :group 'faces)
      (cl-loop for i from 1 to count do
               (let* ((angle (* 2 pi (/ i (float count))))
                      (a (* saturation (cos angle)))
                      (b (* saturation (sin angle)))
                      (name (intern (format format-string i))))
                 (custom-declare-face name '((t nil))
                                      "Prova face."
                                      :group group-name)
                 (set-face-attribute
                  name nil
                  :foreground (apply 'color-rgb-to-hex (color-lab-to-srgb lightness a b)))
                 ))))
#+end_src

*** Instàncies múltiples

Ocasionalment l'entorn en que s'utilitza aquesta configuració pot ser
lleugerament diferent i pot requerir petites variacions, per exemple
la configuració de la impressora.

Per suportar aquesta necessitat cada /sistema/ pot tindre una
configuració diferent. Un sistema s'identifica mitjançant el valor de
la variable d'entorn =EMACS_INSTANCE= o, si no està definida, el nom
de /host/ (sense el domini). El nom del sistema és accessible en la
constant =arv/instance-name=.

#+begin_src emacs-lisp :tangle yes
  (defconst arv/emacs-customize-dir
    (arv/path-concat arv/emacs-conf-dir "customize")
    "Directori on es guarda la personalització de cada sistema.")

  (defconst arv/instance-name
    (or
     (getenv "EMACS_INSTANCE")
     (car (split-string (system-name) "\\.")))
    "Nom del sistema/instància.")

  (setq custom-file
        (arv/path-concat arv/emacs-customize-dir
                         (concat arv/instance-name ".el")))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

*** Repositoris de paquets

#+begin_src emacs-lisp :tangle yes
  (package-initialize)

  (setq package-archives
        '(("gnu"          . "https://elpa.gnu.org/packages/")
          ("casa"         . "https://a13x15.noip.me/melpa/packages/")
          ("melpa"        . "https://melpa.org/packages/")
          ))
#+end_src

Utilitzar =M-x package-refresh-contents= per recarregar la llista de
paquets.

*** =use-package=

La variable =use-package-always-pin= permet configurar el repositori
que s'utilitzarà quan un paquet no especifica la clausula =:pin=.

Sembla que és bastant estricte: al configurar el valor /melpa stable/
el paquet =rainbow-mode=, únicament disponible en el repositori /gnu/,
ha desaparegut. Ha calgut afegir =:pin gnu= per poder instal·lar-lo.

Mentre no activi el repositori /melpa/ no tinc cap preferència
respecte al repositori a utilitzar i preveig problemes si el fixo
(/pin/) globalment.

#+begin_src emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (customize-set-value 'use-package-minimum-reported-time 0.05)
  (customize-set-value 'use-package-verbose t)
  ;; (customize-set-value 'use-package-always-pin "melpa stable")

  (require 'use-package)
#+end_src

*** =auto-compile=                                               :desactivat:

No acava de funcionar (provat amb =psvn.el=), probablement per la meva
ignorancia, i ralentitza l'arranc. El desactivo fins que pugar
mirar-m'ho.

https://github.com/emacscollective/auto-compile

Intenta garantir que els arxius compilats (=.elc=) no estan desfasats
repecte del corresponent arxiu font (=.el=).

#+begin_src emacs-lisp :tangle no
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
#+end_src

En cas que l'arxiu =.elc= estigui desfasat carrega el =.el=.

#+begin_src emacs-lisp :tangle yes
  (setq load-prefer-newer t)
#+end_src

*** =transient=

https://github.com/magit/transient

Facilita contruir línies de comandes interactivament (s'utilitza en
=magit=).

#+begin_src emacs-lisp :tangle yes
  (use-package transient
    :ensure t)
#+end_src

*** Directori =site-lisp= local

El subdirectori =site-lisp= de la configuració s'utilitza per guardar
paquets no disponibles en els repositoris (elpa o git).

Tot i que no és habitual, els paquets poden necessitar canvis
esporàdics per resoldre errors, mantindre la compatibilitat etc. Per
facilitar-me la vida l'arxiu =loaddefs.el= es genera si no existeix o
està desactualitzat respecte als corresponents =.el=.

#+begin_src emacs-lisp :tangle yes
  (let* ((site-lisp-path (expand-file-name (arv/path-concat arv/emacs-conf-dir "site-lisp")))
         (generated-autoload-file (arv/path-concat site-lisp-path "loaddefs.el")))
    (unless (and (file-exists-p generated-autoload-file)
                 (null (cl-remove-if
                        (lambda (x) (or (string= generated-autoload-file x)
                                   (file-newer-than-file-p generated-autoload-file x)))
                        (directory-files site-lisp-path t "\\.el$"))))
      (update-directory-autoloads site-lisp-path))
    (load generated-autoload-file))
#+end_src

Encara que =use-package= permet definir /autoloads/ l'ús de
=loaddef.el= és recomanable i no penalitza el temps d'arranc de manera
apreciable.

*** Biblioteques addicionals

Biblioteques de funcions utilitzades en la configuració.

**** =cl-lib=                                                       :builtin:

Implementa funcionalitats de /common lisp/ en emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package cl-lib)
#+end_src

**** =f=
     :PROPERTIES:
     :ID:       22d6bbbb-d859-4388-8bdd-36df7c6cff48
     :END:

https://github.com/rejeep/f.el

Una API moderna per treballar amb arxius i directoris des d'emacs.

Pel tipus de paquet (biblioteca de funcions) s'hauria d'instal·lar
automàticament com una dependència i no directament, però alguns dels
meus paquets (no en elpa) la utilitzen.

#+begin_src emacs-lisp :tangle yes
  (use-package f
    :ensure t)
#+end_src

**** =s=

https://github.com/magnars/s.el

Col·lecció de funcions per manipular cadenes.

#+begin_src emacs-lisp :tangle yes
  (use-package s
    :ensure t)
#+end_src

*** Compatibilitat

Aquesta secció defineix funcions que faciliten mantindre la
compatibilitat amb diferents instal·lacios d'Emacs.

- Emacs 24 no defineix =string-greaterp= (ni =string>=), curiosament
  sí defineix =string-lessp= i =string<=.

  #+begin_src emacs-lisp :tangle yes
    (unless (fboundp 'string-greaterp)
      (defun string-greaterp (a b)
	(not (or (string= a b)
		 (string< a b)))))
  #+end_src

- Si compilo emacs en un entorn minimalista les funcions següents no
  estan definides:

  #+begin_src emacs-lisp :tangle yes
    (unless (fboundp 'scroll-bar-mode)
      (defun scroll-bar-mode (x)))

    (unless (fboundp 'mouse-wheel-mode)
      (defun mouse-wheel-mode (x)))
  #+end_src

** Informació personal

L'adreça d'e-mail pot variar depenent del sistema. Per defecte
s'inicialitza a partir de la variable d'entorn =EMAIL=. Probablement
sigui preferible a definir un valor fix en la configuració.

#+begin_src emacs-lisp :tangle yes
  (setq user-full-name "Alexis Roda"
        user-mail-address "alexis.roda.villalonga@gmail.com")
#+end_src
** Interfície d'usuari

#+begin_src emacs-lisp :tangle yes
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (customize-set-value 'inhibit-startup-screen t)
  ;; cursor blinks forever
  (customize-set-value 'blink-cursor-blinks -1)
#+end_src

** Tema

Crec que la millor forma d'organitzar la configuració de les /faces/
és concentrar-les en una única secció, facilita el canvi de tema.

*** Variables

Aquesta secció defineix variables relacionades amb les /faces/. Es
defineixen per garantir que existeixen pero el seu valor s'ha de
canviar, si escau, dins les funcions que personalitzen els temes, no
ací.

Color utilitzat en el cursor quan estem en mode /insert/.

#+begin_src emacs-lisp :tangle yes
  (defvar my/face-cursor-insert-background-color nil)
#+end_src

Color utilitzat en el cursor quan estem en mode /overwrite/.

#+begin_src emacs-lisp :tangle yes
  (defvar my/face-cursor-overwrite-background-color "purple")
#+end_src

*** Noves faces

Aquesta secció defineix noves faces utilitzades en la configuració. Es
defineixen per garantir que existeixen pero el valor s'ha de canviar,
si escau, dins les funcions que personalitzen els temes, no ací.

**** =hi-lock=

Faces utilitzades per ressaltar alguns elements. Empra un codi de tres
colors que ressembla un semàfor per indicar tres nivells de
/gravetat/, /atenció/ etc.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "hi-lock"
    (defface arv/hi-green
      '((((min-colors 88)) (:weight bold :foreground "black" :background "light green"))
        (t (:weight bold :background "green")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-orange
      '((((min-colors 88)) (:weight bold :foreground "black" :background "orange"))
        (t (:weight bold :background "orange")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-pink
      '((((min-colors 88)) (:weight bold :foreground "white" :background "magenta"))
        (t (:weight bold :background "magenta")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-red
      '((((min-colors 88)) (:weight bold :background "red1" :foreground "white"))
        (t (:weight bold :background "red" :foreground "white")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces))
#+end_src

*** doom-one

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-doom-one ()
    ;; El color dels comentaris contrasta poc amb el color de fons i
    ;; dificulta la lectura.

    (set-face-attribute 'font-lock-comment-face nil
                        :foreground "#83898d")

    ;; Els colors de =display-line-numbers= destaquen massa i em distreuen
    ;; del text que estic editant. Aquesta combinació utilitza un color més
    ;; fosc i ressalta la línia actual.

    (set-face-attribute 'line-number nil
                        :foreground "grey30"
                        :background "#202020")
    (set-face-attribute 'line-number-current-line nil
                        :foreground "#b2731d"
                        :background "#21242b")
    (set-face-attribute 'mode-line nil
                        :background "#b88fc2"
                        :foreground "black")
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "#b4b4b4"
                        :background "#68217a")

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui.

      (when (display-graphic-p)
        (set-face-attribute 'aw-leading-char-face nil
                            :height 4.0
                            :weight 'bold)))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-warning nil
                          :underline nil
                          :foreground "white"
                          :background "#d56d00")
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :foreground "white"
                          :background "#a80000"))

    (with-eval-after-load "diff-hl"
      (set-face-attribute 'diff-hl-change nil
                          :foreground "blue3"
                          :background "#333355")
      (set-face-attribute 'diff-hl-delete nil
                          :foreground "red3"
                          :background "#553333")
      (set-face-attribute 'diff-hl-insert nil
                          :foreground "green4"
                          :background "#335533"))

    (with-eval-after-load "magit"
      (set-face-attribute 'magit-diff-added nil
                          :foreground "#98be65"
                          :background "#21242b")
      ;; (set-face-attribute 'magit-diff-added-highlight nil
      ;;                     :foreground "#98be65"
      ;;                     :background "#21242b")
      (set-face-attribute 'magit-diff-removed nil
                          :foreground "#ff6c6b"
                          :background "#23272e")
      ;; (set-face-attribute 'magit-diff-removed-highlight nil
      ;;                     :foreground "#ff6c6b"
      ;;                     :background "#23272e"))
      )

    (with-eval-after-load "diff-mode"
      (set-face-attribute 'diff-hunk-header nil
                          :weight 'bold
                          :foreground "#282c34"
                          :background "#a9a1e1"
                          ;; extend no funciona, crec que degut a que la
                          ;; face no inclou el salt de línia. Ho deixo
                          ;; com una intenció.
                          :extend t)
      (set-face-attribute 'diff-added nil
                          :weight 'bold
                          :foreground "#98be65"
                          :background "#3e493d"
                          :extend t)
      (set-face-attribute 'diff-removed nil
                          :weight 'bold
                          :foreground "#ff6c6b"
                          :background "#4f343a"
                          :extend t)
      (set-face-attribute 'diff-header nil
                          :background "royalblue4"
                          :weight 'bold
                          :extend t)))
#+end_src

*** wombat

Personalització del tema /wombat/. El nom és circumstancial, és
l'últim tema fosc que he utilitzat abans d'animar-me a provar
=modus-operandi=. Aquesta configuració ha evolucionat segons he anat
canviant de tema (/zenburn/, /tango-dark/, /doom-one/ i /wombat/ que
recordi) i hauria de funcionar més o menys bé amb un tema fosc.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-wombat ()
    (set-face-attribute 'button nil
                        :foreground "#8ac6f2"
                        :underline t)

    ;; cursor
    (set-face-attribute 'cursor  nil
                        :background "#fce94f")

    ;; Els colors de =display-line-numbers= destaquen massa i em distreuen
    ;; del text que estic editant. Aquesta combinació utilitza un color més
    ;; fosc i ressalta la línia actual.

    (set-face-attribute 'line-number nil
                        :foreground "grey30"
                        :background "#202020")
    (set-face-attribute 'line-number-current-line nil
                        :foreground "#b2731d"
                        :background "grey20")

    ;; El color per defecte per la mode-line dificulta diferenciar les
    ;; finestres. El color que he triat no em convenç però almenys facilita
    ;; veure el límit de les finestres. Una altra combinació utilitza el
    ;; mateix groc que utilitzo a i3 per ressaltar la finestra activa, actiu
    ;; =#ffcc00= i inactiu =#aa8900=.

    (set-face-attribute 'mode-line nil
                        :box nil
                        :background "#00ad50"
                        :foreground "black"
                        :height 0.85)
    (set-face-attribute 'mode-line-highlight nil
                        :box nil
                        :background "orange"
                        :foreground "black")
    (set-face-attribute 'mode-line-inactive nil
                        :inherit 'mode-line
                        :box nil
                        :background "#004f24"
                        :foreground "#999999"
                        :weight 'light)

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui. Crec que la familia
      ;; es podria eliminar. Defineix altres aspectes a mes de colors,
      ;; suposo que és acceptable.

      (if (display-graphic-p)
          (set-face-attribute 'aw-leading-char-face nil
                              :family "ubuntu mono"
                              :height 4.0
                              :weight 'bold
                              :background "chartreuse"
                              :foreground "black")
        (set-face-attribute 'aw-leading-char-face nil
                            :background "white"
                            :foreground "black"))
      )

    (with-eval-after-load "apropos"
      (set-face-attribute 'apropos-symbol nil
                          :foreground "chartreuse"
                          :bold t)
      (set-face-attribute 'apropos-keybinding nil
                          :foreground "medium spring green"
                          ))

    (with-eval-after-load "compile"
      (set-face-attribute 'compilation-error nil
                          :underline nil
                          :weight 'normal))

    (with-eval-after-load "diff-hl"
      ;; En alguns temes (detectat en =doom-one=) la definició de les
      ;; faces de =diff-hl= té problemes quan el frame es parteix en dos
      ;; verticalment, en la finestra de la dreta no es visualitza
      ;; correctament. Funciona millor si s'utilitza un color solid
      ;; enlloc de ressaltar només la vora.

      (set-face-attribute 'diff-hl-change nil
                          :foreground "blue3"
                          :background "#333355")
      (set-face-attribute 'diff-hl-delete nil
                          :foreground "red3"
                          :background "#553333")
      (set-face-attribute 'diff-hl-insert nil
                          :foreground "green4"
                          :background "#335533"))

    (with-eval-after-load "dired"
      (set-face-attribute 'dired-directory nil
                          :foreground "#729fcf"))

    (with-eval-after-load "eldoc"
      (set-face-attribute 'eldoc-highlight-function-argument nil
                          :underline nil
                          :foreground "yellow"
                          :weight 'bold))

    (with-eval-after-load "emmet-mode"
      (set-face-attribute 'emmet-preview-input nil
                          :box nil)
      ;; No aconsegueixo redefinir el color, utilitza el de hightlight
      ;; (del que hereta). Aquesta face únicament s'utilitza, breument,
      ;; quan es confirma el resultat, en un flash.
      (set-face-attribute 'emmet-preview-output nil
                          :background "green"
                          :box nil))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :background "Firebrick4"))

    (with-eval-after-load "hl-line"
      (if (display-graphic-p)
          (set-face-attribute 'hl-line nil
                              :foreground "white"
                              :background "black")
        (set-face-attribute 'hl-line nil
                            :foreground "black"
                            :background "yellow"))
      (set-face-attribute 'hl-line nil
                          :underline nil))

    (with-eval-after-load "ido"
      (set-face-attribute 'ido-first-match nil
                          :background "pale green"
                          :foreground "black"))

    (with-eval-after-load "org"
      (set-face-attribute 'org-mode-line-clock nil
                          :background "green yellow")
      (set-face-attribute 'org-document-title nil
                          :foreground "pale turquoise"
                          :weight 'bold
                          :height 1.5)
      (set-face-attribute 'org-level-1 nil
                          :weight 'bold
                          :height 1.2)
      (set-face-attribute 'org-block-begin-line nil
                          :weight 'normal
                          :background "#202020")
      (set-face-attribute 'org-block nil
                          :background "black")
      (set-face-attribute 'org-block-end-line nil
                          :weight 'normal
                          :background "#202020"))

    (with-eval-after-load "rst"
      ;; customize-face (suposo) te problemes quan la llista
      ;; d'atributs esta buida, sembla que ho interpreta com "no
      ;; canviar res" enlloc de "borrar tots els atributs"

      (set-face-attribute 'rst-level-1 nil :background nil)
      (set-face-attribute 'rst-level-2 nil :background nil)
      (set-face-attribute 'rst-level-3 nil :background nil)
      (set-face-attribute 'rst-level-4 nil :background nil)
      (set-face-attribute 'rst-level-5 nil :background nil)
      (set-face-attribute 'rst-level-6 nil :background nil))

    (with-eval-after-load "term"
      ;; Els colors per defecte de =term= no em convencen. Aquesta
      ;; combinació m'agrada més:

      (custom-set-faces
       '(term-color-black ((t (:foreground "#242424" :background "#242424"))))
       '(term-color-red ((t (:foreground "#ef2929" :background "#ff1313"))))
       '(term-color-green ((t (:foreground "#8ae234" :background "#4e9a06"))))
       '(term-color-yellow ((t (:foreground "#fce94f" :background "#c4a000"))))
       '(term-color-blue ((t (:foreground "#729fcf" :background "#3465a4"))))
       '(term-color-magenta ((t (:foreground "#ad7fa8" :background "#75507b"))))
       '(term-color-cyan ((t (:foreground "#34e2e2" :background "#06989a"))))
       '(term-color-white ((t (:foreground "#eeeeec" :background "#d3d7cf"))))

       '(term-default-fg-color ((t (:inherit term-color-white))))
       '(term-default-bg-color ((t (:inherit term-color-black))))))

    (with-eval-after-load "transient"
      ;; El color que utilitza =transient= per ressaltar les opcions
      ;; /actives/ no destaca gaire.

      (custom-set-faces
       '(transient-argument ((t (:foreground "green" :weight bold))))))
    )
#+end_src

*** modus-operandi

Personalització de =modus-operandi=.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-modus-operandi ()

    ; redueix la mida del text de la modeline
    (set-face-attribute 'mode-line nil :height 94)
    (set-face-attribute 'mode-line-inactive nil :height 94)

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui.

      (when (display-graphic-p)
        (set-face-attribute 'aw-leading-char-face nil
                            :height 4.0
                            :weight 'bold)))

    (with-eval-after-load "hl-line"
      ;; la face hl-line definida en modus-operandi no combina bé amb
      ;; text clar sobre fons de colors (ho he detectat en alguns
      ;; hi-lock personalitzats amb text blanc sobre fons roig p.e.).
      ;; Pel momen prefereixo perdre els colors i que tot el text sigui
      ;; llegible.

      (when (display-graphic-p)
        (set-face-attribute 'hl-line nil
                            :foreground "black")))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-warning nil
                          :underline nil
                          :foreground "white"
                          :background "#d56d00")
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :foreground "white"
                          :background "#a80000"))

    (with-eval-after-load "rst"
      ;; customize-face (suposo) te problemes quan la llista
      ;; d'atributs esta buida, sembla que ho interpreta com "no
      ;; canviar res" enlloc de "borrar tots els atributs"

      (set-face-attribute 'rst-level-1 nil :background nil)
      (set-face-attribute 'rst-level-2 nil :background nil)
      (set-face-attribute 'rst-level-3 nil :background nil)
      (set-face-attribute 'rst-level-4 nil :background nil)
      (set-face-attribute 'rst-level-5 nil :background nil)
      (set-face-attribute 'rst-level-6 nil :background nil))

    )
#+end_src

*** Elements independents del tema

En aquesta secció es configuren elements independents del tema. Açò
exclou colors.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-faces-common ()
    (with-eval-after-load "org"
      (custom-set-faces
       '(org-document-title ((t (:height 1.5 :weight bold))))
       '(org-level-1 ((t (:inherit outline-1 :height 1.25 :weight bold))))
       '(org-level-2 ((t (:inherit outline-2 :height 1.188 :weight bold))))
       '(org-level-3 ((t (:inherit outline-3 :height 1.125 :weight bold))))
       '(org-level-4 ((t (:inherit outline-4 :height 1.063 :weight bold))))
       '(org-level-5 ((t (:inherit outline-5 :height 1.0 :weight bold)))))
      )
    )
#+end_src

*** Activació del tema

#+begin_src emacs-lisp :tangle yes
  ;; (load-theme 'wombat)
  ;; (my/customize-theme-wombat)

  ;; (use-package modus-operandi-theme
  ;;   :ensure t
  ;;   :config
  ;;   (my/customize-theme-modus-operandi))

  (use-package doom-themes
    :ensure t
    :config
    (load-theme 'doom-one)
    (my/customize-theme-doom-one)
    (my/customize-faces-common))

  (when (display-graphic-p)
    ;; x-display-pixel-height necessita un entorn graphic
    (set-face-attribute 'default nil
                        :family "JetBrains Mono"
                        :height (if (> (x-display-pixel-height) 1080) 94 88)))
#+end_src

** Paquets

Aquesta secció inclou la configuració de paquets d'us general.

*** =abbrev=                                                        :builtin:

[[info:emacs#Abbrevs][=abbrev=]] és semblant a =yasnippet= però menys potent. Tot i això
resulta útil com una mena d'autocorrector.

#+begin_src emacs-lisp :tangle yes
  (use-package abbrev
    :commands abbrev-mode
    :config
    (customize-set-value 'abbrev-file-name
                         (arv/path-concat arv/emacs-conf-dir "shared" "abbrev_defs"))
    (customize-set-value 'save-abbrevs t)
    :diminish "")
#+end_src

La variable =abbrev-mode= és buffer local amb el que no es pot
utilitzar =setq=. Canviant el valor per defecte s'aconsegueix activar
=abbrev= en tots els modes. Si no es vol utilitzar en un mode només
cal desactivar-lo des del /hook/ amb =(abbrev-mode 0)= o =(setq
abbrev-mode nil)=.

#+begin_src emacs-lisp :tangle yes
  (set-default 'abbrev-mode t)
#+end_src

La documentació recomana activar =abbrev= amb la funció =abbrev-mode=,
no assignant-li un valor a la variable =abbrev-mode=. Per una altra
banda, activar una funcionalitat sembla que no pertany a aquesta
secció sinó a la configuració d'algun mode
(=fundamental-mode=?). Finalment la funció =abbrev-mode= activa
=abbrev= en el buffer actual, per tant sí o sí s'ha de moure al
/hook/. Pel moment, mentre la configuració acaba de prendre forma, es
manté el canvi del valor per defecte de la variable.

*** =ace-window=

https://github.com/abo-abo/ace-window

=ace-window= agilitza la navegació entre les finestres.

#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :ensure t
    :commands ace-window
    :config
    (customize-set-value 'aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?ñ))
    (customize-set-value 'aw-scope 'frame))
#+end_src

*** =apropos=                                                       :builtin:

Mai l'he incorporat al meu workflow però sembla una bona forma de
trobar informació.

Per eficiència =apropos= únicament busca en un subconjunt de les
possibilitats. L'opció [[help:apropos-do-all][apropos-do-all]] controla l'espai de cerca i pot
ralentitzar-la. Si esdevé un problema caldrà restaurar el valor per
defecte (=nil=) i acostumar-se a utilitzar la comanda prefix (=C-u=).

#+begin_src emacs-lisp :tangle yes
  (customize-set-value 'apropos-do-all t)
#+end_src

*** =avy=

https://github.com/abo-abo/avy

=avy= agilitza el desplaçament dins un buffer.

Per defecte =avy= permet saltar a qualsevol finestra dins el frame
actual. No acostumo a saltar entre finestres i tendeix a generar
seqüències llargues de fins tres lletres, especialment en pantalles
grans. Per aquest motiu ho restringeixo a salts dins el buffer actiu.

#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :ensure t
    :commands (avy-goto-char-2
               avy-goto-line
               avy-goto-word-1)
    :config
    (setq avy-all-windows nil))
#+end_src

*** =beacon=

https://github.com/Malabarba/beacon

Whenever the window scrolls a light will shine on top of your cursor
so you know where it is.

#+begin_src emacs-lisp :tangle yes
  (use-package beacon
    :ensure t
    :config
    (customize-set-value 'beacon-color
                         (face-attribute 'cursor :background))
    (customize-set-value 'beacon-size 60)
    (customize-set-value 'beacon-blink-duration 0.5)
    (beacon-mode 1))
#+end_src

*** =browse-url=                                                    :builtin:

Integració d'emacs amb un navegador web extern.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'browse-url
    (customize-set-value 'browse-url-browser-function 'browse-url-generic)
    (customize-set-value 'browse-url-generic-program "firefox"))
#+end_src

*** =embrace=

https://github.com/cute-jumper/embrace.el

Facilita manipular (afegir, modificar, eliminar) parelles de
/parèntesis/.

#+begin_src emacs-lisp :tangle yes
  (use-package embrace
    :ensure t
    :commands embrace-commander)
#+end_src

*** =calendar=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'calendar
    (customize-set-value 'calendar-day-abbrev-array
                         ["Dg" "Dl" "Dt" "Dc" "Dj" "Dv" "Ds"])
    (customize-set-value 'calendar-day-name-array
                         ["Diumenge" "Dilluns" "Dimarts" "Dimecres"
                          "Dijous" "Divendres" "Dissabte"])
    (customize-set-value 'calendar-month-name-array
                         ["Gener" "Febrer" "Març" "Abril" "Maig"
                          "Juny" "Juliol" "Agost" "Setembre"
                          "Octubre" "Novembre" "Desembre"])
    (customize-set-value 'calendar-week-start-day 1))
#+end_src

*** =company=

https://github.com/company-mode/company-mode

/Complete anything/ és un /framework/ per completar text en emacs. Té
una arquitectura de /plugins/ i inclou múltiples /backends/.

#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :commands company-mode
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-idle-delay 0.5)
    (setq company-tooltip-align-annotations t)
    :diminish "")
#+end_src

*** =compilation=                                                   :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package compile
    :commands compile
    :config
    (customize-set-value 'compilation-message-face 'default))
#+end_src

*** =dash=

https://github.com/magnars/dash.el

A modern list api for Emacs. No 'cl required.

#+begin_src emacs-lisp :tangle yes
  (use-package dash
    :config (dash-enable-font-lock))
#+end_src

*** =diff-hl-mode=

https://github.com/dgutov/diff-hl

=diff-hl-mode= highlights uncommitted changes on the left side of the
window, allows you to jump between and revert them selectively.

[[https://github.com/syohex/emacs-git-gutter][git-gutter]] és una alternativa en cas que aquest no em convenci, però
sembla abandonat.

#+begin_src emacs-lisp :tangle yes
  (use-package diff-hl
    :ensure t
    :commands (diff-hl-margin-mode
               global-diff-hl-mode
               turn-on-diff-hl-mode)
    :config
    (use-package psvn
      :defer t
      :config
      (defadvice svn-status-update-modeline (after svn-update-diff-hl activate)
        (diff-hl-update)))
    (use-package magit
      :defer t
      :config
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+end_src

Açò anirà en algun /hook/ o configuració global:

#+begin_src emacs-lisp :tangle yes
  (global-diff-hl-mode)
  (unless (display-graphic-p)
    (diff-hl-margin-mode))
#+end_src

Aquesta paquet defineix algunes comandes interessants:

- =diff-hl-revert-hunk= (=C-x v n=)

- =diff-hl-prev-hunk= (=C-x v [=)

- =diff-hl-next-hunk= (=C-x v ]=)

*** =diff-mode=                                                     :builtin:

Per defecte al accedir a un /hunk/ amb les comandes =diff-hunk-next=
(=<tab>=) o =diff-hunk-prev= (=s-<tab>=) es refina la diferència
ressaltant els canvis individuals.

Tindre-ho activat per defecte em distreu, en general trobo que afegeix
massa soroll. Ho desactivo. Es pot activar en el /hunk/ actual amb la
comanda =diff-refine-hunk= (=C-r=).

#+begin_src emacs-lisp :tangle yes
  (use-package diff-mode
    :config
    (add-hook 'diff-mode-hook (lambda () (diff-auto-refine-mode 0)))
    :bind (:map diff-mode-map
                ("C-r" . diff-refine-hunk)))
#+end_src

*** =diminish=

#+begin_src emacs-lisp :tangle yes
  (use-package diminish
    :ensure t
    :commands diminish)
#+end_src

*** =dired=                                                         :builtin:

=dired= per defecte crea un nou buffer al visitar un directori o
fitxer. Personalment prefereixo evitar la proliferació de buffers.

#+begin_src emacs-lisp :tangle yes
  (defun arv/dired-up-directory ()
    "Visita el directori pare, en el mateix buffer."
    (interactive)
    (find-alternate-file ".."))
#+end_src

Permet crear un arxiu buid (quasi buid, conté un salt de línia) des de
=dired=. L'alternativa actual és obrir amb =C-x C-f=, modificar,
guardar i tancar un arxiu.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "dired"
    (require 'f)

    (defun my/dired-create-empty-file ()
      "Crea un arxiu buid en un buffer dired."
      (interactive)
      (let* ((arxiu (read-string "File name: "))
             (ruta (f-join (dired-current-directory) arxiu)))
        (unless (file-exists-p ruta)
          (shell-command  (format "touch '%s'" ruta) nil)
          (revert-buffer)))))
#+end_src

Afegim les comandes al /keymap/.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "dired"
    (my/bind-keys dired-mode-map
                  '(("M-<up>" arv/dired-up-directory)
                    ("^" arv/dired-up-directory)
                    ("C-m" dired-find-alternate-file)
                    ("c" my/dired-create-empty-file))))
#+end_src

*** =display-line-numbers=

En emacs 26 la numeració de línies ha millorat en quant a rendiment
respecte a =linum= i similars. Li donaré una segona oportunitat.

Personalment trobo més útil veure valors relatius a absoluts.

Em resulta molest que canviï l'ample per adaptar-se al nombre de
dígits, més quan utilizo numeració relativa que rarament requereix més
de dos dígits.

Per minimitzar l'efecte es fixa l'ample i es configura per mai
disminuir. Amb la pantalla vertical necessito fins 3 dígits (mostra
poc més de 100 línies). En la majoria d'arxius 3 és suficient
(rarament utilitzo arxius de més de 1000 línies). En arxius més llargs
pot creixer si cal.

Preferiria que mostrés el valor zero per la línia actual (estic
acostumat a consultar la línia actual en la /modeline/) i evitar el
creixement però no sembla que sigui possible configurar-ho.

#+begin_src emacs-lisp :tangle yes
  (defun my/enable-line-numbers-mode ()
    ;; HACK: en un parell de llocs de la configuració activo
    ;; display-line-numbers-mode. El problema és que si el desactivo i
    ;; l'activo utiliza numeració absoluta. Mentre esbrino com
    ;; configurar-ho, aquesta funció ho centralitza.
    (display-line-numbers-mode 1)
    (setq display-line-numbers 'relative))

  (setq display-line-numbers-grow-only t
        display-line-numbers-width-start 3)
#+end_src

*** =ediff=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ediff
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

*** =eglot=

Client =lsp= (/language server protocol/). Aquesta secció conté
configuració global. La configuració de cada llenguatge es fa en la
secció /mode/ corresponent.

Una alternativa és =lsp-mode=. No he pogut fer-lo funcionar amb la
cpctelera (crec que el problema és de =clangd= no de =lsp-mode=). M'ha
semblat una mica intrusiu.

#+begin_src emacs-lisp :tangle yes
  (use-package eglot
    :ensure t
    :commands eglot)
#+end_src

*** =eldoc=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package eldoc
    :commands eldoc-mode
    :diminish "")
#+end_src

*** =electric-pair=                                                 :builtin:

Activa globalment el mode =electric-pair=: al inserir un parèntesi
(clau, claudàtor etc.) obert automàticament s'insereix el corresponent
parèntesi tancat.

#+begin_src emacs-lisp :tangle yes
  (electric-pair-mode 1)
#+end_src

Es desactiva en el minibuffer, vull valorar si és més una moléstia o
una ajuda:

#+begin_src emacs-lisp :tangle yes
  (defun my/inhibit-electric-pair-mode-in-modeline (char)
    (minibufferp))

  (setq electric-pair-inhibit-predicate
        #'my/inhibit-electric-pair-mode-in-modeline)
#+end_src

*** =engine-mode=

https://github.com/hrs/engine-mode

=engine-mode= facilita integrar dins emacs diferents cercadors web.

#+begin_src emacs-lisp :tangle yes
  (use-package engine-mode
    :ensure t
    :config
    (engine-mode t)

    ;; els engines s'ordenen per keybinding per facilitar identificar
    ;; els conflictes al definir les tecles

    (defengine diec2
      "dlc.iec.cat/results.asp?txtEntrada=%s"
      :keybinding "c"
      :term-transformation-hook (lambda (term) (encode-coding-string term latin-1)))

    (defengine django
      "https://docs.djangoproject.com/search/?q=%s&release=11"
      :keybinding "d")

    (defengine emacs-stack-exchange
      "http://emacs.stackexchange.com/search?q=%s"
      :keybinding "e")

    (defengine google
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g")

    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "G")

    (defengine rfcs
      "http://pretty-rfc.herokuapp.com/search?q=%s"
      :keybinding "r")

    (defengine stack-overflow
      "https://stackoverflow.com/search?q=%s"
      :keybinding "s")

    (defengine sdl
      "http://wiki.libsdl.org/%s"
      :keybinding "S")

    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
      :keybinding "w")

    (defengine wordreference
      "http://www.wordreference.com/redirect/translation.aspx?w=%s&dict=enes"
      :keybinding "W")

    (defengine z80heaven
      "http://z80-heaven.wikidot.com/instructions-set:%s"
      :keybinding "z"))
#+end_src

*** =expand-region=

https://github.com/magnars/expand-region.el

#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t
    :commands er/expand-region)
#+end_src

*** =figlet=                                                         :manual:

https://gist.github.com/digash/392649

Insereix text gran. Requereix la comanda externa =figlet=.

#+begin_src emacs-lisp :tangle yes
  (use-package figlet
    :ensure nil
    :load-path "conf.d/site-lisp"
    :config
    (setq figlet-font-dir "/usr/share/figlet")
    (setq figlet-default-font "standard")
    :commands (figlet
               figlet-no-comment
               banner
               banner-no-comment))
#+end_src

*** =flymake=                                                       :builtin:

Aparentment he estat utilitzant =flycheck=. Vaig a donar-li una
oportunitat a =flymake=. En les comparatives que he llegit deixen
millor a =flycheck= però afegeix una dependència externa.

#+begin_src emacs-lisp :tangle yes
  (use-package flymake
    :commands flymake-mode)
#+end_src

*** =font-lock=                                                     :builtin:

#+begin_src emacs-lisp :tangle yes
  (global-font-lock-mode t)
  (customize-set-value 'font-lock-maximum-decoration t)
#+end_src

No tinc clar si activar-lo ací és preferible a fer-ho en algun hook.

*** =grin=

=grin= és una utilitat tipus =grep=, escrita en python. Es pot
descarregar des de https://pypi.python.org/pypi/grin.

La integració amb emacs està basada en [[https://bitbucket.org/dariusp686/emacs-grin/src][emacs-grin]].

#+begin_src emacs-lisp :tangle yes
  (use-package grin
    :load-path "site-lisp")
#+end_src

Al estar escrita en python pot donar problemes si s'executa dins un
directori amb codi python que conté mòduls que poden interferir amb
els =import= que fa =grin=. Ho vaig detectar, crec recordar, intentant
executar-lo dins el =site-packages= d'un /virtualenv/, no recordo els
detalls concrets.

=ag=[[[https://github.com/ggreer/the_silver_searcher][enllaç]]] és una alternativa semblant, escrita en C, per tant més
ràpida i que no té conflictes amb arbres de codi python.

El que em tira enrere per canviar és la interfície del mòdul
=ag.el=[[[https://github.com/Wilfred/ag.el][enllaç]]], defineix moltes comandes per fer diferents tipus de
cerques (text en directori, text en directori només en certs arxius,
regex en directori, text en projecte, text en certs arxius del
projecte, regex en projecte ...). Massa comandes/combinacions de
tecles que recordar i poca flexibilitat. M'agrada més l'enfoc de
=grin.el=, una única comanda que demana el directori i la línia de
comandes.

El problema amb =grin= és anecdòtic en el meu cas d'us i no hi ha
urgència en fer el canvi. Açò és més un recordatori.

*** =hi-lock=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package hi-lock
    :diminish "")
#+end_src

*** =highlight-indentation=

https://github.com/antonj/Highlight-Indentation-for-Emacs

=highlight-indentation= mostra /regles/ verticals per facilitar
alinear el text. No l'utilitzo però qui sap si alguna vegada pot ser
útil.

#+begin_src emacs-lisp :tangle yes
  (use-package highlight-indentation
    :ensure t
    :commands (highlight-indentation-mode
               highlight-indentation-current-column-mode))
#+end_src

*** =hippie-expand=                                      :builtin:desactivat:

Exemple de funció que proveeix candidats a =hippie-expand= a partir
dels /TAGS/.

#+begin_src emacs-lisp :tangle no
  (defun try-expand-tags (old)
    "Funcio compatile amb `hippie-expand' per expandir tags.

  Argument OLD nil la primera vegada que es crida, t les seguents."
    ;; @NOTE: alex 2014-08-02 16:30:17: Aquesta funció s'utilitza amb
    ;; `make-hippie-expand-function', en eixe punt el mòdul
    ;; `hippie-expand' estarà carregat, motiu pel que no es requereix el
    ;; mòdul ni es defineix cap autoload. De la mateixa forma la funció
    ;; `tags-complete-tag' es carrega al inicialitzar emacs (mòdul
    ;; `compat'), amb lo que està disponible.
    (unless old
      (let ((start-point (save-excursion
                           (backward-word 1)
                           (point))))
        (he-init-string start-point (point))
        (setq he-expand-list (sort
                              (tags-complete-tag he-search-string nil t)
                              'string-lessp))))
    (while (and he-expand-list
                (he-string-member (car he-expand-list) he-tried-table))
      (pop he-expand-list))
    (if (null he-expand-list)
        (progn
          (when old (he-reset-string))
          ())
      (he-substitute-string (car he-expand-list))
      (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
      (pop he-expand-list)
      t))
#+end_src

*** =hl-line=                                                       :builtin:
    :PROPERTIES:
    :ID:       ea3e7059-fedc-44b2-b1d6-55e3326d050e
    :END:

Ressalta la línia on es troba el cursor actualment.

#+begin_src emacs-lisp :tangle yes
  (use-package hl-line
    :commands global-hl-line-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (global-hl-line-mode t)
#+end_src

Activar el mode probablement pertany a algun hook, o, al ser global, a
la configuració de un mode.

Aquesta funció desactiva =global-hl-line-mode= en el buffer en que
s'executa. Està pensada per cridar-la des d'un /hook/.

#+begin_src emacs-lisp :tangle yes
  (defun my/disable-global-hl-mode-locally ()
    (setq-local global-hl-line-mode nil))
#+end_src

*** =hydra=

https://github.com/abo-abo/hydra

#+begin_src emacs-lisp :tangle yes
  (use-package hydra
    :ensure t
    :defer nil)
#+end_src


*** =ibuffer=                                                       :builtin:

=ibuffer= resulta especialment útil quan cal gestionar molts buffers.

Fins ara he estat utilitzant =ebuff-menu= i, al ser /elèctric/,
resulta una mica més àgil si hi ha pocs buffers.

Encara falta provar =buffer-menu=.

#+begin_src emacs-lisp :tangle yes
  (use-package ibuffer
    :commands ibuffer)
#+end_src

*** =ibuffer-vc=

https://github.com/purcell/ibuffer-vc

Permet agrupar els buffers en =ibuffer= pel repositori de control de
revisions al que pertanyen.

S'activa amb la comanda =ibuffer-vc-set-filter-groups-by-vc-root=.

#+begin_src emacs-lisp :tangle yes
  (use-package ibuffer-vc
    :ensure t)
#+end_src

He detectat un comportament estrany en que els buffers =*Help*=,
=*Buffer List*= i =*Flymake log*= apareixen dins un grup vc quan
sembla més lògic que apareguin en el grup =[ Default ]=.

*** =ido=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :commands (ido-mode ido-everywhere)
    :config
    ;; Inhibit switching to other directory when no matches are found in
    ;; the current directory.
    (customize-set-value 'ido-auto-merge-work-directories-length -1)
    (customize-set-value 'ido-enable-flex-matching t)
    (customize-set-value 'ido-ignore-directories
                         '("\\`CVS/" "\\`\\.\\./" "\\`\\./" "\\`\\.svn/" "\\`\\.ropeproject/"))
    (customize-set-value 'ido-max-work-directory-list 10)
    (setq ido-save-directory-list-file "~/.emacs.d/ido.last")

    ;; Mostra el buffer en la finestra activa encara que sigui visible
    ;; en un altre frame.
    (setq ido-default-buffer-method 'select-window))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (ido-mode 1)
  (ido-everywhere 1)
#+end_src

Personalment prefereixo que els elements es mostrin verticalment
enlloc d'horitzontalment:

#+begin_src emacs-lisp :tangle yes
  (use-package ido-vertical-mode
    :ensure t
    :after ido
    :config
    (ido-vertical-mode 1)
    (add-hook 'ido-setup-hook
              (lambda ()
                ;; more intuitive keybinds for vertical-mode
                (my/bind-keys ido-completion-map
                              '(("<down>" ido-next-match)
                                ("<up>" ido-prev-match)
                                ("<left>" ido-prev-match-dir)
                                ("<right>" ido-next-match-dir)
                                ("M-<left>" ido-prev-work-directory)
                                ("M-<right>" ido-next-work-directory))))))
#+end_src

També m'agrada utilitzar =ido= allí on sigui possible, malauradament
~(ido-everywhere 1)~ és limitat i només l'activa per seleccionar
buffers i arxius.

#+begin_src emacs-lisp :tangle yes
  (use-package ido-completing-read+
    :ensure t
    :after ido
    :config
    (ido-ubiquitous-mode 1))
#+end_src

*** =lorem-ipsum=                                                    :manual:

https://github.com/jschaf/emacs-lorem-ipsum

No està disponible als repositoris estable. No és un tipus de codi que
hagi de canviar/millorar en el futur així que es clona:

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/jschaf/emacs-lorem-ipsum.git
  ./scripts/compile_package emacs-lorem-ipsum
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package lorem-ipsum
    :ensure nil
    :load-path "site-lisp/emacs-lorem-ipsum"
    :commands (lorem-ipsum-insert-paragraphs
               lorem-ipsum-insert-sentences
               lorem-ipsum-insert-list))
#+end_src

*** =magit=

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands (magit-status
               magit-dispatch
               magit-file-dispatch))
#+end_src

*** =minions=

https://github.com/tarsius/minions

Agrupa tots els /indicadors/ dels /minor-modes/ en un menú. La
/modeline/ queda molt més neta.

No m'agrada que no es puga deixar indicadors en la /modeline/, tots
van al menú. Pel meu us afecta a =flymake= que mostra el nombre
d'errors en la modeline.

Llevat d'aquest detall m'agrada que no requreixi configuració, al
contrari que =diminish=. Li donaré una oportunitat.

#+begin_src emacs-lisp :tangle yes
  (use-package minions
    :ensure t
    :config (minions-mode 1))
#+end_src

*** =modeline=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; oculta el número de la columna
  (column-number-mode 0)
  ;; (line-number-mode 0)

  ;; no cal desaprofitar espai quan el gestor de finestres/escriptori ja
  ;; mostra la data
  (display-time-mode 0)
#+end_src

*** =mouse=                                                         :builtin:

Prefereixo que al clicar en la roda del ratolí s'enganxi en la posició
del /point/ enlloc de la del punter del ratolí, dóna més control.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'mouse
    (setq mouse-yank-at-point t)

    (setq mouse-buffer-menu-maxlen 25)
    (setq mouse-buffer-menu-mode-mult 10))
#+end_src

*** =multi-line=

https://github.com/IvanMalison/multi-line

=multi-line= facilita formatar /llistes l'elements/ (paràmetres d'una
funció, elements d'una llista etc.) en una o vàries línies, emprant
diferents formats.

#+begin_src emacs-lisp :tangle yes
  (use-package multi-line
    :ensure t
    :commands multi-line)
#+end_src

*** =mwheel=                                                        :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; aparentment `mouse-wheel-mode' s'activa per defecte
  (mouse-wheel-mode t)

  ;; quantitat a moure quan es gira la roda en combinació amb una tecla
  ;; modificadora
  (setq mouse-wheel-scroll-amount
        '(5
          ((shift) . 1)
          ((control) . nil)))

  (setq mouse-wheel-follow-mouse t)
#+end_src

*** =outline=                                            :builtin:desactivat:

Codi tret de:

http://www.emacswiki.org/emacs/OutlineMinorMode

Defineix funcions que fan l'us del =outline-mode= més intuitiu
(semblant al comportament de l'explorer de windows) i les assigna a
combinacions de tecles més accesibles.

#+begin_src emacs-lisp :tangle no
  (defun arv/outline-body-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (and (not (eobp))
           (progn (forward-char 1)
                  (not (outline-on-heading-p))))))

  (defun arv/outline-body-visible-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-subheadings-p ()
    (save-excursion
      (outline-back-to-heading)
      (let ((level (funcall outline-level)))
        (outline-next-heading)
        (and (not (eobp))
             (< level (funcall outline-level))))))

  (defun arv/outline-subheadings-visible-p ()
    (interactive)
    (save-excursion
      (outline-next-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-hide-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-body-p)
                  (arv/outline-body-visible-p))
             (hide-entry)
             (hide-leaves))
            (t
             (hide-subtree)))))

  (defun arv/outline-show-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-subheadings-p)
                  (not (arv/outline-subheadings-visible-p)))
             (show-children))
            ((and (not (arv/outline-subheadings-p))
                  (not (arv/outline-body-visible-p)))
             (show-subtree))
            ((and (arv/outline-body-p)
                  (not (arv/outline-body-visible-p)))
             (show-entry))
            (t
             (show-subtree)))))

  (with-eval-after-load "outline"
    (my/bind-keys outline-mode-map
                  '(("S-<left>" arv/outline-hide-more)
                    ("S-<right>" arv/outline-show-more)
                    ("S-<up>" outline-previous-visible-heading)
                    ("S-<down>" outline-next-visible-heading)))

    (my/bind-keys outline-minor-mode-map
                  '(("S-<left>" arv/outline-hide-more)
                    ("S-<right>" arv/outline-show-more)
                    ("S-<up>" outline-previous-visible-heading)
                    ("S-<down>" outline-next-visible-heading))
                  ;; prova per moure blocs, no acava de funcionar
                  ;;(define-key map (kbd "S-s-<up>") 'outline-move-subtree-up)
                  ;;(define-key map (kbd "S-s-<down>") 'outline-move-subtree-down)
                  ))
#+end_src

*** =projectile=                                                 :desactivat:

https://github.com/bbatsov/projectile

Gestió de /projectes/ (en un sentit molt relaxat).

Vaig començar a utilitzar-lo per facilitar la navegació dins el codi
font de /Hera/ però vaig acabar implementant una solució específica.

Pel moment es deixa desactivat, a l'espera de veure si trobo a faltar
cap funcionalitat.

#+begin_src emacs-lisp :tangle no
  (use-package projectile
    :ensure t
    :commands projectile-global-mode
    :config

    ;; native indexing is slower but allows for file/directory filtering
    (setq projectile-indexing-method 'native)

    ;; enable caching in order to speedup native indexing
    (setq projectile-enable-caching t)

    (setq projectile-mode-line '(:eval (format " PRJ[%s]" (projectile-project-name))))

    (projectile-global-mode))
#+end_src

*** =psvn=                                                           :manual:

http://www.xsteve.at/prg/emacs/psvn.el

Integració amb el control de versions /subversion/.

Aquesta comanda desfà un /hunk/. Es pot obtindre el mateix efecte amb
la comanda =diff-apply-hunk= però demana confirmació sobre si es vol
aplicar el /hunk/ a la inversa.

#+begin_src emacs-lisp :tangle yes
  (defun my/diff-undo-hunk ()
    "Desfà un hunk."
    (interactive)
    (diff-apply-hunk t))
#+end_src

=svn-status-show-svn-diff= no modifica la finestra activa. Aquesta
funció executa =svn-status-show-svn-diff= i després activa la finestra
que mostra el buffer =*svn diff*=.

#+begin_src emacs-lisp :tangle yes
  (defun my/svn-status-show-svn-diff (arg)
    "Consultar `svn-status-show-svn-diff'."
    (interactive "P")
    (svn-status-show-svn-diff arg)
    (when (get-buffer-window "*svn-diff*")
      (switch-to-buffer-other-window "*svn-diff*")))
#+end_src

No estic segur de si prefereixo aquest comportament, l'anterior o els
dos. El temps dirà. Pel moment assignaré el nou comportament a ~=~ i
l'original a ~M-==~.

La comanda =svn-log-edit-erase-edit-buffer= esborra tot el contingut
del buffer, incloent els comentaris amb la llist d'arxius modificats.
Aquesta comanda és mens agressiva i manté els comentaris.

#+begin_src emacs-lisp :tangle yes
  (defun my/svn-log-edit-erase-edit-buffer ()
    (interactive)
    (set-buffer svn-log-edit-buffer-name)
    (save-excursion
      (goto-char (point-min))
      (keep-lines "^##.*")))
#+end_src

Configura el mode.

#+begin_src emacs-lisp :tangle yes
  (use-package psvn
    :load-path "conf.d/site-lisp"
    :commands (svn-status
               svn-file-show-svn-diff
               svn-status-show-svn-log)
    :config
    (customize-set-value 'svn-status-default-log-arguments
                         '("-v" "--stop-on-copy"))
    (customize-set-value 'svn-status-verbose t)
    (customize-set-value 'svn-status-hide-unmodified t)
    (my/bind-keys
     svn-status-diff-mode-map
     '(("a" diff-apply-hunk)
       ("u" my/diff-undo-hunk)))
    (my/bind-keys
     svn-status-mode-map
     '(("=" my/svn-status-show-svn-diff)
       ("M-=" svn-status-show-svn-diff)))
    (my/bind-keys
     svn-log-edit-mode-map
     '(("C-c C-z" my/svn-log-edit-erase-edit-buffer))))
#+end_src

Amb =magit= al executar la comanda =status= es fa des de l'arrel (el
directori que conté =.git=) mentre que amb =psvn= es fa des del
directori actual. No tinc clar quin enfoc és preferible.

Aquesta comanda implementa l'enfoc de git en subversion per veure si
el prefereixo.

#+begin_src emacs-lisp :tangle yes
  (defun x-my/svn-status ()
    ""
    (interactive)
    (let ((root (locate-dominating-file default-directory ".svn")))
      (if root
          (svn-status root)
        (user-error "No s'ha trobat '.svn'."))))
#+end_src

El buffer per editar els missatge de commit defineix comandes útils
que mai recordo. Aquest és un intent de recordar-les.

#+begin_src emacs-lisp :tangle yes
  (customize-set-value
   'svn-log-edit-header
   (concat "## Lines starting with '## ' will be removed from the log message.\n"
           "##\n"
           "## Partial list of commands\n"
           "## C-c C-d    svn-log-edit-svn-diff\n"
           "## C-c TAB    svn-log-edit-svn-status\n"
           "## C-c C-l    svn-log-edit-svn-log\n"
           "## C-c C-z    svn-log-edit-erase-edit-buffer\n"
           "## C-c C-c    log-edit-done\n"
           "## C-c C-k    log-edit-kill-buffer\n"
           "##\n"))
#+end_src

*** =rainbow=

https://elpa.gnu.org/packages/rainbow-mode.html

Afegeix un fons de color als noms dels colors.

#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode
    :diminish "")
#+end_src

*** =smex=

https://github.com/nonsequitur/smex

=smex= és una versió millorada de =M-x=. Basada en /ido/ facilita
l'accés a les comandes utilitzades recentment i a les més freqüents.

#+begin_src emacs-lisp :tangle yes
  (use-package smex
    :ensure t
    :commands smex
    :config
    (setq smex-save-file (arv/path-concat user-emacs-directory "smex-items"))
    (smex-initialize))
#+end_src

*** =sql=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package sql-mode
    :commands sql-mode
    :config
    (add-hook 'sql-mode-hook
              (lambda ()
                (set-variable 'show-trailing-whitespace t)
                (sql-highlight-postgres-keywords))))
#+end_src

*** =subword=, =superword=                                          :builtin:

#+begin_src emacs-lisp :tangle yes
  (defun arv/wm-cycle ()
    "Cycle word-mode:
  subword-mode -> superword-mode -> nothing -> subword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (superword-mode
      (subword-mode 0)
      (superword-mode 0))
     (t
      (subword-mode 1)
      (superword-mode 0))))

  (defun arv/wm-cycle-2 ()
    "Cycle word-mode:
  subword-mode <-> superword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (t
      (subword-mode 1)
      (superword-mode 0))))
#+end_src

*** =swiper=

#+begin_src emacs-lisp :tangle yes
  (use-package swiper
    :ensure t
    :commands swiper)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/swiper-symbol-with-prefix (p)
    "Like swiper, unless prefix argument is provided.
  With a prefix argument P, isearch for the symbol at point."
    (interactive "P")
    (let ((current-prefix-arg nil))
      (if p (swiper (thing-at-point 'symbol t))
        (swiper))))
#+end_src

*** =tab-mode=                                                      :builtin:

Suport per múltiples pestanyes on cada pestanya té el seu propi layout
de finestres.

#+begin_src emacs-lisp :tangle yes
  (when (version<= "27" emacs-version)
    (use-package tab-bar
      :config
      ;; TODO: aquesta configuració amaga la barra de pestanyes. Per
      ;; tindre una referència estaria be mostrar el nom de la pestanya
      ;; activa en la modeline.
      ;; (customize-set-value 'tab-bar-show nil)

      ;; mentre m'acostumo al funcionament es mostren les pestanyes
      (customize-set-value 'tab-bar-show t)
      (customize-set-variable 'tab-bar-new-tab-choice #'ido-switch-buffer)
      (tab-bar-history-mode)))
#+end_src

*** =term=                                                          :builtin:

Desactiva =global-hl-line-mode= en la terminal.

#+begin_src emacs-lisp :tangle yes
  (add-hook 'term-mode-hook
            (lambda ()
              (my/disable-global-hl-mode-locally)))
#+end_src

*** =uniquify=                                                      :builtin:

=uniquify= és responsable d'assignar noms únics als buffers quan hi ha
conflictes. Suporta diferents estils.

#+begin_src emacs-lisp :tangle yes
  (use-package uniquify
    :defer t
    :config
    (customize-set-value 'uniquify-buffer-name-style 'reverse))
#+end_src

*** =which-key=

https://github.com/justbur/emacs-which-key

=which-key= mostra les combinacions de tecles disponibles.

#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :commands which-key-mode
    :config
    (setq which-key-idle-delay 0.75)
    (setq which-key-sort-order 'which-key-description-order)
    (which-key-setup-side-window-right)
    :diminish "")
#+end_src

#+begin_src emacs-lisp :tangle yes
  (which-key-mode 1)
#+end_src

*** =workgroups=                                                 :desactivat:

Permet definir /workgroups/ (distribucions de finestres emacs) i
alternar entre ells.

Mai vaig aconseguir integrar-lo en el meu workflow i el paquet ja no
és mantingut. Es manté com un recordatori.

#+begin_src emacs-lisp :tangle no
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))
(workgroups-mode 1)
(setq wg-morph-on nil)

(set-face-attribute 'wg-mode-line-face nil
                    :foreground "black"
                    :background "#2fadff")
#+end_src

*** =xt-mouse=                                           :builtin:desactivat:

Afegeix suport mínim pel ratolí quan emacs s'executa en una terminal:

#+begin_src emacs-lisp :tangle no
  (unless (display-graphic-p)
    (use-package xt-mouse
      :config (xterm-mouse-mode)))
#+end_src

20190629: no aprofito la funcionalitat i en contrapartida perdo la
possibilitat que oferix X de seleccionar amb el ratoli.

*** =yasnippet=

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :config
    (add-to-list 'yas-snippet-dirs
                 (arv/path-concat arv/emacs-conf-dir "shared" "yasnippet"))
    (setq yas-prompt-functions '(yas-ido-prompt yas-x-prompt yas-completing-prompt))
    (add-to-list 'auto-mode-alist '("\\.yas$" . snippet-mode))
    :diminish yas-minor-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
    (yas-global-mode 1)
#+end_src

En la [[https://github.com/joaotavora/yasnippet/blob/5a29fe67d70de3749e30ebb37206395b4d1a51a8/NEWS][release 0.13]] es van eliminar tots els snippets del paquet, s'han
mogut al paquet =yasnippet-snippets=.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :ensure t)
#+end_src

** Modes

Aquesta secció inclou la configuració dels /modes/ que utilitzo
habitualment.

L'estructura utilitzada per documentar/configurar els modes és /work
in progress/ però l'organització següent sembla raonable:

#+begin_src org :tangle no
  ,*** mode
  ,**** =paquet 1=
  ,**** =paquet 2=
  ...
  ,**** =paquet N=
  ,**** Funcions d'utilitat
  ,**** Combinacions de tecles
  ,**** /Hook/
#+end_src

Tot i que =use-package= permet definir les tecles emprant la directiva
=:bind= trobo més pràctic agrupar totes les definions en una
secció. Un avantatge de =:bind= és que defineix automàticament
=autoloads= pels simbols que no son funcions (segons =fboundp=).

*** ensamblador Z80

Recull de paquets i configuracions relacionades amb la programació en
ensamblador del Z80 i [[https://github.com/lronaldo/cpctelera][cpctelera]].

**** =sdz80-mode=

Amplia la funcionalitat de =asm-mode= afegint elements relacionats amb
el z80.

#+begin_src emacs-lisp :tangle yes
  (use-package sdz80-mode
    :ensure t
    :commands sdz80-mode)
#+end_src

L'activo per tots els arxius =.s=.

He provat de configurar-ho via =.dir_locals.el= associant a =asm-mode=
l'execució de =sdz80-mode= però sembla que entra en un bucle infinit
(=sdz80-mode= es deriva de =asm-mode=). Pel moment no tinc previst
programar en altres ensambladors apart del Z80 així que pel moment no
és un problema.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.s\\'" . sdz80-mode))
#+end_src

**** =z80count=

Comptabilitza els cicles requererits per cada instrucció. Requereix la
comanda externa [[https://github.com/reidrac/z80count][=z80count=]].

#+begin_src emacs-lisp :tangle yes
  (use-package z80count
    :ensure t)
#+end_src

**** Associació d'arxius

Els arxius =.lst= generats per =asz80= s'obren per defecte en
=conf-mode=. Prefereixo utilitzar =fundamental-mode=.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.lst\\'" . fundamental-mode))
#+end_src

*** C

Idees per mirar:

- https://cestlaz.github.io/posts/using-emacs-32-cpp/

- https://www.youtube.com/watch?v=5FQwQ0QWBTU

- https://www.youtube.com/watch?v=GuEqRmCjy6E


**** gtk-doc

https://github.com/federicomenaquintero/gnome-emacs-utils

Funcions variades per facilitar el desenvolupament de/amb gnome.
M'interessa la funcionalitat per generar comentaris de les funcions.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/federicomenaquintero/gnome-emacs-utils
  ./scripts/compile_package gnome-emacs-utils
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package gtk-doc
    :ensure nil
    :load-path "site-lisp/gnome-emacs-utils"
    :commands (gtk-doc-insert
               gtk-doc-insert-section))
#+end_src

**** cc-mode

Configuració del c-mode.

#+begin_src emacs-lisp :tangle yes
  (use-package cc-mode
    :commands (c-mode c++-mode)
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (setq indent-tabs-mode nil)
                (setq c-default-style "k&r")
                (setq c-basic-offset 4)
                ;; alineació dels arguments d'una funció
                (c-set-offset 'arglist-intro '+)
                (c-set-offset 'arglist-close nil)
                ;; company-mode
                (company-mode t))))
#+end_src

**** lsp

=eglot= recomana(?) utilitzar [[https://github.com/MaskRay/ccls][ccls]] com /language server/:

#+begin_src sh :tangle no
  sudo apt install ccls
#+end_src

Es pot configurar per /projecte/ creant [[https://github.com/MaskRay/ccls/wiki/Project-Setup#ccls-file][l'arxiu .ccls]] en /l'arrel del
projecte/ (on està el directori =.git= o =.svn= imagino). Per la
cpctelera utilitzo:

#+begin_src text
aroda@turing:assault$ cat .ccls
clang
-I/home/aroda/.local/src/cpctelera/cpctelera/src/
#+end_src

A menys que s'utilitzin /includes/ en rutes no estàndards crec que no
cal configurar res. No tinc clar si cal que existeixi l'arxiu encara
que estigui buid.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "cc-mode"
    (add-hook 'c-mode-common-hook
              (lambda ()
                (eglot-ensure))))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "cc-mode"
    (my/bind-keys
     c-mode-map
     '(("C-c m d f" gtk-doc-insert)
       ("C-c m d s" gtk-doc-insert-section)
       )))
#+end_src

*** css

**** Funcions d'utilitat

M'agrada que quan es guarda un arxiu =.scss= es recompili
automàticament el codi CSS. Per fer-ho servir cal definir unes
variables (veure codi).

Per definir variables per projecte es poden utilitzar variables locals
de directori.

#+begin_src emacs-lisp :tangle yes
  (defvar sass-project-root nil
    "Arrel del projecte.")
  (defvar sass-project-main-file nil
    "Arxius arrel del projecte, relatiu a `sass-project-root'.")
  (defvar sass-project-output-file nil
    "Arxiu de sortida, relatiu a `sass-project-root'.")
  (defvar sass-command "sass --style compressed %s %d"
    "Comanda per executar sass.

  Permet interpolar alguns elements:

  - %r: directori arrel del projecte
  - %s: ruta absoluta de l'arxiu origen (source)
  - %d: ruta absoluta de l'arxiu de sortida (dest)
  ")

  (require 'format-spec)

  (defun arv/sass-compile-on-save ()
    "Compila el projecte SASS al guardar.

  Quan un arxiu amb extensió '.scss' es guarda dins el directori
  `sass-project-root' o un subdirectori s'executa la comanda
  `sass-command' substituint:

  - %r: `sass-project-root'
  - %s: `sass-project-main-file'
  - %d: `sass-project-output-file'."
    (if (and (string-match-p "\.scss$" (buffer-file-name))
             (s-starts-with-p sass-project-root (buffer-file-name)))
        (compilation-start
         (format-spec
          sass-command
          (list
           (cons ?r sass-project-root)
           (cons ?s (arv/path-concat sass-project-root sass-project-main-file))
           (cons ?d (arv/path-concat sass-project-root sass-project-output-file))))
         t
         (lambda (mode) "*sass*"))))
#+end_src

**** Combinacions de tecles
**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'css-mode-hook
            (lambda ()
              (rainbow-mode t)
              (company-mode t)))
  (add-hook 'after-save-hook 'arv/sass-compile-on-save)
#+end_src

*** emacs-lisp, ielm
**** =elisp-slime-nav=

https://github.com/purcell/elisp-slime-nav

#+begin_src emacs-lisp :tangle yes
  (use-package elisp-slime-nav
    :ensure t
    :commands elisp-slime-nav-mode
    :diminish "")
#+end_src

**** =macrostep=

=macrostep= permet expandir macros /inline/.

#+begin_src emacs-lisp :tangle yes
  (use-package macrostep
    :ensure t
    :commands macrostep-mode)
#+end_src

**** =package-lint=

https://github.com/purcell/package-lint

This library provides a linter for the metadata in Emacs Lisp files
which are intended to be packages.

#+begin_src emacs-lisp :tangle yes
  (use-package package-lint
    :ensure t
    :commands (package-lint-current-buffer
               package-lint-buffer))
#+end_src

**** =paredit=

#+begin_src emacs-lisp :tangle yes
  (use-package paredit
    :ensure t
    :commands paredit-mode
    :diminish "")
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/scratch ()
    "Activa el buffer *scratch*, creant-lo si és necessari."
    (interactive)
    (let ((current-mode major-mode))
      (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (if (memq current-mode lisp-mode)
          (funcall current-mode))))

  (defun arv/emacs-lisp-insert-grave ()
    "Inserts `' within a string or just ` otherwise."
    (interactive)
    (if (nth 8 (syntax-ppss))
        (progn
          (insert "`'")
          (backward-char 1))
      (insert "`")))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "lisp-mode"
    (my/bind-keys emacs-lisp-mode-map
                  '(("s-SPC" company-complete)
                    ("<f9>" (lambda () (interactive) (ert t)))
                    ("M-<f1>" (lambda () (interactive) (info "elisp")))
                    ("`" arv/emacs-lisp-insert-grave)
                    ("s-c" arv/startup-byte-recompile)
                    ("C-c m b" eval-buffer)
                    ("C-c m c" cancel-debug-on-entry)
                    ("C-c m d" debug-on-entry)
                    ("C-c m e" toggle-debug-on-error)
                    ("C-c m f" find-function)
                    ("C-c m F" emacs-lisp-byte-compile-and-load)
                    ("C-c m l" find-library)
                    ("C-c m m" macrostep-mode)
                    ("C-c m p" paredit-mode)
                    ("C-c m r" eval-region)
                    ("C-c m s" arv/scratch)
                    ("C-c m v" find-variable)
                    ("C-c m ?" elisp-slime-nav-describe-elisp-thing-at-point)
                    ("C-h e V" apropos-value)
                    ("C-c m z" byte-recompile-directory)
                    ("C-c C-z" ielm)))

    (let ((keywords '(("\\<ert-deftest\\>" . font-lock-keyword-face)
                      ("\\<should\\>" . font-lock-keyword-face)
                      ("\\<should-not\\>" . font-lock-keyword-face))))
      (font-lock-add-keywords 'emacs-lisp-mode keywords)
      (font-lock-add-keywords 'lisp-interaction-mode keywords)))

  (with-eval-after-load "paredit"
    (my/bind-keys paredit-mode-map
                  '(("C-<right>" nil)
                    ("C-<left>" nil)
                    ("M-<right>" paredit-forward-slurp-sexp)
                    ("M-<left>" paredit-forward-barf-sexp))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (paredit-mode 1)
              (elisp-slime-nav-mode 1)
              (prettify-symbols-mode 1)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-hook 'ielm-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (elisp-slime-nav-mode 1)))
#+end_src
*** go                                                      :desactivat:brut:

Aquest mode actualment no l'utilitzo. S'inclou la configuració,
desactivada, per accelerar la migració.

#+begin_src emacs-lisp :tangle no
  (require 'company)
  (require 'company-go)
  (require 'go-eldoc)
  (require 'go-mode)
  (require 'projectile)

  (defun arv/gobuild ()
    "Jumps to project root and runs 'go build -v'."
    (interactive)
    (compile (format "cd %s && go build -v" (projectile-project-root)) 't))

  (defun arv/goinstall ()
    "runs 'go install' on current package."
    (interactive)
    (compile (format "cd %s && go install" (file-name-directory (buffer-file-name))) 't))

  (defun arv/gotest ()
    "runs 'go test' on current package."
    (interactive)
    (compile (format "cd %s && go test" (file-name-directory (buffer-file-name))) 't))

  (eval-after-load "go-mode"
    '(progn
       (setq gofmt-command "goimports")
       ;; flymake
       (require 'flymake-go)
       ;; documentation
       (setq godoc-at-point-function 'godoc-gogetdoc)
       (define-key go-mode-map (kbd "C-c m d") 'godoc-at-point)
       ;; jumping around
       (define-key go-mode-map (kbd "C-c j a") 'go-goto-arguments)
       (define-key go-mode-map (kbd "C-c j d") 'go-goto-docstring)
       (define-key go-mode-map (kbd "C-c j i") 'go-goto-imports)
       (define-key go-mode-map (kbd "C-c j m") 'go-goto-method-receiver)
       (define-key go-mode-map (kbd "C-c j n") 'go-goto-function-name)
       (define-key go-mode-map (kbd "C-c j r") 'go-goto-return-values)
       (define-key go-mode-map (kbd "M-.") 'godef-jump)
       ;; compilation
       (define-key go-mode-map (kbd "<f9>") 'arv/gobuild)
       (define-key go-mode-map (kbd "C-<f9>") 'arv/gotest)
       (define-key go-mode-map (kbd "M-<f9>") 'arv/goinstall)
       ))

  (add-hook 'go-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'gofmt-before-save)
              ;; autocompletion. Depends on external command gocode
              (set (make-local-variable 'company-backends) '(company-go))
              (company-mode)
              ;; eldoc
              (go-eldoc-setup)))
#+end_src

*** haskell

#+begin_src emacs-lisp :tangle yes
  (use-package haskell-mode
    :ensure t
    :config
    (define-key haskell-mode-map (kbd "C->") (lambda () (interactive) (insert " -> ")))
    (define-key haskell-mode-map (kbd "C-<") (lambda () (interactive) (insert " <- "))))
#+end_src

*No revisat*: a [[https://sachachua.com/blog/2019/08/2019-08-26-emacs-news/][Sacha Chua 2019-08-26 Emacs news]] he trobat un enllaç a
[[https://github.com/soupi/minimal-haskell-emacs][minimal haskell emacs]] (a minimal emacs configuration for haskell
programming).

*** html
**** =emmet= (anteriorment =zencoding=)

https://github.com/smihica/emmet-mode

=emmet= facilita generar html (xml) a partir d'una especificació en un
format compacte. També suporta CSS però resulta massa criptic i pel
meu cas d'us no aporta res.

#+begin_src emacs-lisp :tangle yes
  (use-package emmet-mode
    :ensure t
    :commands emmet-mode
    :config
    (setq emmet-indentation 2)
    (define-key emmet-mode-keymap (kbd "C-j") nil)
    :diminish "")
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'html-mode-hook
            (lambda ()
              (rainbow-mode t)
              (emmet-mode t)))
#+end_src

*** javascript
**** =tern=

http://ternjs.net/

Integra la comanda externa =tern= dins emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package tern
    :ensure t
    :commands tern-mode
    :diminish "")
#+end_src

**** =company-tern=

https://github.com/proofit404/company-tern

Implementa un /backend/ per =company-mode= basat en =tern=.

#+begin_src emacs-lisp :tangle no
  (use-package company-tern
    :ensure t
    :after tern
    :config
    (add-to-list 'company-backends 'company-tern))
#+end_src

**** =js2-refactor=

https://github.com/magnars/js2-refactor.el

Refactorització de codi js.

#+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :ensure t
    :after js2-mode
    :commands js2-refactor-mode
    :diminish "")
#+end_src

**** =js2-mode=

#+begin_src emacs-lisp :tangle yes
  (use-package js2-mode
    :ensure t
    :commands js2-mode)

  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

**** =xref-js2=                                                  :desactivat:

https://github.com/NicolasPetton/xref-js2

Aquest apareix a una recepta que vaig trobar que explica com
configurar un entorn javascript. Depen de la comanda =ag=. Mai l'he
utilitzat. =tern= sembla prometedor.

#+begin_src emacs-lisp :tangle no
  (use-package xref-js2
    :ensure t)
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'js2-mode
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    (js2r-add-keybindings-with-prefix "C-c m r")
    (add-hook 'js2-mode-hook (lambda ()
                               (js2-imenu-extras-mode)
                               (js2-refactor-mode)
                               (tern-mode)
                               (company-mode))))
#+end_src

*** org
**** Instal·lació

Al instal·lar /org/ des d'ELPA el codi compilat m'ha donat problemes
([[https://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks][enllaç]]) així que he optat per instal·lar-lo directament des del codi
font ([[https://orgmode.org/worg/dev/org-build-system.html][instruccions]]).

En =init.el= es modifica el valor de =load-path= per garantir que es
carrega la versió correcta de /org/ abans de processar aquesta
configuració.

Per instal·lar:

#+begin_src sh :tangle yes
  [ -d ~/.local/src ] || mkdir -p ~/.local/src
  pushd ~/.local/src
  if [ ! -d org-mode ] ; then
      echo "Descarregant i instal·lant 'org-mode'."
      git clone --quiet https://code.orgmode.org/bzg/org-mode.git
      cd org-mode
      make local.mk
      sed -i -r -e 's!^prefix\s+=.*$!prefix = $(HOME)/.local/share!' local.mk
      make
      make install
  fi
  popd
#+end_src

Per actualitzar la versió instal·lada:

#+begin_src sh :tangle no
  cd ~/.local/src/org-mode
  git pull
  make
  make install
#+end_src

**** Ajuda

Mostra la referència ràpida de =org-mode= (=orgcard.pdf=) si està
disponible (dins el subdirectori =etc=).

#+begin_src emacs-lisp :tangle yes
  (defun my/org-refcard ()
    "Mostra la referència ràpida de org-mode."
    (interactive)
    (let ((org-refcard (arv/path-concat arv/emacs-conf-dir "etc" "orgcard.pdf")))
      (when (file-readable-p org-refcard)
        (find-file org-refcard))))
#+end_src

**** Mòduls extra

/org/ no carrega tots els mòduls disponibles. Segons la documentació
es pot modificar el valor de la variable =org-modules= per afegir nous
mòduls, però no tinc clar si modificar-la ací tindrà efecte, una
vegada carregat /org/, o cal fer-ho en =init.el=, abans de
carregar-lo.

Aparentment =org-modules= té un /setter/ que fara algo al assignar-li
un valor amb =customize-set-value=, probablement carregar els mòduls.

Mentre ho esbrino els mòduls es carreguen manualment.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (when (string-greaterp org-version "9.2")
      (require 'org-tempo)))
#+end_src

**** Plantilles estructurals (temporals)

Plantilla que expandeix =<S= en un bloc de codi /emacs-lisp/ marcat
amb =:tangle yes=. Probablement es podrà esborrar quan s'hagi
completat la migració de la configuració.

En algun punt entre /org/ 8.2.10 i 9.1.7 s'ha canviat la forma en que
s'expandeixen les [[info:org#Structure%20templates][plantilles estructurals]].

#+begin_src emacs-lisp :tangle yes
  ;; No tinc clara la versió en que açò va canviar. En el meu context
  ;; (emacs 25.3.1 + org 8.2.10 i org 9.1.7) "9" és suficientment bo.

  (if (string-greaterp org-version "9")
      (add-to-list 'org-structure-template-alist
                   '("S" . "src emacs-lisp :tangle yes"))
    (add-to-list 'org-structure-template-alist
                 '("S"
                   "#+begin_src emacs-lisp :tangle yes\n?\n#+end_src"
                   "</src>\n?\n<src lang=\"emacs-lisp\" tangle=\"yes\">")))
#+end_src

Utilitzo els estats següents per gestionar les tasques.

#+begin_src plantuml :file estats_org.png
  [*] --> TODO
  TODO --> STRT
  TODO --> CANC
  STRT --> PAUS
  STRT --> WAIT
  STRT --> DONE
  STRT --> CANC
  PAUS --> STRT
  WAIT --> STRT
  DONE --> [*]
  CANC --> [*]
#+end_src

**** =babel=

Llista de llenguatges que es poden avaluar directament des d'un bloc
de codi.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     (let ((langs '((emacs-lisp . t)
                    (python . t)
                    (plantuml . t))))
       ;; https://lists.gnu.org/archive/html/emacs-orgmode/2015-11/msg00425.html
       (if (string-greaterp org-version "8.3")
           (cons '(shell . t) langs)
         (cons '(sh . t) langs)))))
#+end_src

Al exportar un document cada vegada demana confirmació per avaluar els
blocs de codi /plantuml/, resulta molest.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ob-core
    (setq org-confirm-babel-evaluate
          (lambda (lang body)
            (not (member lang '("plantuml"))))))
#+end_src

**** =emacs-htmlize=                                                 :manual:

L'exportació a HTML en org 9.1.8 requereix que estigui instal·lat
=emacs-htmlize=, el problema és que no apareix a ELPA (melpa?):

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/hniksic/emacs-htmlize.git
  ./scripts/compile_package emacs-htmlize
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :after org
    :load-path "site-lisp/emacs-htmlize")
#+end_src

**** =ob-plantuml=

=ob-plantuml= permet integrar diagrames /plantuml/ dins els documents
/org/. Per exemple:

#+begin_src org
  ,#+begin_src plantuml :file tryout.png
    Alice -> Bob: synchronous call
    Alice ->> Bob: asynchronous call
  ,#+end_src
#+end_src

Requereix un /jar/ (java archive) que es pot descarregar des de
http://plantuml.com/download. També requereix el JRE. Provat amb la
versió 8.0.131.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ob-plantuml"
    (customize-set-value
     'org-plantuml-jar-path
     (expand-file-name "~/.local/lib/plantuml/plantuml.jar")))
#+end_src

**** =org=

Defineix el comportament quan s'edita un bloc plegat.

#+begin_src emacs-lisp :tangle yes
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

Les opcions disponibles es troben a l'[[help:org-catch-invisible-edits][ajuda]].

Defineix el nombre de línies en blanc necessaries per mantindre una
línia en blanc entre seccions col·lapsades. Personalment prefeixo que
les capçaleres apareguin juntes.

#+begin_src emacs-lisp :tangle yes
  (setq org-cycle-separator-lines 0)
#+end_src

Em resulta molest el comportament elèctric de la parella =<>=. El
comentari que figura en [[https://code.orgmode.org/bzg/org-mode/commit/886ab9c766][el commit de org]] diu:

#+begin_quote
lisp/org.el (org-mode): Let < and > be recognized as opening and
ending characters.

These characters are typically used in timestamps where it is useful
to use C-M-f and C-M-b to manipulate them.
#+end_quote

No manipulo /timestamps/ i sí que utilitzo =<= per expandir plantilles
estructurals i com operadors en blocs de codi, on el comportament
elèctric és molest. Resetejo la sintaxi de =<= i =>= als valors per
defecte.

#+begin_src emacs-lisp :tangle yes
  (defun my/org-reset-<-syntax ()
    (modify-syntax-entry ?< "@" org-mode-syntax-table)
    (modify-syntax-entry ?> "@" org-mode-syntax-table))
#+end_src

La comanda =org-export-dispatch= (=C-c C-e=) reseteja la taula de
sintaxis (o algo semblant) i =<= recupera el comportament original.
Afegeixo un /advice/ al final de la comanda per revertir el canvi.

#+begin_src emacs-lisp :tangle yes
  (defun my/advice-org-export-dispatch (&optional arg)
    (my/org-reset-<-syntax))

  (advice-add 'org-export-dispatch :after #'my/advice-org-export-dispatch)
#+end_src

Prefereixo que els documents org s'obrin amb totes les capçaleres
plegades, em dona una visió general del document.

#+begin_src emacs-lisp :tangle yes
  (setq org-startup-folded t)
#+end_src

Açò es pot canviar document a document especificant una de les
opcions:

#+begin_src org
  ,#+STARTUP: overview
  ,#+STARTUP: content
  ,#+STARTUP: showall
  ,#+STARTUP: showeverything
#+end_src

Aquesta opció es pot afegir amb la comanda =C-u C-u TAB=
(=org-set-startup-visibility=).

**** =org-id=

Al emmagatzemar l'enllaç a una secció amb =C-c l= s'utilitza el títol
de la secció. Si es modifica el títol de la secció els enllaços es
trenquen.

Amb aquesta configuració =C-c l= assigna un ID únic globalment a la
secció.

#+begin_src emacs-lisp :tangle yes
  (use-package org-id
    :config
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id
          org-id-track-globally t))
#+end_src

**** =ox-twbs=

https://github.com/marsmining/ox-twbs

Exporta a HTML + bootstrap. No mata però és més agradable visualment
que el format per defecte.

Cal importar el paquet perquè es registri i que aparegui en la
pantalla d'exportació (=C-c C-e=). Malauradament no hi ha cap /event/
que permeti retardar l'operació així que espera uns segons
d'inactivitat per carregar-lo.

#+begin_src emacs-lisp :tangle yes
  (use-package ox-twbs
    :ensure t
    :defer 4)
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-emphasize (char)
    (if mark-active
        (org-emphasize char)
      (insert char)))
#+end_src

Afegeix automàticament la data en que es creen les entrades =TODO=:

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-add-creation-date (&rest ignore)
    "Log TODO creation time in the property drawer under the key 'CREATED'."
    (when (and (org-get-todo-state)
               (not (org-entry-get nil "CREATED")))
      (org-entry-put nil "CREATED" (format-time-string (cdr org-time-stamp-formats)))))

  (advice-add 'org-insert-todo-heading :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-heading-respect-content :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-subheading :after #'arv/org-add-creation-date)
#+end_src

**** Faces

Perquè el valor de =org-todo-keyword-faces= tingui efecte sembla que
cal /declarar/ els estats amb algo tipus:

#+begin_src org
  ,#+TODO: TODO STRT PAUS(@) WAIT(@) DONE(@)
  ,#+TODO: | CANC(c@)
#+end_src

Pel que entenc és necessari perquè org sàpiga que són estats finals i
que no. En funció d'això s'aplica un estil.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
        (setq org-todo-keyword-faces
              '(("TODO" . arv/hi-red)
                ("STRT" . hi-blue)
                ("PAUS" . arv/hi-orange)
                ("WAIT" . arv/hi-pink)
                ("DONE" . arv/hi-green)
                ("CANC" . hi-green-b))))
#+end_src

**** Configuració de tecles                                      :desactivat:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
    (my/bind-keys org-mode-map
                  '(("M-<f1>" my/org-refcard))))
#+end_src

Cal revisar el paquet =arv/org=. Fins aleshores es desactiva.

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "/") (lambda () (interactive) (arv/org-emphasize ?/)))
    (define-key org-mode-map (kbd "*") (lambda () (interactive) (arv/org-emphasize ?*)))
    (define-key org-mode-map (kbd "_") (lambda () (interactive) (arv/org-emphasize ?_)))
    (define-key org-mode-map (kbd "=") (lambda () (interactive) (arv/org-emphasize ?=)))
    (define-key org-mode-map (kbd "~") (lambda () (interactive) (arv/org-emphasize ?~)))
    (define-key org-mode-map (kbd "+") (lambda () (interactive) (arv/org-emphasize ?+)))
    (define-key org-mode-map (kbd "C-c M-q") 'arv/org-remove-reduntant-tags)
    (define-key org-mode-map (kbd "C-c q")   'arv/org-add-inherited-tags)
    (define-key org-mode-map (kbd "C-c $") 'arv/org-archive-subtree)
    (define-key org-mode-map (kbd "C-c C-w") 'arv/org-refile))
#+end_src

**** Plantilles de captura

Veure [[info:org#Capture%20templates][Capture templates]] per detalls.


Aquesta serveix per capturar notes relacionades amb la configuració
d'emacs:

#+begin_src emacs-lisp :tangle yes
  (setq org-capture-templates
        `(("t"
           "TODO emacs"
           entry
           (file+headline "~/.emacs.d/conf.d/notes.org" "Bugs, molèsties, millores etc.")
           ,(concat "** TODO %^{Heading} %^g\n"
                    "   :PROPERTIES:\n"
                    "   :CREATED: %U\n"
                    "   :REFERER: %a\n"
                    "   :END:\n\n"
                    "%?")
           :empty-lines 1)))
#+end_src

Aquesta la utilitzo per capturar notes quan treballo en Hera. Potser
es podria generalitzar a notes per projecte.

#+begin_src emacs-lisp :tangle yes
  (when (getenv "HERA_ROOT")
    (push `("p"
            "TODO Hera"
            entry
            (file+headline ,(arv/path-concat (getenv "HERA_ROOT") "doc_dev" "TODO.org") "TODOs")
            ,(concat "** TODO %^{Heading} %^g\n"
                     "   :PROPERTIES:\n"
                     "   :CREATED: %U\n"
                     "   :REFERER: %a\n"
                     "   :END:\n\n"
                     "%?")
            :prepend t
            :empty-lines 1)
          org-capture-templates))
#+end_src

**** LaTeX

Classe basada en =report=. Defineix canvis en la presentació (font,
color dels enllaços i marges) i en l'estructura (el primer element és
=chapter= no =part=).

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ox-latex"
    (add-to-list 'org-latex-classes
                 '("informe"
                   "\\documentclass[paper=a4, fontsize=10pt]{report}
  \\usepackage{fourier}
  \\usepackage[]{babel}
  \\usepackage[margin=3.5cm]{geometry}
  \\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
  \\linespread{1.5}
  \\setlength{\\parskip}{0.3cm}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (add-to-list 'org-latex-classes
                 '("beamer"
                   "\\documentclass[presentation]{beamer}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"
                    "\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"))))
#+end_src

**** Configuracions desactivades

Açò és part de la configuració original que mai vaig acabar d'integrar
en el meu workflow. Es manté per si de cas.

#+begin_src emacs-lisp :tangle no
  ;; define 'ecfg:' links
  (eval-after-load "org"
    '(progn
       (org-add-link-type "ecfg" 'arv/org-ecfg-open)
       (add-hook 'org-store-link-functions 'arv/org-ecfg-store-link)
       (define-key org-mode-map (kbd "C-c M-l") 'arv/org-ecfg-insert-link-at-point)
       ))


  ;; capture
  (setq org-capture-templates
        '(("i" "Interrupcio" entry (file+headline "gtd.org" "Interrupcions")
           (file "templates/interrupt.tmpl")
           :empty-lines 1 :clock-in t :clock-resume nil)
          ("t" "Todo" entry (file+headline "gtd.org" "Tasks")
           (file "templates/todo.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t)
          ("f" "Todo followup" entry (clock)
           (file "templates/todo_followup.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)
          ("s" "Sibling" entry (function (lambda () (org-up-heading-safe) (org-end-of-subtree t)))
           (file "templates/sibling.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)))


  ;; agenda
  (setq org-agenda-files "~/.emacs.d/org/agenda_files")

  (setq org-agenda-custom-commands
        '(("x" tags "TIPUS=\"error\"")
          ("v" todo "DONE|CANCELLED")))


  ;;; workflow
  ;;
  ;; TODO(t) STRT(s!) PAUS(p@) HOLD(i!) WAIT(w@) | DONE(d!) CANC(c@)
  ;;
  ;; - TODO: no action taken, just created the note.
  ;; - STRT: currently working on, there can be only one.
  ;; - PAUS: paused, still not finished.
  ;; - HOLD: interrupted, there can be only one.
  ;; - WAIT: paused, waiting for external feedback.
  ;; - DONE: finished, no further action is required.
  ;; - CANC: canceled, no further action is required.

  (eval-after-load "org"
    '(progn
       (setq org-todo-keywords
             '((sequence "TODO(t)" "STRT(s!)" "PAUS(p@)" "HOLD(i!)"
                         "WAIT(w@)" "|" "DONE(d!)" "CANC(c@)")))
       (setq org-directory "~/.emacs.d/org")
       (setq org-startup-folded t)
       (require 'arv-org)
       (setq arv/org-interrupt-resumed-state "STRT")
       (setq arv/org-interrupt-interrupted-state "HOLD")
       (setq arv/org-interrupt-capture-key "i")
       (setq arv/org-sctc-entering-state-clocking-actions
             '(("STRT" . nil)
               ("PAUS" . nil)
               ("WAIT" . nil)))
       (setq arv/org-sctc-paused-state "PAUS")
       (arv/org-sctc-setup)))
#+end_src

**** Hook

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
    (add-hook
     'org-mode-hook
     (lambda ()
       (my/org-reset-<-syntax)
       ;; electric-pair: insereix parelles ==, // i ~~
       (let ((org-electric-pairs '((?= . ?=) (?/ . ?/) (?~ . ?~))))
         (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))))))
#+end_src

*** perl                                                         :desactivat:

Fa anys que no programo en perl i espero no haver de tornar a fer-ho.
S'inclou la configuració per nostàlgia.

#+begin_src emacs-lisp :tangle no
  (add-hook 'perl-mode-hook
            (lambda()
          (set-variable 'show-trailing-whitespace t)
          (setq perl-indent-level 4)
          (turn-on-font-lock)))
#+end_src

*** po

=po-mode= es distribueix com part del codi font de =gettext= que es
pot descarregar des de:

ftp://ftp.gnu.org/pub/gnu/gettext/gettext-latest.tar.xz

El fitxers =po-mode.el= i =po-compat.el= s'han copiat dins el
directori =site-lisp=. La inicialització següent és una adaptació de
=start-po.el=.

#+begin_src emacs-lisp :tangle yes
  (use-package po-mode
    :load-path "conf.d/site-lisp"
    :commands po-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.po\\'\\|\\.po\\." . po-mode)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package po-compat
    :load-path "conf.d/site-lisp"

    ;; :command comprova si el símbol està definit (fboundp), en cas
    ;; negatiu genera un autoload i en cas afirmatiu no fa res. Açò es
    ;; equivalent al que fa start-po.el.
    :commands po-find-file-coding-system

    :init
    (modify-coding-system-alist 'file "\\.po[t]?\\'\\|\\.po\\."
                                'po-find-file-coding-system))
#+end_src

*** prog-mode

Mode base pels modes de programació.

Aquesta configuració permet utilitzar etiquetes, normalment dins
comentaris, que es destacaran utilitzant colors. El significat és el
següent:

- /FIXME/: roig, cal una acció *immediata*. Falta implementar algo,
  algo està mal etc. El codi no funcionarà com s'espera fins que es
  faci l'acció.

- /HACK/, /OPTIMIZE/, /REVIEW/, /TODO/: taronja, cal un acció. El codi
  funcionarà però podria funcionar millor, ser més net etc.

- /IMPORTANT/, /NOTE/, /WARNING/: verd, no cal acció. S'utilitza per
  destacar certs tipus de comentaris.

**** Combinacions de tecles

Cap tecla definida.

**** /Hook/

#+name: target-prog-mode-hook
#+begin_src emacs-lisp :tangle yes
  ;; (eval-after-load "linum"
  ;;   '(progn
  ;;      (require 'relative-linum)))

  (add-hook 'prog-mode-hook
            (lambda ()
              (linum-mode 0)
              (show-paren-mode 1)
              (set-variable 'show-trailing-whitespace t)

              ;; (flyspell-prog-mode)
              ;; flyspell defineix C-, i C-. que ja tinc assignades i
              ;; interioritzades.
              ;; (define-key flyspell-mode-map (kbd "C-,") nil)
              ;; (define-key flyspell-mode-map (kbd "C-.") nil)

              ;; hi-lock

              ;; HACK: 20180818, no tinc clara la causa però, si no
              ;; s'activa font-lock, hi-lock no ressalta els nous
              ;; elements, només els existens en obrir l'arxiu. Açò
              ;; sembla consistent amb el que diu la documentació:
              ;;
              ;;   In buffers where Font Lock mode is enabled, patterns
              ;;   are highlighted using font lock. In buffers where
              ;;   Font Lock mode is disabled, patterns are applied
              ;;   using overlays; in this case, the highlighting will
              ;;   not be updated as you type.
              ;;
              ;; font-lock s'activa globalment. La teoria és que el hook
              ;; s'executa abans que s'hagi activat font-lock.

              (font-lock-mode 1)

              (hi-lock-mode 1)
              (hi-lock-face-buffer "\\bFIXME:" 'arv/hi-red)
              (hi-lock-face-buffer "\\bHACK:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bIMPORTANT:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bNOTE:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bOPTIMIZE:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bREVIEW:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bTODO:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bWARNING:" 'arv/hi-green)))
#+end_src

*** python
**** =arv-py=                                                        :manual:

https://github.com/patxoca/arv-py

Funcions d'utilitat per treballar amb codi python.

#+begin_src emacs-lisp :tangle yes
  (use-package arv-py
    :ensure t
    :commands (pyx/add-setup-dependency
               pyx/electric-colon
               pyx/get-current-package-name
               pyx/insert-current-package-name
               pyx/make
               pyx/nav-goto-first-import
               pyx/nav-up-list
               pyx/refactor-wrap-for
               pyx/refactor-wrap-if-else
               pyx/refactor-wrap-try-except
               pyx/refactor-wrap-while
               pyx/refactor-wrap-with
               pyx/smart-grave
               pyx/visit-setup-py
               pyx/visit-test-module))
#+end_src

**** =elpy=

https://github.com/jorgenschaefer/elpy

Documentació https://elpy.readthedocs.io/en/latest/index.html

Pel seu funcionament requereix algunes comandes externes:

#+begin_src sh :tangle no
  pip install jedi flake8 autopep8 yapf
#+end_src

=M-x elpy-config= per veure si estan instal·lades.

#+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :config
    (defun arv/elpy-nav-forward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-forward-block))

    (defun arv/elpy-nav-backward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-backward-block))

    (my/bind-keys elpy-mode-map
                  '(("C-<down>" arv/elpy-nav-forward_block)
                    ("C-<up>" arv/elpy-nav-backward_block)
                    ("C-<left>" nil)
                    ("C-<right>" nil)
                    ("C-c m d" elpy-doc)))

    ;; Arxius de menys de 8K es transfereixen al backend via RPC, els
    ;; majors via un arxiu temporal. En la documentació diu que enviar
    ;; arxius "grans" per RPC pot ser lent però no defineix que és
    ;; "gran". Espero que 8K no qualifiqui com gran.
    (customize-set-value 'elpy-rpc-large-buffer-size 8192)

    (customize-set-value 'elpy-syntax-check-command "flake8")

    (customize-set-value 'elpy-modules
                         '(elpy-module-company
                           ;; elpy-module-django
                           elpy-module-eldoc
                           elpy-module-flymake
                           ;; elpy-module-highlight-indentation
                           elpy-module-pyvenv
                           elpy-module-sane-defaults
                           elpy-module-yasnippet))

    (when (boundp 'elpy-rpc-virtualenv-path)
      ;; Aquesta opció s'ha introduït en una refactorització de elpy amb
      ;; posterioritat a la versió 1.31.0. Enlloc de comparar versions
      ;; trobo més robust comprovar si l'opció existeix.
      (customize-set-value 'elpy-rpc-virtualenv-path 'current))
    (define-key elpy-mode-map (kbd "C-c C-g") nil)
    (define-key elpy-mode-map (kbd "C-c M-g") 'elpy-pdb-map))
#+end_src

La comanda =flake8= es pot configurar des de l'arxiu
=~/.config/flake8=.

***** snippets

El snippet =super= definit per =elpy= adapta la sintaxi del codi
generat a la versió de l'interpret python /actiu/. Açò resulta
inconvenient quan es desenvolupa amb python 3 però el codi ha de
funcionar amb python 2 i 3.

Per resoldre-ho he redefinit localment el snippet i he introduït la
variable =my/elpy-python-6= per controlar el comportament del snippet:

- si el valor és /cert/ genera codi que funciona en python 2 i 3.

- si és /fals/ genera codi específic

El valor per defecte és =nil= i es pot canviar per projecte en
=.dir-locals.el=.

#+begin_warning
Perquè açò funcioni cal que el directori dels snippets aparegui en
=yas-snippet-dirs= abans del directori de snippets de =elpy=.
#+end_warning

**** =pep8=                                                          :manual:

https://gist.github.com/ieure/302847

Pel seu funcionament requereix una comanda externa:

#+begin_src sh :tangle no
  pip install pycodestyle
#+end_src

La configuració detecta si =pycodestyle= està disponible. En cas
negatiu utiliza la comanda =pep8=.

#+begin_src emacs-lisp :tangle yes
  (use-package python-pep8
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands (python-pep8 pep8)
    :config
    (when (executable-find "pycodestyle")
      (customize-set-value 'python-pep8-command "pycodestyle"))
    (customize-set-value 'python-pep8-options '("--repeat" "--max-line-length=150")))
#+end_src

**** =pylookup=                                                  :desactivat:

https://github.com/tsgates/pylookup

Accés a la documentació. Sembla que cal baixar la documentació en
format HTML i executar un programa per indexar-la i crear una mena de
base de dades. Suposo que funcionaria per qualsevol documentació, no
sols la de python.

Mai he aconseguit integrar-ho en el meu workflow, segons el que
necessito en cada cas tiro de /eldoc/, busco la definició i miro el
codi font, accedeixo a la documentació online o tiro de google.

#+begin_src emacs-lisp :tangle no
  (autoload 'pylookup-lookup "pylookup")
  (autoload 'pylookup-update "pylookup")

  (eval-after-load "python"
    '(progn
       (define-key python-mode-map (kbd "C-c h") 'pylookup-lookup)))

  (add-hook 'python-mode-hook
            (lambda()
              (let ((pylookup-dir (arv/startup-get-absolute-path "site-lisp/pylookup")))
                (setq pylookup-program (arv/path-join pylookup-dir "pylookup.py"))
                (setq pylookup-db-file (arv/path-join pylookup-dir "pylookup.db"))
                )))
#+end_src

**** =pydoc info=                                                :desactivat:

https://bitbucket.org/jonwaltman/pydoc-info/

Accés a la documentació en format /info/ (p.e. la generada per
/sphinx/ per python, django etc). Tampoc vaig aconseguir integrar-ho
en el workflow.

[[http://www.draketo.de/light/english/free-software/read-your-python-module-documentation-emacs][Guia de configuració.]]

#+begin_src emacs-lisp :tangle no
  (autoload 'info-lookup-add-help "info-look" "" nil nil)

  (eval-after-load "python"
    '(progn
       (info-lookup-add-help
        :mode 'python-mode
        :parse-rule 'pydoc-info-python-symbol-at-point
        :doc-spec
        '(("(python)Index" pydoc-info-lookup-transform-entry)
          ("(django14)Index" pydoc-info-lookup-transform-entry)))))
#+end_src

**** =pylint=                                                        :manual:

https://github.com/PyCQA/pylint/tree/master/elisp

El paquet =pylint.el= no està disponible en /ELPA/. Forma part de la
distribució de =pylint= i s'ha copiat dins el directori
=site-packages=. Requereix la comanda externa =pylint=, proveïda pel
paquet python =pylint=:

#+begin_src sh :tangle no
  pip install pylint
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pylint
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pylint)
#+end_src

**** =pytest=                                                        :manual:

Integra el paquet python =pytest= dins emacs. La implementació
original és de [[https://github.com/ionrock/pytest-el][ionrock]] però utilitzo un [[https://github.com/patxoca/pytest-el][fork]] propi.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/pytest-el.git
  ./scripts/compile_package pytest-el
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pytest
    :load-path "site-lisp/pytest-el"
    ;; únicament es defineixen autoloads per les funcions utilitzades en
    ;; la configuració.
    :commands (pytest-all
               pytest-one
               pytest-rerun-last
               pytest-mode-enable-if-test-module
               pytest-run-tests-for-current-module)

    :init
    ;; cal definir-la abans d'activar el mode
    (setq pytest-mode-keymap-prefix "C-c m t")
    (with-eval-after-load "python"
      (my/bind-keys python-mode-map '(("C-c m t a" pytest-all)))
      (my/bind-keys python-mode-map '(("C-c m t t" pytest-run-tests-for-current-module))))

    :config
    (my/bind-keys pytest-mode-map
                  '(("<f12>" pytest-one)))

    ;; WARNING: definir `pytest-cmd-flags' com segura per qualsevol
    ;; cadena és potencialment perillós, deixa la porta oberta a valors
    ;; maliciosos com ara " ; rm -Rf $HOME/ #"
    (put 'pytest-cmd-flags 'safe-local-variable 'stringp))
#+end_src

**** =python=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (setq python-shell-virtualenv-path (getenv "VIRTUAL_ENV"))
    (setq python-indent-guess-indent-offset nil)

    ;; defineix l'interpret
    (customize-set-value 'python-shell-interpreter "ipython")
    (customize-set-value 'python-shell-interpreter-args "-i --simple-prompt")


    ;; activates source tracking when debugging with pdb from a shell
    ;; buffer
    (add-hook 'comint-output-filter-functions 'python-pdbtrack-comint-output-filter-function)

    (elpy-enable))
#+end_src

**** =sphinx-doc=

https://github.com/naiquevin/sphinx-doc.el

=sphinx-doc= is an emacs minor mode for inserting docstring skeleton
for Python functions and methods. The structure of the docstring is as
per the requirement of the Sphinx documentation generator.

#+begin_src emacs-lisp :tangle yes
  (use-package sphinx-doc
    :ensure t
    :commands sphinx-doc-mode)
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (my/bind-keys
     python-mode-map
     '(("C-c m 8" python-pep8)
       ("C-c m m" pyx/make)
       ("C-c m p" pylint)
       ("C-c m w f" pyx/refactor-wrap-for)
       ("C-c m w i" pyx/refactor-wrap-if-else)
       ("C-c m w t" pyx/refactor-wrap-try-except)
       ("C-c m w w" pyx/refactor-wrap-while)
       ("C-c m i s d " pyx/add-setup-dependency)
       ("C-c m i p n" pyx/insert-current-package-name)

       ;; pytest
       ("<f12>" pytest-all)
       ("C-<f12>" pytest-rerun-last)

       ("<f9>" pyx/make)
       ("s-<tab>" python-indent-shift-right)
       ("s-<iso-lefttab>" python-indent-shift-left)
       (":" pyx/electric-colon)
       ("`" pyx/smart-grave)
       ("C-m" newline-and-indent)
       ("C-c j i" pyx/nav-goto-first-import)
       ("C-c j S" pyx/visit-setup-py)
       ("C-c j T" pyx/visit-test-module)
       ("C-=" arv/rst-underline-header)
       ("C-," arv/wm-cycle-2)
       ("C->" indent-rigidly-right-to-tab-stop)
       ("C-<" indent-rigidly-left-to-tab-stop)
       ))
    (my/bind-keys
     elpy-mode-map
     '(("M-<up>" pyx/nav-up-list)
       ("M-<down>" pyx/nav-down-list)
       ("M-S-<down>" elpy-nav-move-line-or-region-down)
       ("M-S-<up>" elpy-nav-move-line-or-region-up)
       ))
    (define-key python-mode-map (kbd "C-<tab>")
      (make-hippie-expand-function
       '(try-expand-dabbrev
         ;; try-expand-tags
         try-expand-dabbrev-all-buffers)
       t)))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'python
    (add-hook 'python-mode-hook
              (lambda ()
                ;; outline
                (outline-minor-mode t)
                (set
                 (make-local-variable 'outline-regexp)
                 "[\t ]*\\(class\\|def\\|if\\|elsif\\|else\\|while\\|for\\|try\\|except\\|finally\\)\\>")

                ;; ressalta les línies on hi ha un breakpoint
                (highlight-lines-matching-regexp "^[[:space:]]*import i?pdb")
                (highlight-lines-matching-regexp "^[[:space:]]*i?pdb.set_trace()")

                ;; company-mode
                (company-mode t)

                ;; afecta a indent-rigidly-(left|righ)-to-tab-stop
                (setq python-indent-offset 4)
                (setq tab-width python-indent-offset)

                ;; ressalta els nivell d'indentacio
                ;; (arv/highlight-indentation-mode 0)

                ;; pylint/flymake-pylint
                ;; (pylint-add-menu-items)
                ;; (flymake-mode 1)

                ;; sphinx-doc
                (sphinx-doc-mode t)

                (superword-mode 1)
                (pytest-mode-enable-if-test-module)
                )))
#+end_src

*** python-django

Configuracions per facilitar el treball en projectes django:

- introspecció: obtindre les apps, els models etc. (=djira-el=).

- operacions amb les /apps/: visitar un model, una vista, consultar la
  documentació etc. (=django-el=).

- edició de plantilles (=pony-tpl=).

**** =django-el=                                                     :manual:

https://github.com/patxoca/django-el.git

Biblioteca que implementa funcions que faciliten la navegació dins un
projecte django.

#+begin_src emacs-lisp :tangle yes
  (use-package django-el
    :ensure t
    :init (setq django-el-prefix-key "C-c d")
    :commands (django-el-mode
               django-el-jump-to-javascript-controller
               django-el-jump-to-template
               django-el-autopair-template-tag))
#+end_src

**** =djira-el=                                                   :manual:

https://github.com/patxoca/djira-el

Biblioteca que permet accedir a la api definida per =djira= ([[https://github.com/patxoca/djira][github]]).
Aquest paquet substitueix a =python-django=, que ja no és mantingut.

Pel seu funcionament requereix que django estigui executant-se i que
tingui instal·lada l'aplicació =djira=.

#+begin_src emacs-lisp :tangle yes
  (use-package djira-el
    :ensure t
    :commands (djira-buffer-belongs-in-app-p))
#+end_src

**** =pony-tpl=                                                      :manual:

https://github.com/davidmiller/pony-mode

=pony-tpl= defineix un mode menor per editar plantilles django. Forma
part de =pony-mode= (abandonat?).

S'ha incorporat una versió local dins el directori =site-lisp= de la
configuració en la que s'han eliminat les dependències de =pony-mode=.

#+begin_src emacs-lisp :tangle yes
  (use-package pony-tpl
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pony-tpl-mode)
#+end_src

**** Configuració

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (my/bind-keys python-mode-map
                  '(("C-c j t" django-el-jump-to-template)
                    ("C-c j j" django-el-jump-to-javascript-controller))))

  (with-eval-after-load "sgml-mode"
    (my/bind-keys html-mode-map
                  '(("C-c j t" django-el-jump-to-template)
                    ("%" django-el-autopair-template-tag)))
    (add-hook 'html-mode-hook
              (lambda ()
                (when (djira-buffer-belongs-in-app-p (current-buffer))
                  (pony-tpl-mode)))))
#+end_src

*** rst
**** Funcions auxiliars
***** Documents =rst=

Funcions per treballar amb documents =rst=.

#+begin_src emacs-lisp :tangle yes
  (defun arv/rst-underline-header (caracter)
    (interactive "cCaracter: ")
    (let ((l (length (buffer-substring-no-properties (progn
                                                       (back-to-indentation)
                                                       (point))
                                                     (progn
                                                       (end-of-line)
                                                       (point)))))
          (indentation-level (progn
                               (back-to-indentation)
                               (current-column))))
      (when l
        (end-of-line)
        (insert "\n")
        (insert (make-string indentation-level ?\s))
        (insert (make-string l caracter))
        (insert "\n\n")
        (insert (make-string indentation-level ?\s)))))

  (defun arv/-rst-after-role-p ()
    "Return t if point is after a role."
    (looking-back ":\\w+:" (line-beginning-position)))

  (defun arv/rst-smart-grave ()
    "Tries to be smart about common ` usage patterns.

  If point is after a role (like :xref:) inserts ``, elsewhere
  inserts ```` (inline code literal). Point is left in the middle.

  If the region is active surround it and point is left at the
  end."
    (interactive)
    (let ((begin (point))
          (end   (point))
          (active (region-active-p))
          (delimiter))
      (when active
        (setq begin (min (region-beginning) (region-end)))
        (setq end   (max (region-beginning) (region-end))))
      (goto-char begin)
      (setq delimiter (if (arv/-rst-after-role-p)
                          "`"
                        "``"))
      (insert delimiter)
      (goto-char (+ end (length delimiter)))
      (insert delimiter)
      (unless active
        (backward-char (length delimiter)))))

  (defun arv/rst-smart-asterisk ()
    "Tries to be smart about * usage.

  If there's only withespace before point it assumes that it's a
  list bullet and inserts '* ', otherwise it inserts '**' and
  leaves point in the middle."
    (interactive)
    (if (string-match-p "^\s*$"
                        (buffer-substring-no-properties (line-beginning-position) (point)))
        (insert "* ")
      (insert "**")
      (backward-char 1)))
#+end_src

***** /sphinx/

Comandes per facilitar el treball amb documentació processada amb
[[http://www.sphinx-doc.org/en/master/][sphinx]].

Les funcions per compilar el projecte operen amb el Makefile generat
per sphinx. El Makefile es busca en el directori actual (on està
l'arxiu del buffer actual) i en els directoris pare.

#+begin_src emacs-lisp :tangle yes
  (defun arv/-sphinx-locate-makefile ()
    "Busca l'arxiu Makefile començant en el directori on està el
  buffer actual i visitant els directoris pare.

  Si troba el Makefile retorna la ruta absoluta del directori que
  el conte. Retorna nil si no el troba."
    (let ((cwd (file-name-directory (expand-file-name (buffer-file-name)))))
      (while (and (not (string= cwd "/"))
                  (not (file-exists-p (concat cwd "Makefile"))))
        (setq cwd (file-name-directory (directory-file-name cwd))))
      (if (string= cwd "/")
          nil
        cwd)))

  (defun arv/-sphinx-build (target)
    "Intenta executar 'make <target>'"
    (let ((makefile (arv/-sphinx-locate-makefile)))
      (unless (null makefile)
        (compilation-start (format "make -k -C %s %s" makefile target)
                           t
                           (lambda (mode) "*sphinx*")))))

  (defun arv/sphinx-build-latexpdf ()
    "Genera PDF"
    (interactive)
    (arv/-sphinx-build "latexpdf"))

  (defun arv/sphinx-build-html ()
    "Genera HTML"
    (interactive)
    (arv/-sphinx-build "html"))

  (defun arv/sphinx-run-doctest ()
    "Executa els doctest"
    (interactive)
    (arv/-sphinx-build "doctest"))
#+end_src

**** Definicions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "rst"
    (my/bind-keys
     rst-mode-map
     '(("*" arv/rst-smart-asterisk)
       ("`" arv/rst-smart-grave)
       ("<f9>" arv/sphinx-build-latexpdf)
       ("C-<f9>" arv/sphinx-run-doctest)
       ("M-<f9>" arv/sphinx-build-html)
       ("C-=" arv/rst-underline-header))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'rst-mode-hook
            (lambda ()
              (auto-fill-mode 1)
              (flyspell-mode 0)
              ;; activa el resaltat d'espai en blanc al final de línia
              (set-variable 'show-trailing-whitespace t)))
#+end_src

*** typescript

Configuració de =typescript=.

#+begin_src emacs-lisp :tangle yes
  (use-package typescript-mode
    :ensure t)
#+end_src

**** Funcions auxiliars

***** compilar

La comanda =compile= no mostra correctament els codis ANSI generants
durant la compilació. Aquesta comanda supleix la mancança.

#+begin_src emacs-lisp :tangle yes
  (defun my/typescript-compile ()
    "Intenta executar 'tsc'"
    (interactive)
    (let ((project-root (locate-dominating-file default-directory "tsconfig.json")))
      (if project-root
          (compilation-start (format "cd %s ; tsc" project-root)
                             t
                             (lambda (mode) "*tsc*"))
        (user-error "No es troba 'tsconfig.json'"))))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "typescript-mode"
    (my/bind-keys
     typescript-mode-map
     '(("<f9>" my/typescript-compile))))
#+end_src

**** Hook

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "typescript-mode"
    (add-hook
     'typescript-mode-hook
     (lambda ()
       ;; electric-pair: insereix <>
       (let ((ts-electric-pairs '((?< . ?>))))
         (setq-local electric-pair-pairs (append electric-pair-pairs ts-electric-pairs))
         ))))
#+end_src

*** vue                                                          :desactivat:

Actualment no l'utilitzo.

#+begin_src emacs-lisp :tangle no
(require 'mmm-mode)
(require 'vue-mode)
(mmm-add-mode-ext-class nil "\\.vue\\'" 'vue-mode)
#+end_src

*** zope

Associa modes als arxius relacionats amb zope:

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.pt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.cpt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.zpt$" . html-mode))

  (add-to-list 'auto-mode-alist '("\\.vpy$" . python-mode))
  (add-to-list 'auto-mode-alist '("\\.cpy$" . python-mode))

  (add-to-list 'auto-mode-alist '("\\.css.dtml$" . css-mode))
#+end_src

** Variat

Ressalta el parèntesi corresponent a l'actual.

#+begin_src emacs-lisp :tangle yes
  (show-paren-mode 1)
#+end_src

Esborra els espais en blanc al final de les línies en el moment de
guardar l'arxiu.

#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Si estem en un GUI canvia el títol de la finestra per mostrar el nom
del buffer actiu i la ruta de l'arxiu.

#+begin_src emacs-lisp :tangle yes
(when window-system
  (setq frame-title-format '("emacs %b (%f)")))
#+end_src

De vegades es guarda repetidament la mateixa marca. Aquest /advice/
elimina les repeticions, accelerant la navegació.

http://endlessparentheses.com/faster-pop-to-mark-command.html

#+begin_src emacs-lisp :tangle yes
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+end_src

Per recuperar les marques de la pila cal utilitzr =C-u C-SPC= per cada
marca, poc àgil. Aquest canvi permet utilitzar =C-u C-SPC C-SPC ...=

#+begin_src emacs-lisp :tangle yes
  (setq set-mark-command-repeat-pop t)
#+end_src

En el meu mon les frases es separen amb un espai, no dos.

#+begin_src emacs-lisp :tangle yes
  (customize-set-value 'sentence-end-double-space nil)
#+end_src

Prefereixo utilitzar espais pel sagnat, conserven el format.

#+begin_src emacs-lisp :tangle yes
  (customize-set-variable 'indent-tabs-mode nil)
  (customize-set-variable 'tab-width 4)
#+end_src

Algunes comandes, que es consideren /perilloses/ pels /novatos/, estan
desactivades. A aquestes alçades crec que puc activar-les totes:

#+begin_src emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+end_src

Ignora majúscules/minúscules al ordenar línies. Normalment ordeno per
facilitar-me la vida buscant elements. Segons açò sembla lògic ignorar
les diferències de majúscules/minúscules.

#+begin_src emacs-lisp :tangle yes
  (setq sort-fold-case t)
#+end_src

Per classificar:

#+begin_src emacs-lisp :tangle yes
  (setq inhibit-eol-conversion nil)

  (setq text-scale-mode-step 1.1)

  ;; assorted
  (setq ansi-color-for-comint-mode t)
  (setq current-language-environment "UTF-8")

  ;; display-buffer-reuse-frames is a variable defined in `window.el'.
  ;; Its value is nil
  ;;
  ;;   This variable is obsolete since 24.3;
  ;;   use a `reusable-frames' alist entry in `display-buffer-alist'.
  ;;
  ;; Documentation:
  ;; Non-nil means `display-buffer' should reuse frames.
  ;; If the buffer in question is already displayed in a frame, raise
  ;; that frame.
  (setq display-buffer-reuse-frames t)

  (setq next-line-add-newlines nil)
  (setq scroll-preserve-screen-position t)
  (customize-set-value 'scroll-step 1)
  (customize-set-value 'scroll-conservatively 10000)
  (setq tooltip-mode t)
  (setq transient-mark-mode t)
  (setq visible-bell nil)
#+end_src

*** Backups

El 99% del temps els arxius de backup creats durant l'edició són més
una molèstia que altra cosa. Es mouen a un directori de backup per si
cal recuperar-los.

#+begin_src emacs-lisp :tangle yes
  (let ((backup-dir (arv/path-concat user-emacs-directory "backups" "files")))
    (unless (file-directory-p backup-dir)
      (make-directory backup-dir t))
    (setq backup-directory-alist `(("." . ,backup-dir))))
#+end_src

*** Diferenciar modes /insert/ i /overwrite/

Es aquest apartat es configura el canvi del color del cursor per
indicar que ens troben en mode inserció o sobreescriptura.

Guarda el color del cursor en mode /insert/ per poder restaurar-lo al
alternar entre /overwrite/ i /insert/.

#+begin_src emacs-lisp :tangle yes
  (when (null my/face-cursor-insert-background-color)
    (setq my/face-cursor-insert-background-color
          (face-attribute 'cursor :background)))
#+end_src

La solució original té un problema, el color del cursor és global
mentre que el mode insertar/sobreescriure és local a cada buffer. Al
cambiar de buffer no s'ajusta el color del cursor.

#+begin_src emacs-lisp :tangle no
  (defadvice overwrite-mode (after overwrite-mode-adjust-cursor activate)
    "Change cursor color when enabling/disabling overwrite mode."
    (set-cursor-color (if overwrite-mode
                          "purple"
                        my/face-cursor-insert-background-color)))
#+end_src

No he trobat cap /hook/ que es dispari si es canvia de buffer (=C-x
b=) o de finestra (=C-x o=). Aquesta solució s'executa després de cada
comanda amb el que hauria de ser acurada.

#+begin_src emacs-lisp :tangle yes
  (defun my/update-cursor-color-for-insert-overwrite-mode ()
    (set-cursor-color (if overwrite-mode
                          my/face-cursor-overwrite-background-color
                        my/face-cursor-insert-background-color)))

  (add-hook 'post-command-hook #'my/update-cursor-color-for-insert-overwrite-mode)
#+end_src

No espero que suposi un problema pel rendiment. Si ralentitza
apreciablement l'execució una altra possibilitat (cutre) seria aplicar
/advice/ també a les funcions que canvien de buffer i de finestra.

** Comandes
   :PROPERTIES:
   :ID:       02df8b30-de79-489f-b4c9-13162d5d2784
   :END:

Comandes que proveeixen funcionalitat a l'usuari (i poden estar
lligades a combinacions de tecles).

*** =arv/alternar-mida-font=

De vegades és interessant augmentar temporalment la mida de la font
(una visita amb qui cal revisar codi). Fins ara utilitzava =C-+= i
=C--= però no funciona bé amb =company-mode=, cal fer-ho buffer a
buffer i cada buffer acaba amb una mida de lletra diferent.

Aquesta funció alterna entre una mida per defecte i una de gran.

Pel moment les mides estan fixades al cos de la funció. És fràgil. He
provat guardant la mida inicial i comparant amb aquest valor per
determinar l'estat però no funciona. El valor guardat és 100 (el
assigant en la secció [[*Faces][Faces]]) però el llegit posteriormente en la
funció és 98. No sé si el tema o algun paquet canvia el valor o si és
algun tipus d'arrodoniment de la mida. Fins que esbrini una solució
millor és queda fixat i s'utilitza un /flag/ bi-estat per seguir la
pista de l'esta.

#+begin_src emacs-lisp :tangle yes
  (defvar arv/big-font-enabled nil)
  (defvar my/face-default-height (face-attribute 'default :height))
  (defvar my/face-default-big-height (truncate (* my/face-default-height 1.4)))

  (defun arv/alternar-mida-font ()
    "Alterna entre font 'normal' i 'gran'."
    (interactive)
    (set-face-attribute 'default nil
                        :height (if arv/big-font-enabled
                                    my/face-default-height
                                  my/face-default-big-height))
    (setq arv/big-font-enabled (not arv/big-font-enabled)))
#+end_src

*** =my/bash-terminal=

No m'acostumo a utilitzar la comanda =shell=, la meva teoria és que no
permet utilizar les tecles nadiues. Provaré una temporada amb =term=.

#+begin_src emacs-lisp :tangle yes
  (defun my/bash-terminal ()
    "Obre una terminal executant bash."
    (interactive)
    (term "/bin/bash"))
#+end_src

*** =arv/downcase-word= i =arv/upcase-word=

Converteix a majúscules/minúscules la paraula en el punt. A diferència
de =upcase-word= i =downcase-word=, no cal situar el punt al
començament de la paraula.

/Robat/ de http://oremacs.com/2014/12/23/upcase-word-you-silly/

#+begin_src emacs-lisp :tangle yes
  (defun arv/upcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'upcase-word))))

  (defun arv/downcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'downcase-word))))
#+end_src

*** =arv/duplicate-line-or-region-dwim=

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-dwim (arg)
    "Duplicate current line.

  - Without prefix argument duplicate current line.

  - Positive prefix ARG means include previous ARG lines plus the
    current one.

  - If ARG is negative include current line plus next ARG lines.

  - If the region is active duplicates all the complete lines
    intersecting with the region. ARG is ignored."
    (interactive "P")
    (let (start
          end
          where
          text)
      (cond
       ((region-active-p)
        (setq beg (save-excursion
                    (goto-char (min (point) (mark)))
                    (line-beginning-position)))
        (setq end (save-excursion
                    (goto-char (max (point) (mark)))
                    (forward-line)
                    (line-beginning-position)))
        (setq where end))
       ((null arg)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position 2))
        (setq where end))
       ((< arg 0)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position (+ (- arg) 2)))
        (setq where beg))
       (t
        (setq beg (line-beginning-position (+ (- arg) 1)))
        (setq end (line-beginning-position 2))
        (setq where end)))
      (save-excursion
        (goto-char end)
        (when (eobp)
          (newline)
          (setq end (1+ end))
          (unless (= where beg)
            (setq where end))))
      (setq text (buffer-substring-no-properties beg end))
      (goto-char where)
      (insert text)
      (goto-char where)
      (back-to-indentation)))
#+end_src

*** =arv/duplicate-line-or-region-and-comment-dwim=

#+begin_src emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-and-comment-dwim (start stop)
    "Duplicate the whole lines i region and comment them.
  Mostly equivalent to select region, copy, paste, select again and
  comment region, but the region is not copied to the kill ring and
  the text properties are removed."
    (interactive "r")
    (let* ((beg (progn (goto-char start) (line-beginning-position)))
           (end (progn (goto-char stop) (line-end-position)))
           (text (buffer-substring-no-properties beg end)))
      (goto-char end)
      (newline)
      (insert text)
      (comment-region beg end)))
#+end_src

*** =arv/generate-random-uuid= i =arv/insert-random-uuid=

#+begin_src emacs-lisp :tangle yes
  (defun arv/generate-random-uuid ()
    (with-temp-buffer
      (shell-command "uuidgen -r" t)
      (beginning-of-buffer)
      (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/insert-random-uuid ()
    "Insert random UUID"
    (interactive)
    (insert (arv/generate-random-uuid)))
#+end_src

*** =arv/goto-line=

Com =goto-line= però activa =linum-mode= per facilitar identificar la
línia.

No ho utilitzo gaire.

#+begin_src emacs-lisp :tangle yes
  (defun arv/goto-line ()
    "Like `goto-line' but temporarily display absolute line
  numbers."
    (interactive)
    (let ((linum-enabled linum-mode))
      (unwind-protect
          (let ((relative-linum-enabled nil))
            (linum-mode 1)
            (call-interactively 'goto-line))
        (unless linum-enabled
          (linum-mode -1)))))
#+end_src

*** =my/json-prettify=

https://coderwall.com/p/2vnxaw/beautify-json-in-emacs

#+begin_src emacs-lisp :tangle yes
  (defun my/json-prettify ()
    (interactive)
    (let ((b (if mark-active (min (point) (mark)) (point-min)))
          (e (if mark-active (max (point) (mark)) (point-max))))
      (shell-command-on-region
       b e
       "python -mjson.tool"
       (current-buffer) t)))
#+end_src

*** =my/kill-region=

De vegades premo =C-w= per error i esborro la regió quan no està
marcada, resulta molest. Aquesta comanda executa =kill-region=
únicament si la regió està activa.

#+begin_src emacs-lisp :tangle yes
  (defun my/kill-region (beg end &optional region)
    "kill-region només si la regió està activa."
    (interactive (list (mark) (point) 'region))
    (when (region-active-p)
      (kill-region beg end region)))
#+end_src

*** =my/kill-to-beginning-of-line= i =my/kill-to-indentation=

Moltes vegades vull esborrar cap al principi de la línia enlloc de cap
al final. =kill-line= permet esborrar cap enrere especificant un
prefix negatiu però al especificar -1 esborra fins la línia anterior.
No he trobat com fer el que vull.

Aquestes comandes implementen variants d'aquesta idea, esborren fins
el començament de la línia, fins al sagnat o combinen les dos.

#+begin_src emacs-lisp :tangle yes
  (defun my/kill-to-beginning-of-line ()
    "Esborra enrere fins el començament de la línia."
    (interactive)
    (kill-region (line-beginning-position) (point)))

  (defun my/kill-to-indentation ()
    "Esborra enrere fins el sagnat."
    (interactive)
    (let ((position (save-excursion
                      (back-to-indentation)
                      (point))))
      (kill-region position (point))))

  (defun my/kill-to-indentation-or-beginning-of-line ()
    "Esborra enrere fins el sagnat i si el punt ja està en el
  sagnat esborra fins al començament de la linia."
    (interactive)
    (let ((indentation (save-excursion
                         (back-to-indentation)
                         (point))))
      (if (= indentation (point))
          (kill-region (line-beginning-position) indentation)
        (kill-region indentation (point)))))
#+end_src

*** =arv/kill-ring-save-word-at-point=

#+begin_src emacs-lisp :tangle yes
  (defun arv/kill-ring-save-word-at-point ()
    "Copia un text en el kill ring. El seu comportament varia
  depenent de si la marca està o no activa:

  - si està activa delega en `kill-ring-save' i es copia el text
    seleccionat.

  - sinó es copia el símbol sobre el que està situat el cursor."
    (interactive)
    (if mark-active
        (call-interactively 'kill-ring-save)
      (kill-new (thing-at-point 'symbol t))))
#+end_src

*** =arv/open-line-after-and-indent=, =arv/open-line-before-and-indent=

#+begin_src emacs-lisp :tangle yes
  (defun arv/open-line-before-and-indent (n)
    "Insereix una línia abans de l'actual i indenta. Amb un prefix
  numèric N insereix N línies."
    (interactive "*p")
    (open-line n)
    (indent-according-to-mode))

  (defun arv/open-line-after-and-indent (n)
    "Insereix una línia després de l'actual i indenta. Amb un
  prefix numèric N insereix N línies."
    (interactive "*p")
    (end-of-line)
    (newline n)
    (indent-according-to-mode))
#+end_src

*** =arv/query-replace=

#+begin_src emacs-lisp :tangle yes
  (defun arv/query-replace (&optional arg)
    "Replacement for `query-replace'.

  - It proposes the symbol at point as the initial value for the
    search string.

  - If the region is active it contraints the replacement,
    otherwise operate on the whole buffer.

  - Without prefix argument performs `query-replace'.

  - With C-u performs `replace-string'.

  In any case point is preserved."
    (interactive "*P")
    (let* ((old-string (read-string "Replace: " (thing-at-point 'symbol t)))
           (new-string (read-string (concat "Replace " old-string " with: ") ""))
           (start (if mark-active (min (mark) (point)) (point-min)))
           (end   (if mark-active (max (mark) (point)) (point-max))))
      (save-excursion
        (if (not arg)
            (query-replace old-string new-string nil start end)
          (goto-char start)
          (while (search-forward old-string end t)
            (replace-match new-string))))))
#+end_src

*** =my/compile-with-comint-enabled=

cpctelera inclou color en la sortida de les comandes, específicament
en la compilació. La comanda =compile= per defecte mostra els codis
ANSI i la sortida resulta difícil de llegir. Es pot invocar amb =C-u=
per activar =comint-mode= però mai hi penso i requereix dos tecles.
Addicionalment cal escriure/confirmar la comanda de compilació.

Aquesta funció és la contraria de =compile=, per defecte activa
=comint-mode= i amb =C-u= el desactiva. No pregunta per la comanda de
compilació, utilitza el valor de la variable =compile-command= (cal
assignar-li un valor en la configuració d'Emacs o en un arxiu
=.dir-locals.el=).

Té dos detalls que caldria polir:

- el buffer s'obre en mode escriptura

- no reconneix la comanda =q= per tancar el buffer (insereix una =q=
  o, si es canvia a =read-only-mode=, dóna un error /buffer de sols
  lectura/).

#+begin_src emacs-lisp :tangle yes
  (defun my/compile-with-comint-enabled (&optional no-comint)
    ""
    (interactive "P")
    (compile (eval compile-command) (not no-comint)))
#+end_src

*** =my/dedent-to-point=
    :PROPERTIES:
    :CREATED:  <2021-01-05 dt. 10:18>
    :END:

Una necessitat habitual és esborrar els espais des del punt fins el
començament del text situat a la dreta del punt. Les funcions
=just-one-space= i similars afecten als espais als dos costats del
punt. =zap-up-to-char= valdria però requereix massa atenció.

=my/dedent-to-point= implementa aquesta funcionalitat. També permet
fussionar línies de forma més àgil que amb la combinació =M-d C-_= que
utilitzo actualment.

#+begin_src emacs-lisp :tangle yes
  (defun my/dedent-to-point (arg)
    "Si el punt està sobre un espai o al final de la línia esborra
  tots els espais situats a la dreta fins trobar el primer caràcter
  que no és un espai o arribar al final de línia.

  Si es crida amb un prefix (C-u) la cerca continua fins el final
  del buffer."
    (interactive "p")
    (when (or (eolp) (looking-at-p "\s"))
      (let* ((begin (point))
             (limit (if (= arg 1) (point-at-eol) (point-max)))
             (end (save-excursion
                    (skip-syntax-forward " " limit)
                    (point))))
        (delete-region begin end))))
#+end_src

*** =my/display-line-numbers-mode=

Activa/desactiva la numeració de les línies. Si està disponible
=display-line-numbers-mode= la utilitza, en cas contrari utilitza
=linum-mode=.

#+begin_src emacs-lisp :tangle yes
  (defun my/display-line-numbers-mode ()
    "Activa la numeració de les línies."
    (interactive)
    (if (fboundp 'display-line-numbers-mode)
        (if display-line-numbers-mode
            (display-line-numbers-mode 0)
          (my/enable-line-numbers-mode))
      (if linum-mode
          (linum-mode 0)
        (linum-mode 1))))
#+end_src

*** =my/rename-file-and-buffer=

Renombrar l'arxiu actual des d'Emacs requereix obrir un buffer
=dired=, localitzar l'arxiu i renombrar-lo. No és especialment àgil.
Aquesta comanda ho simplifica.

Basat en http://steve.yegge.googlepages.com/my-dot-emacs-file

#+begin_src emacs-lisp :tangle yes
  (defun my/rename-file-and-buffer ()
    "Renames both current buffer and file it's visiting."
    (interactive)
    (if (not (buffer-file-name))
        (message "Buffer '%s' is not visiting a file!" (buffer-name))
      (let ((new-name (read-shell-command "New name: ")))
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (rename-file (buffer-file-name) new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))
#+end_src

*** =my/unfill-paragraph=
    :PROPERTIES:
    :ID:       3ec64e49-8906-49c2-9377-8c9b44ae6e61
    :END:

De vegades, al enganxar un paràgraf, =M-q= no fal el que vull i l'he
de convertir en una única línia (a base de =C-e SUPR SPC=) o corregir
el sagnat manualment per tornar a ajustar-lo. Per exemple:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
  facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
  quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
  Sed bibendum.
#+end_example

Aquesta comanda, copiada de la configuració de Sacha Chua, automatitza
aquesta transformació:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum.
#+end_example

i el paràgraf resultat ara es pot ajustar satisfactoriament amb =M-q=:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
    facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
    quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
    Sed bibendum.
#+end_example

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))
#+end_src

En funció de l'ús que en fàci potser valdria la pena definir una
comanda equivalment a =M-Q M-q=.

*** =my/visit-emacs-config= etc.

Comandes per visitar arxius i directoris relacionats amb la
configuració d'emacs:

#+begin_src emacs-lisp :tangle yes
  (defun my/visit-emacs-config ()
    "Visita l'arxiu de configuració d'emacs."
    (interactive)
    (let ((settings-org (arv/path-concat arv/emacs-conf-dir "settings.org")))
      (find-file settings-org)))

  (defun my/visit-emacs-notes ()
    "Visita l'arxiu de configuració d'emacs."
    (interactive)
    (let ((settings-org (arv/path-concat arv/emacs-conf-dir "notes.org")))
      (find-file settings-org)))

  (defun my/visit-emacs-config-directory ()
    "Visita el directori de configuració d'emacs."
    (interactive)
    (find-file arv/emacs-conf-dir))
#+end_src

*** =my/xml-prettify-buffer=

De vegades em cal formatejar un document XML que ve en una única
línia. Aquesta funció formateja un buffer amb contingut XML (o HTML).

#+begin_src emacs-lisp :tangle yes
  (defun my/xml-prettify-buffer ()
    "Formateja (pretty print) un buffer xml."
    (interactive)
    (save-mark-and-excursion
      (sgml-pretty-print (point-min) (point-max))))
#+end_src

*** Comentari dins rectangle

http://pragmaticemacs.com/emacs/comment-boxes/

Semblant a [[help:comment-box][=comment-box=]], fa que el retangle tingui una amplada mínima
igual a =fill-column=.

#+begin_src emacs-lisp :tangle yes
  (defun bjm-comment-box (b e)
    "Draw a box comment around the region but arrange for the
  region to extend to at least the fill column. Place the point
  after the comment box."

    (interactive "r")

    (let ((e (copy-marker e t)))
      (goto-char b)
      (end-of-line)
      (insert-char ?  (- fill-column (current-column)))
      (comment-box b e 1)
      (goto-char e)
      (set-marker e nil)))
#+end_src

[[https://github.com/lewang/rebox2/blob/master/rebox2.el][rebox2]] és una alternativa aparentment més flexible.

*** Partir finestres

Idea treta del vídeo [[https://www.youtube.com/watch?v=nKCKuRuvAOw&t=252][Emacs microhabit - Switching windows]] de Sacha
Chua: parteix una finestra horitzontal/verticalment i mostra un buffer
diferent en la nova finestra.

La versió de Sacha Chua selecciona automàticament el buffer, no m'he
pogut acostumar. Aquesta versió permet triar el buffer (o arxiu) que
es mostrarà en la nova finestra.

#+begin_src emacs-lisp :tangle yes
  (defun arv/split-windows-bellow (prefix)
    "Parteix la finestra verticalment i tria el buffer a mostrar.

  Al partir una finestra permet seleccionar quin buffer es mostrarà
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estàndard estan disponibles. Especialment útils són:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel·la la selecció, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-below)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))

  (defun arv/split-windows-right (prefix)
    "Parteix la finestra horitzontalment i tria el buffer a mostar.

  Al partir una finestra permet seleccionar quin buffer es mostrarà
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estàndard estan disponibles. Especialment útils són:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel·la la selecció, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-right)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))
#+end_src

*** conversió d'entitats HTML <-> caràcter

Modificacions menors al codi trobat en:

https://stackoverflow.com/questions/24085067/is-there-an-emacs-package-for-html-escaping

- afegit =save-excursion=

- fer explícit que cal concondància majúscules/minúscules en les
  cerques.

#+begin_src emacs-lisp :tangle yes
  (setq ar-html2uml
    '(
      ("&AElig;" "Æ")
      ("&Aacute;" "Á")
      ("&Acirc;" "Â")
      ("&Agrave;" "À")
      ("&Aring;" "Å")
      ("&Atilde;" "Ã")
      ("&Auml;" "Ä")
      ("&Ccedil;" "Ç")
      ("&ETH;" "Ð")
      ("&Eacute;" "É")
      ("&Ecirc;" "Ê")
      ("&Egrave;" "È")
      ("&Euml;" "Ë")
      ("&Iacute;" "Í")
      ("&Icirc;" "Î")
      ("&Igrave;" "Ì")
      ("&Iuml;" "Ï")
      ("&Ntilde;" "Ñ")
      ("&Oacute;" "Ó")
      ("&Ocirc;" "Ô")
      ("&Ograve;" "Ò")
      ("&Oslash;" "Ø")
      ("&Otilde;" "Õ")
      ("&Ouml;" "Ö")
      ("&Ouml;" "Ö")
      ("&THORN;" "Þ")
      ("&Uacute;" "Ú")
      ("&Ucirc;" "Û")
      ("&Ugrave;" "Ù")
      ("&Uuml;" "Ü")
      ("&Yacute;" "Ý")
      ("&aacute;" "á")
      ("&acirc;" "â")
      ("&acute;" "\x{00B4}")
      ("&aelig;" "æ")
      ("&agrave;" "à")
      ("&aring;" "å")
      ("&atilde;" "ã")
      ("&auml;" "ä")
      ("&brvbar;" "\x{00A6}")
      ("&ccedil;" "ç")
      ("&cedil;" "\x{00B8}")
      ("&cent;" "¢")
      ("&copy;" "©")
      ("&curren;" "\x{00A4}")
      ("&deg;" "°")
      ("&divide;" "÷")
      ("&eacute;" "é")
      ("&ecirc;" "ê")
      ("&egrave;" "è")
      ("&eth;" "ð")
      ("&euml;" "ë")
      ("&frac12;" "\x{00BD}")
      ("&frac14;" "\x{00BC}")
      ("&frac34;" "\x{00BE}")
      ("&iacute;" "í")
      ("&icirc;" "î")
      ("&iexcl;" "¡")
      ("&igrave;" "ì")
      ("&iquest;" "¿")
      ("&iuml;" "ï")
      ("&laquo;" "«")
      ("&macr;" "¯")
      ("&micro;" "µ")
      ("&middot;" "·")
      ;; ("&nbsp;" " ")
      ("&not;" "¬")
      ("&ntilde;" "ñ")
      ("&oacute;" "ó")
      ("&ocirc;" "ô")
      ("&ograve;" "ò")
      ("&ordf;" "ª")
      ("&ordm;" "º")
      ("&oslash;" "ø")
      ("&otilde;" "õ")
      ("&ouml;" "ö")
      ("&para;" "¶")
      ("&plusmn;" "±")
      ("&pound;" "£")
      ("&raquo;" "»")
      ("&reg;" "®")
      ("&sect;" "§")
      ("&shy;" "­")
      ("&sup1;" "¹")
      ("&sup2;" "²")
      ("&sup3;" "³")
      ("&szlig;" "ß")
      ("&thorn;" "þ")
      ("&times;" "×")
      ("&uacute;" "ú")
      ("&ucirc;" "û")
      ("&ugrave;" "ù")
      ("&uml;" "\x{00A8}")
      ("&uuml;" "ü")
      ("&yacute;" "ý")
      ("&yen;" "¥")
      ("&yuml;" "ÿ")
      ))

  (defun ar-uml2html ()
    "Translate chars into html entities"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil)
          erg)
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (cadr ele) nil t 1)
            (setq erg (car ele))
            ;; Replacing with code starting from & upcases
            ;; Emacs bug?
            (replace-match "")
            (insert erg))))))

  (defun ar-html2uml ()
    "Translate html entities into text"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil))
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (car ele) nil t 1)
            (replace-match "")
            (insert (cadr ele)))))))

#+end_src

*** conversió de format DOS <-> UNIX

#+begin_src emacs-lisp :tangle yes
  (defun unix-to-dos ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun dos-to-unix ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix))
#+end_src

*** =endless/comment-line-or-region=

Comment or uncomment current line and leave point after it. With
positive prefix, apply to N lines including current one. With negative
prefix, apply to -N lines above. If region is active, apply to active
region instead.

http://endlessparentheses.com/implementing-comment-line.html

#+begin_src emacs-lisp :tangle yes
  (defun endless/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above.
  If region is active, apply to active region instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range)))
      (forward-line 1)
      (back-to-indentation)))
#+end_src

*** =endless/isearch-symbol-with-prefix=

Like isearch, unless prefix argument is provided. With a prefix
argument P, isearch for the symbol at point.

http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html

#+begin_src emacs-lisp :tangle yes
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))
#+end_src

*** =zap-up-to-char=

Kill up to but not including ARGth occurrence of CHAR. Case is ignored
if `case-fold-search' is non-nil in the current buffer. Goes backward
if ARG is negative; error if CHAR not found.

#+begin_src emacs-lisp :tangle yes
(defun zap-up-to-char (arg char)
  "Kill up to but not including ARGth occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     (read-char "Zap up to char: " t)))
  (zap-to-char arg char)
  (insert char)
  (when (> arg 0)
    (forward-char -1)))
#+end_src

** Mini paquets

Implementació de funcionalitat que requereix més que una funció però
no té un paquet pròpi.

*** =arv-org=                                               :desactivat:brut:

#+begin_src emacs-lisp :tangle no
  ;;; assorted utilities

  (autoload 'org-agenda-files "org" "" nil nil)

  (defun arv/org-visit-agenda-file ()
    ""
    (interactive)
    (find-file
     (ido-completing-read "Agenda file:" (org-agenda-files) nil t)))


  (defun arv/org--get-tags ()
    (delete "" (split-string (or (org-entry-get (point) "TAGS") "") ":")))

  (defun arv/org--get-parent-tags ()
    (save-excursion
      (save-restriction
        (widen)
        (if (org-up-heading-safe)
            (delete "" (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
          nil))))

  (defun arv/org-remove-reduntant-tags ()
    "Walks the tree-at-point removing redundant tags."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         (lambda ()
           (let ((tags    (arv/org--get-tags))
                 (alltags (arv/org--get-parent-tags)))
             (dolist (tag tags)
               (when (member tag alltags)
                 (org-toggle-tag tag 'off)))))
         nil 'tree)))
    ;; Something gets corrupted and tags are not displayed. That
    ;; happens in my real org file, in test.org (simplest) it works ok.
    ;; Collapsing works around the issue.
    (org-shifttab 2))

  (defun arv/org-add-inherited-tags ()
    "Add inherited tags to sutree-at-point."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-back-to-heading)
        (let ((tags    (arv/org--get-tags))
              (alltags (arv/org--get-parent-tags)))
          (dolist (tag alltags)
            (unless (member tag tags)
              (org-toggle-tag tag 'on))))
        nil 'tree)))

  (defun arv/org-refile (&rest args)
    "Like org-refile but updates tags."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-refile args)
    (save-excursion
      (org-refile '(16))                 ;goto insertion
      (arv/org-remove-reduntant-tags)))


  (defun arv/org-archive-subtree (&rest args)
    "Add inherited tags on archiving."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-archive-subtree args))


  (defun arv/org-start ()
    "Start org agenda within emacs server."
    (interactive)
    (server-start)
    (org-agenda nil "a"))
#+end_src

**** Codi desactivat                                             :desactivat:

Els enllaços /ecfg/ permeten referenciar la configuració d'emacs. Al
moure la configuració dins un document /org/ probablement ja no són
necessaris.

Es manté com exemple.

#+begin_src emacs-lisp :tangle no
  ;;; 'ecfg:' links
  ;;
  ;; 'ecfg:' URLs point to files in my emacs configuration. The links
  ;; are relative to `emacs-startup-dir'. Useful for tasks/notes when
  ;; hacking my emacs configuration.

  (defun arv/org-ecfg--relativize-to-startup-dir-maybe (path)
    "Converts .PATH into a path relative to
  `emacs-startup-dir'. Returns the relative path or nil if PATH is
  outside `emacs-startup-dir'.

  PATH must be absolute."
    (let ((abs-startup-dir (file-name-as-directory (expand-file-name emacs-startup-dir))))
      (if (s-starts-with-p abs-startup-dir path)
          (s-chop-prefix abs-startup-dir path)
        nil)))

  (defun arv/org-ecfg--link-at-point-get-range ()
    "Returns a list with the start and end position for the link at
  point. A link is delimited by blanks and beggining/end of line."
    (let ((start (save-excursion
                   (skip-syntax-backward "^-" (line-beginning-position))
                   (point)))
          (end (save-excursion
                 (skip-syntax-forward "^-" (line-end-position))
                 (point))))
      (list start end)))

  (defun arv/org-ecfg-open (path)
    "Visit the file within `emacs-startup-dir'."
    (find-file (arv/path-join emacs-startup-dir path)))

  (defun arv/org-ecfg-store-link ()
    "Store a link to an emacs config file."
    (let ((link (arv/org-ecfg--relativize-to-startup-dir-maybe (buffer-file-name))))
      (when link
        (org-store-link-props
         :type "ecfg"
         :link (concat "ecfg:" link)
         :description (format "%s" link)))))

  (defvar arv/org-ecfg-insert-link-at-point-history nil)

  (defun arv/org-ecfg-insert-link-at-point (arg)
    "Insert a ecfg link using the text around the point. By default
  the description part is the same as the text. Use the prefix
  command in order to edit the description."
    (interactive "*P")
    (let* ((range (if mark-active
                      (list (point) (mark))
                    (arv/org-ecfg--link-at-point-get-range)))
           (text (apply 'buffer-substring-no-properties range))
           (link (if (s-starts-with-p "ecfg:" text)
                     text
                   (concat "ecfg:" text)))
           (description (if (s-starts-with-p "ecfg:" text)
                            (mapconcat 'identity (cdr (s-split ":" text)) ":")
                          text)))
      (if mark-active
          (deactivate-mark))
      (if arg
          (setq description (read-from-minibuffer "Description:" description
                                                  nil nil
                                                  'arv/org-ecfg-insert-link-at-point-history)))
      (apply 'delete-region range)
      (insert (format "[[%s][%s]]" link description))))
#+end_src

Funcionalitat relacionada amb el seguiment del temps invertit en
tasques, gestió de interrupcions etc. Maig vaig aconsseguir
integrar-ho en el workflow.

#+begin_src emacs-lisp :tangle no
  ;;; state change and clock
  ;;
  ;; I want the clock to automatically start/stop clocking whenever a
  ;; task's state changes.
  ;;
  ;; Entering a state may trigger an action:
  ;;
  ;; - start: start clocking the current task. Clock-out the active task
  ;;   if any.
  ;;
  ;; - stop: stop clocking, but only if the current task is the active
  ;;   task. That's required in order to ensure that changing a task
  ;;   from a /paused/ state to other /paused/ state (from PAUSE to WAIT
  ;;   btw) does not clocks-out the active task,
  ;;
  ;; The mapping between states and actions is stored in the alist
  ;; `arv/org-sctc-entering-state-clocking-actions'. If an state is
  ;; missing or its associated action is nil then no action is performed
  ;; when it's entered.
  ;;
  ;; In case a task is being paused as a consequence of other being
  ;; started it will be put in the state defined in the variable
  ;; `arv/org-sctc-paused-state'.
  ;;
  ;; In order to enable that functionalitty call `arv/org-sctc-setup'
  ;; with no argument or nil. Passing an argument other than nil will
  ;; disable it.

  (defvar arv/org-sctc-entering-state-clocking-actions nil
    "alist mapping states to actions.")

  (defvar arv/org-sctc-paused-state nil
    "Stated for the task being paused.")


  (defvar arv/org-sctc--previous-active-task-marker nil)

  (defun arv/org-sctc--get-state-action (to)
    (cdr (assoc to arv/org-sctc-entering-state-clocking-actions)))

  (defun arv/org-sctc--pause-other-task ()
    (when arv/org-sctc--previous-active-task-marker
      (unwind-protect
          (save-excursion
            (goto-char arv/org-sctc--previous-active-task-marker)
            ;; IMPORTANT: calling org-todo may produce infinite
            ;; recursion, be careful when changing the code!!
            (org-todo arv/org-sctc-paused-state))
        (progn
          (set-marker arv/org-sctc--previous-active-task-marker nil)
          (setq arv/org-sctc--previous-active-task-marker nil)
          (remove-hook 'post-command-hook 'arv/org-sctc--pause-other-task)))))

  (defun arv/org-sctc--state-change (from to)
    (when (and (null arv/org-sctc--previous-active-task-marker)
               (not (string= from to)))
      (let ((action (arv/org-sctc--get-state-action to)))
        (unless (null action)
          (cond
           ((eq action 'start)
            (when (org-clock-is-active)
              (setq arv/org-sctc--previous-active-task-marker (copy-marker org-clock-marker))
              (org-clock-out)
              (add-hook 'post-command-hook 'arv/org-sctc--pause-other-task 'append))
            (org-clock-in))
           ((eq action 'stop)
            (let ((org-state "DONE") ;; hackish, review!!
                  (org-clock-out-when-done t))
              (org-clock-out-if-current)))
           (t (user-error "Unknown action.")))))))

  (defun arv/org-sctc--state-change-callback (p)
    (let ((type (plist-get p :type))
          (from (plist-get p :from))
          (to   (plist-get p :to)))
      (when (eq type 'todo-state-change)
        (arv/org-sctc--state-change from to))))

  (defun arv/org-sctc-setup (&optional disable)
    (if disable
        (remove-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)
      (add-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)))

  ;;; Interruption handling
  ;;
  ;; I want to be able to track interruptions and resume interrupted
  ;; tasks.
  ;;
  ;; Execute `arv/org-interrupt-interrupt-active-task' to put the active
  ;; task in hold, pause the clock and start capturing.
  ;;
  ;; Execute `arv/org-interrupt-resume-last-active-task' to resume the
  ;; last interrupted task, if any.

  (defvar arv/org-interrupt-resumed-state nil
    "State to put the task on when resuming after an
  interruption.")

  (defvar arv/org-interrupt-interrupted-state nil
    "State to put the task on when interrupted.")

  (defvar arv/org-interrupt-capture-key nil
    "Key for the capture template used by the interruption.")

  (defvar arv/org-interrupt--last-active-task nil
    "Private")

  (defun arv/org-interrupt-interrupt-active-task ()
    "Interrupts the active task (if any) and starts capturing an
  interruption.

  If there's an active task its ID is saved in the variable
  `arv/org-interrupt--last-active-task'."
    (interactive)
    (save-excursion
     (when (org-clock-is-active)
       (org-clock-goto)
       (setq arv/org-interrupt--last-active-task (org-id-get-create))
       (org-todo arv/org-interrupt-interrupted-state)))
    (org-capture nil arv/org-interrupt-capture-key))

  (defun arv/org-interrupt-resume-last-active-task ()
    "If there's an interrupted task jump to it and start it again.

  Currently this function relies on the value of the variable
  `arv/org-interrupt--last-active-task' in order to locate the
  interrupted task. The value of this variable won't survive
  restarting emacs and won't be saved."
    (interactive)
    (when arv/org-interrupt--last-active-task
      (org-id-goto arv/org-interrupt--last-active-task)
      (setq arv/org-interrupt--last-active-task nil)
      (org-todo arv/org-interrupt-resumed-state)))
#+end_src

*** =arv-template=

=arv-template= aprofita =yasnippet= per oferir plantilles amb
contingut inicial al crear nous arxius.

El funcionament es basa en que quan es crea un nou buffer, si compleix
certes condicions (estar buid, tindre associat un fitxer etc.),
s'insereix el text =header= (configurable en la variable
=arv/template-snippet-key=) i s'utilitza =yasnippet= per expandir-lo.

Per utilitzar-lo només cal crear /snippets/ amb la clau (=key=)
=header=.

**** Codi
     :PROPERTIES:
     :ID:       57ae3e72-5e9d-4d4c-ada6-c6a93594a458
     :END:

This works by letting =yasnippet= expand the value of the customizable
variable =arv/template-snippet-key= (=header= by default) whenever
visiting a new file.

Two questions arise:

- when to insert/expand the key?

- what to do if the expansion fails?

In order to find the right snippet the buffer must be already in the
right major mode. My first attempt was hooking a function to
=find-file-not-found-functions=, but this didn't work because at that
point the buffer is still in =fundamental-mode=.

So I have decided to track the mode changes using
=after-change-major-mode-hook=, this has a couple of drawbacks:

- apparently a newly created buffer is put in =fundamental-mode= and
  then switched to its final mode, so the functions hooked to
  =after-change-major-mode-hook= should account for being called at
  least twice.

- the function must determine by itself if the buffer is visiting a
  new file or an existing one.

Finally, if the expansion fails the key ("header") must be removed. At
first I tried with =undo= but emacs complained "no further undo
information" so I decided to explicitly delete the key.

#+begin_src emacs-lisp :tangle yes
  ;;; HACK: no s'hauria de requerir yasnippet. El problema és que açò no
  ;;; és un mòdul que es pot carregar sota demanda.

  (require 'yasnippet)
  (defgroup arv/template nil
    "Insert documentation here."
    :group 'arv)

  (defcustom arv/template-snippet-key "header"
    "Name of the snippet."
    :group 'arv/template
    :type  'string
    :safe  'stringp)


  (defun arv/template-insert-header ()
    (when (and (not buffer-read-only)
               (not (eq major-mode 'fundamental-mode))
               (buffer-file-name)
               (save-excursion (goto-char (point-min))
                               (eobp)) ; empty buffer?
               (not (file-exists-p (buffer-file-name))))
      (let ((pos (point)))
        (insert arv/template-snippet-key)
        (unless (yas-expand-from-trigger-key)
          (goto-char pos)
          (delete-char (length arv/template-snippet-key) nil)
          (set-buffer-modified-p nil)))))


  (defun arv/template-setup ()
    (add-hook 'after-change-major-mode-hook 'arv/template-insert-header))
#+end_src

**** Instal·lació/activació

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'yas-snippet-dirs
               (arv/path-concat arv/emacs-conf-dir "shared" "templates"))
  (arv/template-setup)
#+end_src

*** =arv-test=

Helpers per simplificar els tests. Molt probablement existirà una
biblioteca que proveeixi aquesta funcionalitat.

#+begin_src emacs-lisp :tangle yes
  (defun arv-test--mk-buffer (&optional content mode point-marker)
    "Creates a buffer with the given content, mode and point."
    (let ((buffer (generate-new-buffer "*test_buffer*")))
      (with-current-buffer buffer
        (when content
          (insert content))
        (when point-marker
          (goto-char (point-min))
          (when (search-forward point-marker)
            (delete-char (- (length point-marker)))))
        buffer)))

  (defmacro arv-test-with-buffer (content mode point-marker &rest body)
    (declare (indent 1) (debug t))
    `(save-current-buffer
       (set-buffer (arv-test--mk-buffer ,content ,mode ,point-marker))
       ,@body
       (kill-buffer)))
#+end_src

*** =arv-yasnippet=

Colecció caòtica de funcions (i una variable) que faciliten la
definició de snippets.

#+begin_src emacs-lisp :tangle yes
  (defvar django-widget-types '("CheckboxInput"
                                "CheckboxSelectMultiple"
                                "DateInput"
                                "DateTimeInput"
                                "FileInput"
                                "HiddenInput"
                                "MultipleHiddenInput"
                                "NullBooleanSelect"
                                "PasswordInput"
                                "RadioSelect"
                                "Select"
                                "SelectMultiple"
                                "Textarea"
                                "TextInput"
                                "TimeInput"))
#+end_src

Operacions amb cadenes:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-uncamelize (text sep)
    "Retorna text sense 'camelitzar'.

  Si 'text' es 'CamelCase' i 'sep' es '-' retorna 'camel-case'.

  Es suposa que 'text' es un identificador valid escrit en
  CamelCase. 'sep' es un string.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'downcase (s-split-words text) sep)))

  (defalias 'arv-yas-uncamelize 'arv/yas-uncamelize)

  (defun arv/yas-camelize (text)
    "Retorna TEXT 'camelitzat'.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'capitalize (s-split-words text) "")))

  (defun arv/yas-substring (text start end)
    "Retorna un substring.

  Esta versio de substring s'ajusta als limits i, a diferencia de
  substring, no produeix cap error si es sobrepassen.
  "
    (substring text (max 0 start) (min end (length text))))

  (defalias 'arv-yas-substring 'arv/yas-substring)

  (defun arv/string-strip-delimiters (text delimiters)
    "Strip trailing and leading chars from TEXT if they are equal
  and appear in the string DELIMITERS.

  \"+foo+\" \"$\" -> \"+foo+\"
  \"+foo+\" \"$+\" -> \"foo\"
  \"+foo-\" \"+-\" -> \"+foo-\"
  "
    (if (< (length text) 2)
        text
      (let ((delimiters (delete "" (split-string delimiters "")))
            (left-char (substring text 0 1))
            (right-char (substring text (1- (length text)))))
        (if (and (string= left-char right-char)
                 (member left-char delimiters))
            (substring text 1 (1- (length text)))
          text))))

  (defun arv/string-replace-unwanted-chars (value predicate &optional replacement)
    "Returns a string built replacing the chars from the string
  VALUE for whom the function PREDICATE returns nil with the string
  REPLACEMENT.

  If REPLACEMENT is omitted or nil the empty string is used as the
  replacement."
    (let ((replacement (or replacement "")))
      (mapconcat (lambda (x) (cond
                         ((string= x "") "")
                         ((funcall predicate x) x)
                         (t replacement)))
                 (split-string value "")
                 "")))
#+end_src

Funcions especialitzades en codi javascript:

#+begin_src emacs-lisp :tangle yes
  (defun arv/js-make-identifier (text)
    "Replace invalid chars from TEXT with an underscore in order to
  make a valid javascrip identifier."
    (let ((result (arv/string-replace-unwanted-chars
                   text (lambda (x) (string-match "[$a-zA-Z0-9_]" x)) "_")))
      (if (string-match "^[$a-zA-Z_]" result)
          result
        (concat "_" result))))

  (defun arv/yas-js-amd-params-from-modules (text)
    "Given the modules of and AMD `define' generates the names of
  the corresponding function parametres.

  '\"dojo/foo\", \"digit/a_plugin!parameters\"' -> 'foo, a_plugin'
  "
    (s-join ", " (mapcar (lambda (x) (arv/js-make-identifier (car (last (s-split "/" (car (s-split "!" (arv/string-strip-delimiters (s-trim x) "'\""))))))))
                         (s-split "," text))))

  (defun arv/yas-js-get-parameter-names (text)
    (delete "" (mapcar 's-trim (split-string text ","))))

  (defun arv/yas-js-function-parameters-documentation (text &optional header)
    (let ((header (or header "Parameters"))
          (params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (- (current-column) 2) 32) "// ")))
      (if params
          (concat indent
                  header
                  indent
                  (mapconcat (lambda (x) (format "- %s : " x)) params indent))
        "")))

  (defun arv/yas-js-function-store-parameters (text)
    (let ((params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (current-column) 32))))
      (if params
          (concat indent
                  (mapconcat (lambda (x) (format "this._%s = %s;" x x)) params indent))
        "")))
#+end_src

Funcions especialitzades en codi python:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-py-parse-parameters (text)
   "Parseja els arguments d'una funcií/mètode.

  'foo, bar=value' -> (('foo') ('bar' 'value'))"
     (mapcar (lambda (x)
               (mapcar 's-trim (split-string x "=")))
             (split-string text ",")))

  (defalias 'arv-yas-py-parse-parameters 'arv/yas-py-parse-parameters)


  (defun arv/yas-py-get-parameter-names (text &optional exclude)
    "Retorna el nom dels paràmetres.

  Mira de netejar anomalies com parametres sense nom. Si
  s'especifica un valor diferent de `nil' per `exclude' s'exclouen
  el paràmetres '*args' i '**kw' si estan presents (es comprova que
  comencin per * no el nom concret).

  'foo, bar=value' -> ('foo', 'bar')
  'foo,, bar=value' -> ('foo', 'bar')
  'foo, bar=value, *args' -> ('foo', 'bar', '*args')

  Especificant `exclude':

  'foo, bar=value, *args' -> ('foo', 'bar')"
    (delq nil
          (mapcar (lambda (x)
                    (let ((name (nth 0 x)))
                      (unless (or (string= name "")
                                  (and (not (null exclude))
                                       (s-starts-with-p "*" name)))
                        name)))
                  (arv-yas-py-parse-parameters text))))

  (defalias 'arv-yas-py-get-parameter-names 'arv/yas-py-get-parameter-names)


  (defun arv/yas-py-function-parameters-documentation (text)
    "Retorna la documentació pels paràmetres d'una funció.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    :param foo:
    :param bar:
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat ":param " x ":"))
       (arv-yas-py-get-parameter-names text 't)
       indent)))

  (defalias 'arv-yas-py-function-parameters-documentation 'arv/yas-py-function-parameters-documentation)


  (defun arv/yas-py-constructor-store-arguments (text)
    "Retorna l'assignació a atributs en el constructor.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    self._foo = foo
    self._bar = bar
    self._args = args
    self._kw = kw
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat "self._" x " = " x))
       (mapcar
        (lambda (x)
          (s-chop-prefix "*" (s-chop-prefix "*" x)))
        (arv-yas-py-get-parameter-names text))
       indent)))

  (defalias 'arv-yas-py-constructor-store-arguments 'arv/yas-py-constructor-store-arguments)
#+end_src

Funcions especialitzades en codi sh:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-sh-getopt-case-options (text)
    "Retorna les opcions de 'case'.

  Converteix:

      a:b

  en:

      a) OPT_A=$OPTARG ;;
      b) OPT_B=1 ;;
  "
    (let ((indent (concat "\n" (make-string (current-column) 32)))
          (result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (and (> (length text) 1) (char-equal (aref text 1) ?:))
              (progn
                (setq text (substring text 2))
                (setq result (cons (format "%s) OPT_%s=$OPTARG ;;" char CHAR) result)))
            (setq result (cons (format "%s) OPT_%s=1 ;;" char CHAR) result))
            (setq text (substring text 1))
            )))
      (concat indent
              (mapconcat (lambda (x) x) (reverse result) indent))))

  (defun arv/yas-sh-getopt-var-declaration (text)
    "Retorna les variables.

  Converteix:

      a:b

  en:

      OPT_A=
      OPT_B=
  "
    (let ((result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (not (string-equal char ":"))
              (setq result (cons (format "OPT_%s=" CHAR) result)))
          (setq text (substring text 1))))
      (mapconcat (lambda (x) x) (reverse result) "\n")))
#+end_src

Funcions variades:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-today (&optional fmt)
    (let ((fmt (or fmt "%Y-%m-%d")))
      (format-time-string fmt)))

  (defun arv/yas-year ()
    (format-time-string "%Y"))

  (defun arv/yas-buffer-name ()
    (file-name-nondirectory (buffer-file-name)))

  (defun arv/yas-buffer-name-upcase ()
    (upcase (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans ()
    (file-name-sans-extension (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans-upcase ()
    (upcase (arv/yas-buffer-name-sans)))

  (defun arv/yas-buffer-name-sans-camelcase ()
    (arv/yas-camelize (arv/yas-buffer-name-sans)))

  (defun arv/yas-author-name ()
    user-full-name)

  (defun arv/yas-author-email ()
    user-mail-address)
#+end_src

** Combinacions de tecles globals

Aquest apartat és un copiar/enganxar de la configuració original. En
aquest punt moltes de les comandes no estan definides, d'altres són
redundants o mai les he arribat a incorporar en el /workflow/.

#+begin_src emacs-lisp :tangle yes
  ;; disable some keybindings

  ;; disable arrow  keys
  ;; (progn
  ;;   (global-unset-key (kbd "<up>"))
  ;;   (global-unset-key (kbd "<down>"))
  ;;   (global-unset-key (kbd "<left>"))
  ;;   (global-unset-key (kbd "<right>"))
  ;;   (global-unset-key (kbd "C-<up>"))
  ;;   (global-unset-key (kbd "C-<down>"))
  ;;   (global-unset-key (kbd "C-<left>"))
  ;;   (global-unset-key (kbd "C-<right>"))
  ;;   (global-unset-key (kbd "M-<up>"))
  ;;   (global-unset-key (kbd "M-<down>"))
  ;;   (global-unset-key (kbd "M-<left>"))
  ;;   (global-unset-key (kbd "M-<right>")))

  ;; (progn
  ;;   (global-set-key (kbd "M-n") 'forward-paragraph)
  ;;   (global-set-key (kbd "M-p") 'backward-paragraph))

  ;; ocasionally I press C-x C-c by accident, define a more complex
  ;; keybinding to kill emacs
  (global-unset-key (kbd "C-x C-c"))
  (global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)

  ;; On X11 C-z serves no purpose since the wm defines keybindings to
  ;; minimize windows. OTOH is very annoying when pressed by
  ;; accident. In any case C-x C-z is still available.
  (when (display-graphic-p)
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z") 'my/bash-terminal))


  ;; emacs overrides
  ;; (global-set-key (kbd "C-s") #'endless/isearch-symbol-with-prefix)
  (global-set-key (kbd "C-x 2") #'arv/split-windows-bellow)
  (global-set-key (kbd "C-x 3") #'arv/split-windows-right)

  (global-set-key (kbd "C-S-k") #'my/kill-to-indentation-or-beginning-of-line)
  (global-set-key (kbd "C-o") #'arv/open-line-before-and-indent)
  (global-set-key (kbd "C-S-o") #'arv/open-line-after-and-indent)

  (global-set-key (kbd "C-w") #'my/kill-region)

  (global-set-key (kbd "M-D") #'my/dedent-to-point)

  ;; tab-bar
  (when (fboundp 'tab-bar-mode)
    (global-set-key (kbd "C-x t h <left>") #'tab-bar-history-back)
    (global-set-key (kbd "C-x t h p") #'tab-bar-history-back)
    (global-set-key (kbd "C-x t h <right>") #'tab-bar-history-forward)
    (global-set-key (kbd "C-x t h n") #'tab-bar-history-forward))

  ;; let's give a try to swiper
  (global-set-key (kbd "C-s") 'arv/swiper-symbol-with-prefix)
  (global-set-key (kbd "C-S-s") 'isearch-forward)

  (global-set-key (kbd "M-SPC") 'cycle-spacing)
  (global-set-key (kbd "M-z") 'zap-up-to-char)

  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "M-u") 'arv/upcase-word)
  (global-set-key (kbd "M-l") 'arv/downcase-word)
  (global-set-key (kbd "M-;") 'endless/comment-line-or-region)

  (global-set-key (kbd "M-Q") #'my/unfill-paragraph)

  (global-set-key (kbd "s-y") 'arv/duplicate-line-or-region-dwim)
  (global-set-key (kbd "C-M-y") 'arv/duplicate-line-or-region-and-comment-dwim)


  ;; other bindings

  (global-set-key (kbd "<f1>") (lambda () (interactive) (info)))
  (global-set-key (kbd "C-<f1>") (lambda () (interactive) (info "emacs")))
  (global-set-key (kbd "<f7>") 'next-error)
  (global-set-key (kbd "<f8>") 'previous-error)
  (global-set-key (kbd "<f9>") #'my/compile-with-comint-enabled)
  (global-set-key (kbd "C-<f9>") 'compile)

  (global-set-key (kbd "s-g") 'arv/goto-line)
  ;;; es un incordio tener que teclear yes para confirmar
  (global-set-key (kbd "C-<return>") "yes\C-m")

  (global-set-key (kbd "M-%") 'arv/query-replace)
  (global-set-key (kbd "M-w") 'arv/kill-ring-save-word-at-point)

  (global-set-key (kbd "C-<tab>") 'dabbrev-expand)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
                                          ; Una altra alternativa si
                                          ; aquesta no em convenç és
                                          ; buffer-menu

  ;; insert map

  (global-set-key (kbd "C-c i l") 'lorem-ipsum-insert-paragraphs)
  (global-set-key (kbd "C-c i L") 'lorem-ipsum-insert-sentences)
  (global-set-key (kbd "C-c i f") 'figlet)
  (global-set-key (kbd "C-c i F") 'figlet-no-comment)
  (global-set-key (kbd "C-c i u") 'arv/insert-random-uuid)

  ;; jump map

  (global-set-key (kbd "C-c j c") 'avy-goto-char-2)
  (global-set-key (kbd "C-c j e e") #'my/visit-emacs-config)
  (global-set-key (kbd "C-c j e d") #'my/visit-emacs-config-directory)
  (global-set-key (kbd "C-c j e n") #'my/visit-emacs-notes)
  (global-set-key (kbd "C-c j h n") #'diff-hl-next-hunk)
  (global-set-key (kbd "C-c j h p") #'diff-hl-previous-hunk)
  (global-set-key (kbd "C-c j l") 'avy-goto-line)
  (global-set-key (kbd "C-c j s") 'imenu)
  (global-set-key (kbd "C-c j w") 'avy-goto-word-1)

  ;; embrace
  (global-set-key (kbd "C--") 'embrace-commander)

  ;; grin
  (global-set-key (kbd "C-ç") 'arv/grin)

  ;; keybindings per subversion: C-c s
  (global-set-key (kbd "C-c s =") 'svn-file-show-svn-diff)
  (global-set-key (kbd "C-c s l") 'svn-status-show-svn-log)
  (global-set-key (kbd "C-c s s") 'x-my/svn-status)

  ;; keybindings per magit: C-c g
  (global-set-key (kbd "C-c g s") #'magit-status)
  (global-set-key (kbd "C-c g d") #'magit-dispatch)
  (global-set-key (kbd "C-c g f") #'magit-file-dispatch)

  ;; expand-region
  (global-set-key (kbd "C-.") 'er/expand-region)

  ;; multi-line
  (global-set-key (kbd "C-c r m") 'multi-line)

  ;; find-file-in-project
  (global-set-key (kbd "C-x f") 'find-file-in-project)

  ;; org
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c o s") 'org-sort)

  ;; smex
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; toggle map
  (global-set-key (kbd "C-c t c") 'column-number-mode)
  (global-set-key (kbd "C-c t B") 'arv/alternar-mida-font)
  (global-set-key (kbd "C-c t f") 'auto-fill-mode)
  (global-set-key (kbd "C-c t F") 'toggle-fullscreen)
  (global-set-key (kbd "C-c t l") #'my/display-line-numbers-mode)
  (global-set-key (kbd "C-c t L") 'line-number-mode)
  (global-set-key (kbd "C-c t r") 'read-only-mode)

  ;; word-mode
  (global-set-key (kbd"C-,") 'arv/wm-cycle)

  (global-set-key (kbd "C-c b b") 'bjm-comment-box)

#+end_src

** hydras

Pel moment definiré les hidres ací. La idea és utilitzar-les per fer
accessibles comandes relacionades que em resulten útils però utilitzo
tan ocasionalment que no recordo les tecles. Per facilitar-ho es
definiran dins el mapa =C-c h=.

*** outline minor mode

#+begin_src emacs-lisp :tangle yes
  (defhydra hydra-outline (:color pink :hint nil)
    "
  ^Hide^             ^Show^           ^Move
  ^^^^^^------------------------------------------------------
  _q_: sublevels     _a_: all         _u_: up
  _t_: body          _e_: entry       _n_: next visible
  _o_: other         _i_: children    _p_: previous visible
  _c_: entry         _k_: branches    _f_: forward same level
  _l_: leaves        _s_: subtree     _b_: backward same level
  _d_: subtree

  "
    ;; Hide
    ("q" hide-sublevels)    ; Hide everything but the top-level headings
    ("t" hide-body)         ; Hide everything but headings (all body lines)
    ("o" hide-other)        ; Hide other branches
    ("c" hide-entry)        ; Hide this entry's body
    ("l" hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" show-all)          ; Show (expand) everything
    ("e" show-entry)        ; Show this heading's body
    ("i" show-children)     ; Show this heading's immediate child sub-headings
    ("k" show-branches)     ; Show all sub-headings under this heading
    ("s" show-subtree)      ; Show (expand) everything in this heading & below
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("z" nil "leave"))

  (global-set-key (kbd "C-c h o") 'hydra-outline/body)
#+end_src

*** smerge

El paquet =smerge= facilita resoldre conflictes al fer un merge en un
control de revisions.

L'origen d'aquesta hydra és un [[https://irreal.org/blog/?p=5651][post de Irreal]].

#+begin_src emacs-lisp :tangle yes
  (defhydra hydra-smerge
    (:color red :hint nil :pre (smerge-mode 1))
    "
  ^Move^    ^Keep^    ^Diff^    ^Pair^
  ------------------------------------------------------
  _n_ext    _b_ase    _R_efine  _<_: base-mine
  _p_rev    _m_ine    _E_diff   _=_: mine-other
  ^ ^       _o_ther   _C_ombine _>_: base-other
  ^ ^       _a_ll     _r_esolve
  _q_uit    _RET_: current
  "
    ("RET" smerge-keep-current)
    ("C" smerge-combine-with-next)
    ("E" smerge-ediff)
    ("R" smerge-refine)
    ("a" smerge-keep-all)
    ("b" smerge-keep-base)
    ("m" smerge-keep-mine)
    ("n" smerge-next)
    ("o" smerge-keep-other)
    ("p" smerge-prev)
    ("r" smerge-resolve)
    ("<" smerge-diff-base-mine)
    ("=" smerge-diff-mine-other)
    (">" smerge-diff-base-other)
    ("q" nil :color blue))

  (global-set-key (kbd "C-c h s") 'hydra-smerge/body)
#+end_src

* Parxes

Recull de parxes que resolen incompatibilitats etc. La idea és
agrupar-los ací per facilitar localitzar-los i eliminar-los quan
estiguin resolts.

Estaria bé afegir alarmes per comprovar si ja hi ha una solució.

- 20180601: Corregeix [[https://github.com/jorgenschaefer/elpy/issues/1379][un error amb emacs 26.1 i elpy 1.21]]: =M-x= salta
  a un TAG, no utilitza la funcionalitat de =elpy=.

  #+begin_src emacs-lisp :tangle yes
    (with-eval-after-load 'elpy
      (when (and (string= emacs-version "26.1")
                 (string= elpy-version "1.21.0"))
        (defun elpy--xref-backend ()
          "Return the name of the elpy xref backend."
          (if (or (and (not (elpy-rpc--process-buffer-p elpy-rpc--buffer))
                       (elpy-rpc--get-rpc-buffer))
                  elpy-rpc--jedi-available)
              'elpy
            nil))))
  #+end_src

- 20180818: amb emacs 26 el comportament de =hi-lock= no és el mateix
  que amb la versió 25: sembla que només ressalta els elements que hi
  ha al obrir l'arxiu, no els que s'afegeixen posteriorment.

  Veure comentari/solució en el [[target-prog-mode-hook][hook que configura =hi-lock=]].

  El parxe sembla /correcte/ però no estic segur. Investigar-ho amb
  més calma.

* Incubadora

Noves funcionalitats que estic provant. Si em convencen es mouen a
l'apartat /Configuració/.

En aquest apartat l'organització és la inversa, tot va dins una
subsecció per tractar cada nova funcionalitat com un tot. Si
s'accepta, el contingut es distribueix on correspongui.

Allí on tingui sentit, el nom dels elements haurien de començar amb el
prefix =x-arv= per identificar que son experimentals. Probablement amb
la API pública (comandes?) sigui suficient.

** =rotate-windows=

https://github.com/domtronn/emacs/blob/1b0bae5f146c8adb477ac4f7158c063ed45baeea/init/functions.el#L282

Rota els buffers entre les finestres:

#+begin_src emacs-lisp :tangle yes
  (defun x-arv/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond
     ((not (> (count-windows) 1))
      (message "You can't rotate a single window!"))
     (t
      (let  ((i 1)
             (numWindows (count-windows)))
        (while  (< i numWindows)
          (let* (
                 (w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i numWindows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1  b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i))))))))
#+end_src

S'afegeix la comanda al keymap de finestres:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c w r") #'x-arv/rotate-windows)
#+end_src

** =winner-mode=

En general no el veig pràctic però hi ha un cas d'ús en que podria ser
útil: quan s'obre una finestra tipus ajuda, compilació etc. i la vull
fer desapareixer.

#+begin_src emacs-lisp :tangle yes
  (use-package winner
    :commands winner-mode
    :config
    (setq winner-ring-size 50)
    (setq winner-boring-buffers '("*Apropos*"
                                  "*Buffer List*"
                                  "*Compile-Log*"
                                  "*Completions*"
                                  "*grep*"
                                  "*Help*"
                                  "*hera-events*"
                                  "*Occur*"
                                  "*pytest*"
                                  "*svn-diff*"
                                  "*svn-info*"
                                  "*svn-info-output*"
                                  "*svn-log*"
                                  "*svn-log-edit*"
                                  "*svn-property-edit*"
                                  )))
#+end_src

Açò anirà en alguna secció /global/.

#+begin_src emacs-lisp :tangle yes
  (winner-mode t)
#+end_src

** =arv/camelize=

De vegades vull convertir =foo_bar= en =FooBar= i al revés:

#+begin_src emacs-lisp :tangle yes
  (defun x-my/camelize ()
    (interactive)
    (when (looking-at-p "\\sw\\|\\s_")
      (let* ((begin (save-excursion
                      (while (and (not (bobp)) (looking-back "\\sw\\|\\s_"))
                        (backward-word))
                      (point)))
             (end (save-excursion
                    (while (and (not (eobp)) (looking-at "\\sw\\|\\s_"))
                      (forward-word))
                    (point)))
             (text (buffer-substring-no-properties begin end))
             (replacement (with-syntax-table (standard-syntax-table)
                            (if (and (string-match-p "^\\sw+$" text)
                                     (s-mixedcase-p text))
                                ;; CamelCase -> camel_case
                                (mapconcat 'downcase (s-split-words text) "_")
                              ;; camel_case -> CamelCase
                              (mapconcat 'capitalize (s-split-words text) "")
                              ))))
        (save-excursion
          (goto-char begin)
          (delete-region begin end)
          (insert replacement)
          )
        )))
#+end_src

El separador està fixat al codi però pel moment és suficientment bó.
El provaré en =python-mode= per veure que tal. Si resulta útil acabaré
de polir-la.

En certa forma açò és una generalització de =capitalize=:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "M-c") 'x-my/camelize)
#+end_src

** repetició de comandes

Pot resultar pràctic però no acabo de trobar un ús.

- [[https://github.com/myuhe/smartrep.el][smartrep.el]]: support sequential operation which omit prefix key.
  Latest commit f0ff5a6 on 9 May 2015.

  #+begin_src emacs-lisp :tangle no
    (smartrep-define-key
     global-map "M-g"
     '(("n" . next-line)
       ("p" . previous-line)))
  #+end_src

- [[https://github.com/abo-abo/hydra][hydra]]: make Emacs bindings that stick around. Latest commit 62e0f37
  on 27 Feb 2018.

  #+begin_src emacs-lisp :tangle no
    (use-package hydra
      :ensure t
      :config
      (defhydra hydra-zoom (global-map "C-c r")
        "multi-line"
        ("m" multi-line)))
  #+end_src

- configuració de Sacha Chuar: based on
  http://oremacs.com/2015/01/14/repeatable-commands/ . Modified to
  accept =nil= as the first value if you don't want the keymap to run
  a command by default, and to use =kbd= for the keybinding
  definitions.

  #+begin_src emacs-lisp :tangle no
    (defun my/def-rep-command (alist)
      "Return a lambda that calls the first function of ALIST.
    It sets the transient map to all functions of ALIST,
    allowing you to repeat those functions as needed."
      (let ((keymap (make-sparse-keymap))
            (func (cdar alist)))
        (mapc (lambda (x)
                (when x
                  (define-key keymap (kbd (car x)) (cdr x))))
              alist)
        (lambda (arg)
          (interactive "p")
          (when func
            (funcall func arg))
          (set-transient-map keymap t))))
  #+end_src

* Descartat

Funcionalitats experimental que no he acosseguit /interioritzar/.

** Inici de línia

Copiat de
http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/:

#+begin_src emacs-lisp :tangle no
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+end_src

#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "C-a") #'my/smarter-move-beginning-of-line)
#+end_src

** Desactivar tecles del cursor

Porto massa anys utilitzant les tecles del cursor i he desenvolupat
habits per mourem ràpidament amb elles. El canvi em trenca massa el
ritme de treball i resulta frustrant.

L'objectiu és acostumar-me a no utilitzar les tecles del cursor pels
desplaçaments i no haver de moure la ma fora de la /fila principal/.

#+begin_src emacs-lisp :tangle no
  (defun comanda-desactivada ()
    (interactive)
    (let ((visible-bell t))
      (ding)))

  (global-set-key (kbd "<up>") #'comanda-desactivada)
  (global-set-key (kbd "<down>") #'comanda-desactivada)
  (global-set-key (kbd "<left>") #'comanda-desactivada)
  (global-set-key (kbd "<right>") #'comanda-desactivada)
#+end_src

* Per mirar
** =define-compilation-mode=

En alguns mòduls utilitzo buffers de compilació per mostrar el
resultat d'executar una comanda externa (p.e. llistar events i
subscriptors en Hera). Mirar si aquesta macro aporta cap avantatge.

** ressaltar insert/overwrite en la modeline

Ressaltar el mode insert/overwrite en la modeline utiltizant un color
de fons. Actualment /insert/ no es visualitza.

** revisar les [[info:elisp#Coding%20Conventions][info:elisp#Coding Conventions]].
** [[https://melpa.org/#/redshank][redshank]]

Common Lisp Editing Extensions. Específicament m'interesa la part que
permet refactoritzar codi.

** lpy

https://github.com/abo-abo/lpy/blob/master/lpy.el

This is an attempt to implement a variant of `lispy-mode'
(https://github.com/abo-abo/lispy) for Python. Unfortunately, Python
isn't nearly as well-structured as LISP. But Python is ubiquitous, and
the less powerful `lpy-mode' is better than nothing at all.

The basic idea of `lpy-mode' is to increase the editing efficiency by
binding useful navigation, refactoring and evaluation commands to
unprefixed keys, e.g. "j" or "e". But only in certain point positions,
so that you are still able to use uprefixed keys to insert themselves.

Example, here "|" represents the point position:

  print |("2+2=%d" % (2 + 2))

Here, if you press the key "e", the whole line will be evaluated and
"2+2=4" will be printed in the Echo Area. Note that if `lpy-mode' was
off, pressing "e" would instead result in:

  print e|("2+2=%d" % (2 + 2))

So inserting any key isn't actually useful with that point position
and e.g. the "e" can be used for evaluating the current statement.

But, for instance, if you wanted to edit "print" into "printe", you
could do that in a straightforward way, just like you would with
`lpy-mode' off : with "C-b e".
