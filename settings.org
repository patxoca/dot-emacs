#+TITLE: Configuraci贸 d'emacs d'Alexis Roda
#+OPTIONS: toc:4 h:4
#+STARTUP: overview

#+LANGUAGE: ca
#+LATEX_CLASS: informe

#+begin_abstract
Aquesta 茅s la tercera encarnaci贸 de la configuraci贸 d'emacs. Els
objectius que es volen aconsseguir s贸n:

- reduir el temps de crrega.

- prendre el control del caos en que havia esdevingut la segona
  encarnaci贸 i mantindre una baixa entropia.

- automatitzar el desplegament de la configuraci贸 a nous sistemes.

Per貌 la veritat 茅s que 茅s divertit .
#+end_abstract

* Instal路laci贸

En teoria aquesta configuraci贸 hauria de funcionar amb emacs 24.4 o
posterior. En la prctica nom茅s est provada amb emacs 25.2.1 i
25.3.1.

Depend猫ncies: =git=, =make= i =makeinfo= (per instal路lar org). En
ubuntu el paquet /texinfo/ proveeix la comanda =makeinfo=.

#+begin_src sh :tangle no
  mkdir ~/.emacs.d
  cd ~/.emacs.d
  git clone https://github.com/patxoca/dot-emacs.git conf.d
  ln -s conf.d/init.el .
  emacs
#+end_src

#+begin_warning
Actualment 茅s *imprescindible* que el directori on es clona el
repositori sigui =conf.d=. Aquest valor est fixat en algunes parts de
la configuraci贸.
#+end_warning

Al executar /emacs/ sobre una copia de treball neta es generaran els
fitxers =settings.el= i =settings.sh=. El primer cont茅 la configuraci贸
d'/emacs/ i el segon comandes /sh/ per configurar l'entorn. A
continuaci贸 es carregar =settings.el= i per acabar s'executar
=settings.sh=.

El primer arranc pot trigar uns minuts, mentre es descarreguen i
instal路len tots els paquets.

En arrancs posteriors el fitxer =settings.el= s'actualitzar
automticament si s'ha fet cap canvi en aquest document.

El fitxer =settings.sh= mai s'actualitza, cal esborrar-lo i es
generar i executar novament en el seg眉ent arranc.

* Introducci贸

En aquest apartat es dona una visi贸 general de la configuraci贸 i es
detallen algunes guies/recomanacions per ajudar a mantindre la
consist猫ncia i un nivell baix de caos.

** Versi贸 de org

La configuraci贸 dep猫n de que /org/ estigui instal路lat, concretament el
m貌dul /babel/, per extreure (/tangle/) els blocs de codi i generar
l'arxiu de configuraci贸 /real/ (=settings.el=).

Cal que aquesta configuraci贸 /sigui compatible/, almenys pel que
respecta a l'extracci贸 dels blocs de codi, amb la versi贸 de /org/ que
s'utilitzar durant el /bootstrap/. En cas de problemes caldr
actualitzar la versi贸 de /org/.

Durant el primer arranc es descarregar el codi font de /org/ i
s'instal路lar baix la jerarquia de directoris =~/.local=. En els
arrancs subseq眉ents s'utilitzar la nova versi贸.

** Configuraci贸 de paquets

La configuraci贸 dels paquets nom茅s pot incloure modificaci贸 d'elements
definits pel propi paquet. No pot definir tecles globals, no pot
activar cap funcionalitat etc.

La idea 茅s mantindre la localitat separant responsabilitats.

Actualment alguns paquets no ho compleixen.

** Configuraci贸 de modes

Un mode en ess猫ncia 茅s un paquet per貌 en aquest punt encara no he
decidit com organitzar-ho.

Tampoc he decidit si tots paquets han d'anar a la mateixa secci贸 o
poden apareixer en la secci贸 del mode en que s'utilitzen (com est
ara).

** Blocs de codi sh

Un dels objectius 茅s automatitzar la configuraci贸 inicial de l'entorn.
Una de les eines utilitzades per aconsseguir-ho s贸n el blocs de codi
/sh/.

Els bloc /sh/ s'utilitzen en varis contexts:

- s'insereixen en un arxiu per formar un 煤nic script =settings.sh=.
  Aquest script ser executat automticament durant el primer arranc
  d'emacs.

- s'avaluen individualment des del propi document. Per exemple, quan
  s'afegeix un nou paquet a la configuraci贸 i cal instal路lar-lo
  avaluant el bloc de codi.

- en un sistema ja configurat en el que s'ha esborrat l'arxiu
  =settings.sh=. s igual que el punt 1 per貌 l'entorn ja est
  configurat.

Cal tindre cura al escriure aquests blocs de codi per tal de garantir
que funcionin en tots els contexts:

- cal preservar l'entorn d'execuci贸: si es modifica l'entorn
  d'execuci贸, en la modalitat /script/ (contexts 1 i 3), els canvis
  afectaran als blocs que s'executin a continuaci贸.

  En particular cal preservar el directori de treball. El codi pot
  assumir que el directori de treball 茅s =~/.emacs.d/conf.d=. Al
  finalitzar ha de restaurar el directori de treball (utilitzant
  =pushd= i =popd= enlloc de =cd=, per exemple).

- cal que sigui independent: el codi ha de funcionar tant si s'executa
  en modalitat /script/ com en modalitat /bloc/.

- cal que sigui idempotent: el codi pot executar-se m茅s d'una vegada i
  ha de funcionar corretament tant la primera com la resta.

El directori =scripts= cont茅 alguns scripts per simplificar les
tasques m茅s habituals:

- =clone_git=: =clone-git URL= clona un repositori git dins el
  directori =~/.emacs.d/site-lisp=. Si el repositori ja est clonat no
  fa res.

- =compile_package=: =compile_package NOM= compila els fitxers emacs
  lisp del directori =~/.emacs.d/site-lisp/<NOM>= i actualitza
  =~/.emacs.d/site-lisp/loaddefs.el=.

# Cap莽alera de l'arxiu generat a partir dels blocs de codi sh:

#+begin_src sh :tangle yes :exports none
  #!/bin/bash

  cd ~/.emacs.d/conf.d

#+end_src

** Tecles i /keymaps/ personalitzats

Cal definir els keymaps i regles generals per organitzar les
definicions de tecles globals i per modes.

Agrupar les tecles globals tenia sentit quan la configuraci贸 estava
repartida entre varis m貌duls. Al agrupar-la tota en un 煤nic document
=org= potser resulta m茅s clar moure les assignacions de tecles al
corresponent =use-package=. No m'acaba d'agradar.

Pel que fa als keymaps /locals/ hi ha varies opcions:

- en =use-package= 煤nicament es poden modificar tecles ja definides
  pel pr貌pi paquet.

- en =use-package= es pot modificar el /keymap/ local, sempre que el
  comandes siguin locals.

- altres?


#+BEGIN_QUOTE
Reconfiguracio de tecles globalment.  Per evitar conflictes, els
comandos personals els configuro sota el prefix C-c C-a i segueixo el
conveni de que els moduls que escric defineixen el seu propi
"subespai" de tecles (p.e. todo.el utilitza C-c C-a C-r).
#+END_QUOTE

** Directori =site-lisp=

Desenvolupar.

Dos directoris =site-lisp=, que ficar en cadascun, no abusar. Gesti贸.

* Informaci贸 personal

L'adre莽a d'e-mail pot variar depenent del sistema. Per defecte
s'inicialitza a partir de la variable d'entorn =EMAIL=. Probablement
sigui preferible a definir un valor fix en la configuraci贸.

#+begin_src emacs-lisp :tangle yes
  (setq user-full-name "Alexis Roda"
        user-mail-address "alexis.roda.villalonga@gmail.com")
#+end_src

* Inicialitzaci贸
** Funcions auxiliars

Funcions utilitzades en la pr貌pia configuraci贸. Aquestes funcions no
poden dependre de biblioteques de tercers.

*** =arv/bind-keys=

No tinc clar quin /keymap/ es afectat per la clausula =:bind= de
=use-package=, la q眉esti贸 茅s que en alguns casos (configuraci贸 de
=paredit= p.e.) no acaba de funcionar com espero.

La funci贸 =arv/bind-keys= intenta fer menys verbosa la definici贸 de
les tecles quan no queda m茅s remei que fer-ho manualment.

#+begin_src emacs-lisp :tangle yes
  (defun arv/bind-keys (map key-definitions)
    (dolist (item key-definitions)
      (let ((key (car item))
            (command (cadr item)))
        (define-key map (kbd key) command))))
#+end_src

Exemple:

#+begin_src emacs-lisp :tangle no
  (arv/bind-keys some-mode-map
                 '(("C-c f" do-foo)
                   ("C-c b" do-bar)))
#+end_src

*** =arv/generate-lab-faces=

Genera /faces/:

#+begin_src emacs-lisp :tangle yes
  (require 'color)

  (defun arv/generate-lab-faces (name count &optional lightness saturation group-name)
    "Generate `count' faces named `<name>-01-face' to
  `<name>-nn-face' within the group `group-name'.

  `name' and `group-name' must be strings, not symbols.

  ,* `lightness' defaults to 45
  ,* `saturation' defaults to 40
  ,* `group-name' defaults to `<name>-faces'
  "
    (let ((group-name (intern (or group-name (concat name "-faces"))))
          (lightness (or lightness 45))
          (saturation (or saturation 40))
          (format-string (concat name "-%02i-face")))
      (custom-declare-group group-name nil "Autogenerated faces" :group 'faces)
      (cl-loop for i from 1 to count do
               (let* ((angle (* 2 pi (/ i (float count))))
                      (a (* saturation (cos angle)))
                      (b (* saturation (sin angle)))
                      (name (intern (format format-string i))))
                 (custom-declare-face name '((t nil))
                                      "Prova face."
                                      :group group-name)
                 (set-face-attribute
                  name nil
                  :foreground (apply 'color-rgb-to-hex (color-lab-to-srgb lightness a b)))
                 ))))
#+end_src

** Instncies m煤ltiples

Ocasionalment l'entorn en que s'utilitza aquesta configuraci贸 pot ser
lleugerament diferent i pot requerir petites variacions, per exemple
la configuraci贸 de la impressora.

Per suportar aquesta necessitat cada /sistema/ pot tindre una
configuraci贸 diferent. Un sistema s'identifica mitjan莽ant el valor de
la variable d'entorn =EMACS_INSTANCE= o, si no est definida, el nom
de /host/ (sense el domini). El nom del sistema 茅s accessible en la
constant =arv/instance-name=.

#+begin_src emacs-lisp :tangle yes
  (defconst arv/emacs-customize-dir
    (arv/path-concat arv/emacs-conf-dir "customize")
    "Directori on es guarda la personalitzaci贸 de cada sistema.")

  (defconst arv/instance-name
    (or
     (getenv "EMACS_INSTANCE")
     (car (split-string (system-name) "\\.")))
    "Nom del sistema/instncia.")

  (setq custom-file
        (arv/path-concat arv/emacs-customize-dir
                         (concat arv/instance-name ".el")))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

** Repositoris de paquets

#+begin_src emacs-lisp :tangle yes
  (package-initialize)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (setq package-archives
        '(("gnu"          . "https://elpa.gnu.org/packages/")
          ("melpa stable" . "https://melpa-stable.milkbox.net/packages/")
          ("elpy"         . "https://jorgenschaefer.github.io/packages/")
          ;; ("melpa"     . "https://melpa.org/packages/")
          ;; ("org"       . "https://orgmode.org/elpa/")
          ))
#+end_src

Utilitzar =M-x package-refresh-contents= per recarregar la llista de
paquets.

** =use-package=

La variable =use-package-always-pin= permet configurar el repositori
que s'utilitzar quan un paquet no especifica la clausula =:pin=.

Sembla que 茅s bastant estricte: al configurar el valor /melpa stable/
el paquet =rainbow-mode=, 煤nicament disponible en el repositori /gnu/,
ha desaparegut. Ha calgut afegir =:pin gnu= per poder instal路lar-lo.

Mentre no activi el repositori /melpa/ no tinc cap prefer猫ncia
respecte al repositori a utilitzar i preveig problemes si el fixo
(/pin/) globalment.

#+begin_src emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (customize-set-value 'use-package-minimum-reported-time 0.05)
  (customize-set-value 'use-package-verbose t)
  ;; (customize-set-value 'use-package-always-pin "melpa stable")

  (require 'use-package)
#+end_src

** =auto-compile=                                                :desactivat:

No acava de funcionar (provat amb =psvn.el=), probablement per la meva
ignorancia, i ralentitza l'arranc. El desactivo fins que pugar
mirar-m'ho.

https://github.com/emacscollective/auto-compile

Intenta garantir que els arxius compilats (=.elc=) no estan desfasats
repecte del corresponent arxiu font (=.el=).

#+begin_src emacs-lisp :tangle no
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
#+end_src

En cas que l'arxiu =.elc= estigui desfasat carrega el =.el=.

#+begin_src emacs-lisp :tangle yes
  (setq load-prefer-newer t)
#+end_src

** Directori =site-lisp= local

El subdirectori =site-lisp= de la configuraci贸 s'utilitza per guardar
paquets no disponibles en els repositoris (elpa o git).

Tot i que no 茅s habitual, els paquets poden necessitar canvis
espordics per resoldre errors, mantindre la compatibilitat etc. Per
facilitar-me la vida l'arxiu =loaddefs.el= es genera si no existeix o
est desactualitzat respecte als corresponents =.el=.

#+begin_src emacs-lisp :tangle yes
  (let* ((site-lisp-path (expand-file-name (arv/path-concat arv/emacs-conf-dir "site-lisp")))
         (generated-autoload-file (arv/path-concat site-lisp-path "loaddefs.el")))
    (unless (and (file-exists-p generated-autoload-file)
                 (null (cl-remove-if
                        (lambda (x) (or (string= generated-autoload-file x)
                                   (file-newer-than-file-p generated-autoload-file x)))
                        (directory-files site-lisp-path t "\\.el$"))))
      (update-directory-autoloads site-lisp-path))
    (load generated-autoload-file))
#+end_src

Encara que =use-package= permet definir /autoloads/ l'煤s de
=loaddef.el= 茅s recomanable i no penalitza el temps d'arranc de manera
apreciable.

** Biblioteques addicionals

Biblioteques de funcions utilitzades en la configuraci贸

**** =cl-lib=                                                       :builtin:

Implementa funcionalitats de /common lisp/ en emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package cl-lib)
#+end_src

**** =s=

https://github.com/magnars/s.el

Col路lecci贸 de funcions per manipular cadenes.

#+begin_src emacs-lisp :tangle yes
  (use-package s
    :ensure t)
#+end_src

** Compatibilitat

Necessito suportar Emacs 24 per alguns casos en que no vull compilar
una versi贸 m茅s recent. Aquesta secci贸 defineix funcions que faciliten
mantindre la compatibilitat.

Emacs 24 no defineix =string-greaterp= (ni =string>=), curiosament s铆
defineix =string-lessp= i =string<=.

#+begin_src emacs-lisp :tangle yes
  (unless (fboundp 'string-greaterp)
    (defun string-greaterp (a b)
      (not (or (string= a b)
               (string< a b)))))
#+end_src

* Configuraci贸
** Interf铆cie d'usuari

#+begin_src emacs-lisp :tangle yes
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (customize-set-value 'inhibit-startup-screen t)
  ;; cursor blinks forever
  (customize-set-value 'blink-cursor-blinks -1)
#+end_src

** Tema

#+begin_src emacs-lisp :tangle yes
  ;; (load-theme 'tango-dark)

  (use-package doom-themes
    :ensure t)

  ;; doom-one t茅 alguns problemes de visualitzaci贸 en terminals
  ;; (svn-diff resulta il路legible)
  (if (display-graphic-p)
      (load-theme 'doom-one)
    (load-theme 'tango-dark))

  ;; (set-face-attribute 'compilation-error nil
  ;;                     :underline nil
  ;;                     :weight 'normal)
  ;; (set-face-attribute 'cursor  nil
  ;;                     :background "white")
  (set-face-attribute 'default nil
                      :height 100)
  ;; (set-face-attribute 'eldoc-highlight-function-argument nil
  ;;                     :underline t :foreground "green"
  ;;                     :weight 'bold)
#+end_src

En terminals en mode text el color de fons del tema dificulta la
lectura. En eixe cas s'estableix un fons negre. No estic segur
d'haver-ho provat en un /xterm/ amb 256 colors.

#+begin_src emacs-lisp :tangle yes
  (unless (display-graphic-p)
    (set-face-attribute 'default nil
                        :background "black"
                        :foreground "white"))
#+end_src

La forma en que =doom-one= defineix les faces de =diff-hl= t茅
problemes quan el frame es parteix en dos verticalment, en la finestra
de la dreta no es visualitza correctament. Funciona millor si
s'utilitza un color solid enlloc de ressaltar nom茅s la vora.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "diff-hl"
    (set-face-attribute 'diff-hl-change nil :foreground "blue3" :background "#333355")
    (set-face-attribute 'diff-hl-delete nil :foreground "red3" :background "#553333")
    (set-face-attribute 'diff-hl-insert nil :foreground "green4" :background "#335533"))
#+end_src

El color per defecte per la mode-line dificulta diferenciar les
finestres.

#+begin_src emacs-lisp :tangle yes
  (set-face-attribute 'mode-line nil
                      :box nil
                      :background "#00ad50"
                      :foreground "black"
                      :height 0.85)
  (set-face-attribute 'mode-line-highlight nil
                      :box nil
                      :background "orange"
                      :foreground "black")
  (set-face-attribute 'mode-line-inactive nil
                      :inherit 'mode-line
                      :box nil
                      :background "#004f24"
                      :foreground "#999999"
                      :weight 'light)
#+end_src

El color que he triat no em conven莽 per貌 almenys facilita veure el
l铆mit de les finestres. Una altra combinaci贸 utilitza el mateix groc
que utilitzo a i3 per ressaltar la finestra activa, actiu =#ffcc00= i
inactiu =#aa8900=.

** Paquets

Aquesta secci贸 inclou la configuraci贸 de paquets d'us general.

*** =abbrev=                                                        :builtin:

[[info:emacs#Abbrevs][=abbrev=]] 茅s semblant a =yasnippet= per貌 menys potent. Tot i aix貌
resulta 煤til com una mena d'autocorrector.

#+begin_src emacs-lisp :tangle yes
  (use-package abbrev
    :commands abbrev-mode
    :config
    (customize-set-value 'abbrev-file-name
                         (arv/path-concat arv/emacs-conf-dir "shared" "abbrev_defs"))
    (customize-set-value 'save-abbrevs t)
    :diminish "")
#+end_src

La variable =abbrev-mode= 茅s buffer local amb el que no es pot
utilitzar =setq=. Canviant el valor per defecte s'aconsegueix activar
=abbrev= en tots els modes. Si no es vol utilitzar en un mode nom茅s
cal desactivar-lo des del /hook/ amb =(abbrev-mode 0)= o =(setq
abbrev-mode nil)=.

#+begin_src emacs-lisp :tangle yes
  (set-default 'abbrev-mode t)
#+end_src

La documentaci贸 recomana activar =abbrev= amb la funci贸 =abbrev-mode=,
no assignant-li un valor a la variable =abbrev-mode=. Per una altra
banda, activar una funcionalitat sembla que no pertany a aquesta
secci贸 sin贸 a la configuraci贸 d'algun mode
(=fundamental-mode=?). Finalment la funci贸 =abbrev-mode= activa
=abbrev= en el buffer actual, per tant s铆 o s铆 s'ha de moure al
/hook/. Pel moment, mentre la configuraci贸 acaba de prendre forma, es
mant茅 el canvi del valor per defecte de la variable.

*** =ace-window=

https://github.com/abo-abo/ace-window

=ace-window= agilitza la navegaci贸 entre les finestres.

#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :ensure t
    :commands ace-window
    :config
    (if (display-graphic-p)
        (set-face-attribute 'aw-leading-char-face nil
                            :height 4.0
                            :foreground "green")
      (set-face-attribute 'aw-leading-char-face nil
                          :background "white"
                          :foreground "black"))
    (customize-set-value 'aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?帽))
    (customize-set-value 'aw-scope 'frame))
#+end_src

*** =avy=

https://github.com/abo-abo/avy

=avy= agilitza el despla莽ament dins un buffer.

Per defecte =avy= permet saltar a qualsevol finestra dins el frame
actual. No acostumo a saltar entre finestres i tendeix a generar
seq眉猫ncies llargues de fins tres lletres, especialment en pantalles
grans. Per aquest motiu ho restringeixo a salts dins el buffer actiu.

#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :ensure t
    :commands (avy-goto-char-2
               avy-goto-line
               avy-goto-word-1)
    :config
    (setq avy-all-windows nil))
#+end_src

*** =browse-url=                                                    :builtin:

Integraci贸 d'emacs amb un navegador web extern.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'browse-url
    (customize-set-value 'browse-url-browser-function 'browse-url-generic)
    (customize-set-value 'browse-url-generic-program "firefox"))
#+end_src

*** =embrace=

https://github.com/cute-jumper/embrace.el

Facilita manipular (afegir, modificar, eliminar) parelles de
/par猫ntesis/.

#+begin_src emacs-lisp :tangle yes
  (use-package embrace
    :ensure t
    :commands embrace-commander)
#+end_src

*** =calendar=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'calendar
    (customize-set-value 'calendar-day-abbrev-array
                         ["Dg" "Dl" "Dt" "Dc" "Dj" "Dv" "Ds"])
    (customize-set-value 'calendar-day-name-array
                         ["Diumenge" "Dilluns" "Dimarts" "Dimecres"
                          "Dijous" "Divendres" "Dissabte"])
    (customize-set-value 'calendar-month-name-array
                         ["Gener" "Febrer" "Mar莽" "Abril" "Maig"
                          "Juny" "Juliol" "Agost" "Setembre"
                          "Octubre" "Novembre" "Desembre"])
    (customize-set-value 'calendar-week-start-day 1))
#+end_src

*** =company=

https://github.com/company-mode/company-mode

/Complete anything/ 茅s un /framework/ per completar text en emacs. T茅
una arquitectura de /plugins/ i inclou m煤ltiples /backends/.

#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :commands company-mode
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-idle-delay 0.5)
    (setq company-tooltip-align-annotations t)
    (setq company-backends '(company-elisp
                             company-nxml
                             company-css
                             company-files))
    :diminish "")
#+end_src

*** =compilation=                                                   :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package compile
    :commands compile
    :config
    (set-face-attribute 'compilation-error nil
                        :underline nil
                        :weight 'normal)
    (customize-set-value 'compilation-message-face 'default))
#+end_src

*** =dash=

https://github.com/magnars/dash.el

A modern list api for Emacs. No 'cl required.

#+begin_src emacs-lisp :tangle yes
  (use-package dash
    :config (dash-enable-font-lock))
#+end_src

*** =diff-hl-mode=

https://github.com/dgutov/diff-hl

=diff-hl-mode= highlights uncommitted changes on the left side of the
window, allows you to jump between and revert them selectively.

[[https://github.com/syohex/emacs-git-gutter][git-gutter]] 茅s una alternativa en cas que aquest no em convenci, per貌
sembla abandonat.

#+begin_src emacs-lisp :tangle yes
  (use-package diff-hl
    :ensure t
    :commands (diff-hl-margin-mode
               global-diff-hl-mode
               turn-on-diff-hl-mode)
    :config
    (use-package psvn
      :defer t
      :config
      (defadvice svn-status-update-modeline (after svn-update-diff-hl activate)
        (diff-hl-update)))
    (use-package magit
      :defer t
      :config
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+end_src

A莽貌 anir en algun /hook/ o configuraci贸 global:

#+begin_src emacs-lisp :tangle yes
  (global-diff-hl-mode)
  (unless (display-graphic-p)
    (diff-hl-margin-mode))
#+end_src

*** =diminish=

#+begin_src emacs-lisp :tangle yes
  (use-package diminish
    :ensure t
    :commands diminish)
#+end_src

*** =dired=                                                         :builtin:

=dired= per defecte crea un nou buffer al visitar un directori o
fitxer. Personalment prefereixo evitar la proliferaci贸 de buffers.

#+begin_src emacs-lisp :tangle yes
  (defun arv/dired-up-directory ()
    "Visita el directori pare, en el mateix buffer."
    (interactive)
    (find-alternate-file ".."))

  (with-eval-after-load "dired"
    (arv/bind-keys dired-mode-map
                   '(("M-<up>" arv/dired-up-directory)
                     ("^" arv/dired-up-directory)
                     ("C-m" dired-find-alternate-file)))

    (set-face-attribute 'dired-directory nil :foreground "#729fcf"))
#+end_src

*** =ediff=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ediff
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

*** =eldoc=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package eldoc
    :commands eldoc-mode
    :config
    (set-face-attribute 'eldoc-highlight-function-argument nil
                        :underline nil
                        :foreground "yellow"
                        :weight 'bold)
    :diminish "")
#+end_src

*** =electric-pair=                                                 :builtin:

Activa globalment el mode =electric-pair=: al inserir un par猫ntesi
(clau, claudtor etc.) obert automticament s'insereix el corresponent
par猫ntesi tancat.

#+begin_src emacs-lisp :tangle yes
  (electric-pair-mode 1)
#+end_src

*** =engine-mode=

https://github.com/hrs/engine-mode

=engine-mode= facilita integrar dins emacs diferents cercadors web.

#+begin_src emacs-lisp :tangle yes
  (use-package engine-mode
    :ensure t
    :config
    (engine-mode t)

    ;; els engines s'ordenen per keybinding per facilitar identificar
    ;; els conflictes al definir les tecles

    (defengine diec2
      "dlc.iec.cat/results.asp?txtEntrada=%s"
      :keybinding "c"
      :term-transformation-hook (lambda (term) (encode-coding-string term latin-1)))

    (defengine django
      "https://docs.djangoproject.com/search/?q=%s&release=11"
      :keybinding "d")

    (defengine emacs-stack-exchange
      "http://emacs.stackexchange.com/search?q=%s"
      :keybinding "e")

    (defengine google
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g")

    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "G")

    (defengine rfcs
      "http://pretty-rfc.herokuapp.com/search?q=%s"
      :keybinding "r")

    (defengine stack-overflow
      "https://stackoverflow.com/search?q=%s"
      :keybinding "s")

    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
      :keybinding "w")

    (defengine wordreference
      "http://www.wordreference.com/redirect/translation.aspx?w=%s&dict=enes"
      :keybinding "W")

    (defengine z80heaven
      "http://z80-heaven.wikidot.com/instructions-set:%s"
      :keybinding "z"))
#+end_src

*** =expand-region=

https://github.com/magnars/expand-region.el

#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t
    :commands er/expand-region)
#+end_src

*** =f=

https://github.com/rejeep/f.el

Una API moderna per treballar amb arxius i directoris des d'emacs.

Pel tipus de paquet (biblioteca de funcions) s'hauria d'instal路lar com
una depend猫ncia i no directament, per貌 alguns dels meus paquets (no en
elpa) la utilitzen.

#+begin_src emacs-lisp :tangle yes
  (use-package f
    :ensure t)
#+end_src

*** =figlet=                                                         :manual:

https://gist.github.com/digash/392649

Insereix text gran. Requereix la comanda externa =figlet=.

#+begin_src emacs-lisp :tangle yes
  (use-package figlet
    :ensure nil
    :load-path "conf.d/site-lisp"
    :config
    (setq figlet-font-dir "/usr/share/figlet")
    (setq figlet-default-font "standard")
    :commands (figlet
               figlet-no-comment
               banner
               banner-no-comment))
#+end_src

*** =flymake=                                                       :builtin:

Aparentment he estat utilitzant =flycheck=. Vaig a donar-li una
oportunitat a =flymake=. En les comparatives que he llegit deixen
millor a =flycheck= per貌 afegeix una depend猫ncia externa.

#+begin_src emacs-lisp :tangle yes
  (use-package flymake
    :commands flymake-mode
    :config
    (set-face-attribute 'flymake-errline nil
                        :underline nil
                        :background "Firebrick4"))
#+end_src

*** =font-lock=                                                     :builtin:

#+begin_src emacs-lisp :tangle yes
  (global-font-lock-mode t)
  (customize-set-value 'font-lock-maximum-decoration t)
#+end_src

No tinc clar si activar-lo ac铆 茅s preferible a fer-ho en algun hook.

*** =grin=

https://bitbucket.org/dariusp686/emacs-grin/src

=grin= 茅s una utilitat tipus =grep=, escrita en python. Es pot
descarregar des de https://pypi.python.org/pypi/grin.

#+begin_src emacs-lisp :tangle yes
  (use-package grin
    :ensure t
    :commands grin)
#+end_src

Al estar escrita en python pot donar problemes si s'executa dins un
directori amb codi python que cont茅 m貌duls que poden interferir amb
els =import= que fa =grin=. Ho vaig detectar, crec recordar, intentant
executar-lo dins el =site-packages= d'un /virtualenv/, no recordo els
detalls concrets.

=ag=[[[https://github.com/ggreer/the_silver_searcher][enlla莽]]] 茅s una alternativa semblant, escrita en C, per tant m茅s
rpida i que no t茅 conflictes amb arbres de codi python.

El que em tira enrere per canviar 茅s la interf铆cie del m貌dul
=ag.el=[[[https://github.com/Wilfred/ag.el][enlla莽]]], defineix moltes comandes per fer diferents tipus de
cerques (text en directori, text en directori nom茅s en certs arxius,
regex en directori, text en projecte, text en certs arxius del
projecte, regex en projecte ...). Massa comandes/combinacions de
tecles que recordar i poca flexibilitat. M'agrada m茅s l'enfoc de
=grin.el=, una 煤nica comanda que demana el directori i la l铆nia de
comandes.

El problema amb =grin= 茅s anecd貌tic en el meu cas d'us i no hi ha
urg猫ncia en fer el canvi. A莽貌 茅s m茅s un recordatori.

*** =hi-lock=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package hi-lock
    :diminish ""
    :config
    (defface arv/hi-green
      '((((min-colors 88)) (:weight bold :foreground "black" :background "light green"))
        (t (:weight bold :background "green")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-orange
      '((((min-colors 88)) (:weight bold :foreground "black" :background "orange"))
        (t (:weight bold :background "orange")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-red
      '((((min-colors 88)) (:weight bold :background "red1" :foreground "white"))
        (t (:weight bold :background "red" :foreground "white")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces))
#+end_src

*** =highlight-indentation=

https://github.com/antonj/Highlight-Indentation-for-Emacs

=highlight-indentation= mostra /regles/ verticals per facilitar
alinear el text. No l'utilitzo per貌 qui sap si alguna vegada pot ser
煤til.

#+begin_src emacs-lisp :tangle yes
  (use-package highlight-indentation
    :ensure t
    :commands (highlight-indentation-mode
               highlight-indentation-current-column-mode))
#+end_src

*** =hippie-expand=                                      :builtin:desactivat:

Exemple de funci贸 que proveeix candidats a =hippie-expand= a partir
dels /TAGS/.

#+begin_src emacs-lisp :tangle no
  (defun try-expand-tags (old)
    "Funcio compatile amb `hippie-expand' per expandir tags.

  Argument OLD nil la primera vegada que es crida, t les seguents."
    ;; @NOTE: alex 2014-08-02 16:30:17: Aquesta funci贸 s'utilitza amb
    ;; `make-hippie-expand-function', en eixe punt el m貌dul
    ;; `hippie-expand' estar carregat, motiu pel que no es requereix el
    ;; m貌dul ni es defineix cap autoload. De la mateixa forma la funci贸
    ;; `tags-complete-tag' es carrega al inicialitzar emacs (m貌dul
    ;; `compat'), amb lo que est disponible.
    (unless old
      (let ((start-point (save-excursion
                           (backward-word 1)
                           (point))))
        (he-init-string start-point (point))
        (setq he-expand-list (sort
                              (tags-complete-tag he-search-string nil t)
                              'string-lessp))))
    (while (and he-expand-list
                (he-string-member (car he-expand-list) he-tried-table))
      (pop he-expand-list))
    (if (null he-expand-list)
        (progn
          (when old (he-reset-string))
          ())
      (he-substitute-string (car he-expand-list))
      (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
      (pop he-expand-list)
      t))
#+end_src

*** =hl-line=                                                       :builtin:

Ressalta la l铆nia on es troba el cursor actualment.

#+begin_src emacs-lisp :tangle yes
  (use-package hl-line
    :commands global-hl-line-mode
    :config
    (if (display-graphic-p)
        (set-face-attribute 'hl-line nil
                            :foreground "white"
                            :background "black")
      (set-face-attribute 'hl-line nil
                          :foreground "black"
                          :background "yellow")))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (global-hl-line-mode t)
#+end_src

Activar el mode probablement pertany a algun hook, o, al ser global, a
la configuraci贸 de un mode.

La definici贸 de colors probablement pertany a la configuraci贸 del
tema.

*** =hydra=

https://github.com/abo-abo/hydra

#+begin_src emacs-lisp :tangle yes
  (use-package hydra
    :ensure t
    :defer nil)
#+end_src


*** =ibuffer=                                                       :builtin:

=ibuffer= resulta especialment 煤til quan cal gestionar molts buffers.

Fins ara he estat utilitzant =ebuff-menu= i, al ser /el猫ctric/,
resulta una mica m茅s gil si hi ha pocs buffers.

Encara falta provar =buffer-menu=.

#+begin_src emacs-lisp :tangle yes
  (use-package ibuffer
    :commands ibuffer)
#+end_src

*** =ido=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :commands (ido-mode ido-everywhere)
    :config
    (set-face-attribute 'ido-first-match nil
                        :background "pale green"
                        :foreground "black")

    ;; Inhibit switching to other directory when no matches are found in
    ;; the current directory.
    (customize-set-value 'ido-auto-merge-work-directories-length -1)
    (customize-set-value 'ido-enable-flex-matching t)
    (customize-set-value 'ido-ignore-directories
                         '("\\`CVS/" "\\`\\.\\./" "\\`\\./" "\\`\\.svn/" "\\`\\.ropeproject/"))
    (customize-set-value 'ido-max-work-directory-list 10)
    (setq ido-save-directory-list-file "~/.emacs.d/ido.last")

    ;; Mostra el buffer en la finestra activa encara que sigui visible
    ;; en un altre frame.
    (setq ido-default-buffer-method 'select-window))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (ido-mode 1)
  (ido-everywhere 1)
#+end_src

Personalment prefereixo que els elements es mostrin verticalment
enlloc d'horitzontalment:

#+begin_src emacs-lisp :tangle yes
  (use-package ido-vertical-mode
    :ensure t
    :after ido
    :config
    (ido-vertical-mode 1)
    (add-hook 'ido-setup-hook
              (lambda ()
                ;; more intuitive keybinds for vertical-mode
                (arv/bind-keys ido-completion-map
                               '(("<down>" ido-next-match)
                                 ("<up>" ido-prev-match)
                                 ("<left>" ido-prev-match-dir)
                                 ("<right>" ido-next-match-dir)
                                 ("M-<left>" ido-prev-work-directory)
                                 ("M-<right>" ido-next-work-directory))))))
#+end_src

Tamb茅 m'agrada utilitzar =ido= all铆 on sigui possible, malauradament
~(ido-everywhere 1)~ 茅s limitat i nom茅s l'activa per seleccionar
buffers i arxius.

#+begin_src emacs-lisp :tangle yes
  (use-package ido-completing-read+
    :ensure t
    :after ido
    :config
    (ido-ubiquitous-mode 1))
#+end_src

*** =lorem-ipsum=                                                    :manual:

https://github.com/jschaf/emacs-lorem-ipsum

No est disponible als repositoris estable. No 茅s un tipus de codi que
hagi de canviar/millorar en el futur aix铆 que es clona:

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/jschaf/emacs-lorem-ipsum.git
  ./scripts/compile_package emacs-lorem-ipsum
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package lorem-ipsum
    :ensure nil
    :load-path "site-lisp/emacs-lorem-ipsum"
    :commands (lorem-ipsum-insert-paragraphs
               lorem-ipsum-insert-sentences
               lorem-ipsum-insert-list))
#+end_src

*** =magit=

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands magit-status)
#+end_src

*** =modeline=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; oculta el n煤mero de la columna
  (column-number-mode 0)
  ;; (line-number-mode 0)

  ;; no cal desaprofitar espai quan el gestor de finestres/escriptori ja
  ;; mostra la data
  (display-time-mode 0)
#+end_src

*** =mouse=                                                         :builtin:

Prefereixo que al clicar en la roda del ratol铆 s'enganxi en la posici贸
del /point/ enlloc de la del punter del ratol铆, d贸na m茅s control.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'mouse
    (setq mouse-yank-at-point t)

    (setq mouse-buffer-menu-maxlen 25)
    (setq mouse-buffer-menu-mode-mult 10))
#+end_src

*** =multi-line=

https://github.com/IvanMalison/multi-line

=multi-line= facilita formatar /llistes l'elements/ (parmetres d'una
funci贸, elements d'una llista etc.) en una o vries l铆nies, emprant
diferents formats.

#+begin_src emacs-lisp :tangle yes
  (use-package multi-line
    :ensure t
    :commands multi-line)
#+end_src

*** =mwheel=                                                        :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; aparentment `mouse-wheel-mode' s'activa per defecte
  (mouse-wheel-mode t)

  ;; quantitat a moure quan es gira la roda en combinaci贸 amb una tecla
  ;; modificadora
  (setq mouse-wheel-scroll-amount
        '(5
          ((shift) . 1)
          ((control) . nil)))

  (setq mouse-wheel-follow-mouse t)
#+end_src

*** =outline=                                            :builtin:desactivat:

Codi tret de:

http://www.emacswiki.org/emacs/OutlineMinorMode

Defineix funcions que fan l'us del =outline-mode= m茅s intuitiu
(semblant al comportament de l'explorer de windows) i les assigna a
combinacions de tecles m茅s accesibles.

#+begin_src emacs-lisp :tangle no
  (defun arv/outline-body-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (and (not (eobp))
           (progn (forward-char 1)
                  (not (outline-on-heading-p))))))

  (defun arv/outline-body-visible-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-subheadings-p ()
    (save-excursion
      (outline-back-to-heading)
      (let ((level (funcall outline-level)))
        (outline-next-heading)
        (and (not (eobp))
             (< level (funcall outline-level))))))

  (defun arv/outline-subheadings-visible-p ()
    (interactive)
    (save-excursion
      (outline-next-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-hide-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-body-p)
                  (arv/outline-body-visible-p))
             (hide-entry)
             (hide-leaves))
            (t
             (hide-subtree)))))

  (defun arv/outline-show-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-subheadings-p)
                  (not (arv/outline-subheadings-visible-p)))
             (show-children))
            ((and (not (arv/outline-subheadings-p))
                  (not (arv/outline-body-visible-p)))
             (show-subtree))
            ((and (arv/outline-body-p)
                  (not (arv/outline-body-visible-p)))
             (show-entry))
            (t
             (show-subtree)))))

  (with-eval-after-load "outline"
    (arv/bind-keys outline-mode-map
                   '(("S-<left>" arv/outline-hide-more)
                     ("S-<right>" arv/outline-show-more)
                     ("S-<up>" outline-previous-visible-heading)
                     ("S-<down>" outline-next-visible-heading)))

    (arv/bind-keys outline-minor-mode-map
                   '(("S-<left>" arv/outline-hide-more)
                     ("S-<right>" arv/outline-show-more)
                     ("S-<up>" outline-previous-visible-heading)
                     ("S-<down>" outline-next-visible-heading))
                   ;; prova per moure blocs, no acava de funcionar
                   ;;(define-key map (kbd "S-s-<up>") 'outline-move-subtree-up)
                   ;;(define-key map (kbd "S-s-<down>") 'outline-move-subtree-down)
      ))
#+end_src

*** =projectile=                                                 :desactivat:

https://github.com/bbatsov/projectile

Gesti贸 de /projectes/ (en un sentit molt relaxat).

Vaig comen莽ar a utilitzar-lo per facilitar la navegaci贸 dins el codi
font de /Hera/ per貌 vaig acabar implementant una soluci贸 espec铆fica.

Pel moment es deixa desactivat, a l'espera de veure si trobo a faltar
cap funcionalitat.

#+begin_src emacs-lisp :tangle no
  (use-package projectile
    :ensure t
    :commands projectile-global-mode
    :config

    ;; native indexing is slower but allows for file/directory filtering
    (setq projectile-indexing-method 'native)

    ;; enable caching in order to speedup native indexing
    (setq projectile-enable-caching t)

    (setq projectile-mode-line '(:eval (format " PRJ[%s]" (projectile-project-name))))

    (projectile-global-mode))
#+end_src

*** =psvn=                                                           :manual:

http://www.xsteve.at/prg/emacs/psvn.el

Integraci贸 amb el control de versions /subversion/.

Aquesta comanda desf un /hunk/. Es pot obtindre el mateix efecte amb
la comanda =diff-apply-hunk= per貌 demana confirmaci贸 sobre si es vol
aplicar el /hunk/ a la inversa.

#+begin_src emacs-lisp :tangle yes
  (defun my/diff-undo-hunk ()
    "Desf un hunk."
    (interactive)
    (diff-apply-hunk t))
#+end_src

Configura el mode.

#+begin_src emacs-lisp :tangle yes
  (use-package psvn
    :load-path "conf.d/site-lisp"
    :commands (svn-status
               svn-file-show-svn-diff
               svn-status-show-svn-log)
    :config
    (customize-set-value 'svn-status-default-log-arguments
                         '("-v" "--stop-on-copy"))
    (customize-set-value 'svn-status-verbose t)
    (customize-set-value 'svn-status-hide-unmodified t)
    (add-hook 'svn-status-diff-mode-hook
              #'(lambda () (diff-auto-refine-mode t)))
    (arv/bind-keys
     svn-status-diff-mode-map
     '(("a" diff-apply-hunk)
       ("u" my/diff-undo-hunk))))
#+end_src

*** =rainbow=

https://elpa.gnu.org/packages/rainbow-mode.html

Afegeix un fons de color als noms dels colors.

#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode
    :diminish "")
#+end_src

*** =smex=

https://github.com/nonsequitur/smex

=smex= 茅s una versi贸 millorada de =M-x=. Basada en /ido/ facilita
l'acc茅s a les comandes utilitzades recentment i a les m茅s freq眉ents.

#+begin_src emacs-lisp :tangle yes
  (use-package smex
    :ensure t
    :commands smex
    :config
    (setq smex-save-file (arv/path-concat user-emacs-directory "smex-items"))
    (smex-initialize))
#+end_src

*** =sql=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package sql-mode
    :commands sql-mode
    :config
    (add-hook 'sql-mode-hook
              (lambda ()
                (set-variable 'show-trailing-whitespace t)
                (sql-highlight-postgres-keywords))))
#+end_src

*** =subword=, =superword=                                          :builtin:

#+begin_src emacs-lisp :tangle yes
  (defun arv/wm-cycle ()
    "Cycle word-mode:
  subword-mode -> superword-mode -> nothing -> subword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (superword-mode
      (subword-mode 0)
      (superword-mode 0))
     (t
      (subword-mode 1)
      (superword-mode 0))))

  (defun arv/wm-cycle-2 ()
    "Cycle word-mode:
  subword-mode <-> superword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (t
      (subword-mode 1)
      (superword-mode 0))))
#+end_src

*** =swiper=

#+begin_src emacs-lisp :tangle yes
  (use-package swiper
    :ensure t
    :commands swiper)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/swiper-symbol-with-prefix (p)
    "Like swiper, unless prefix argument is provided.
  With a prefix argument P, isearch for the symbol at point."
    (interactive "P")
    (let ((current-prefix-arg nil))
      (if p (swiper (thing-at-point 'symbol t))
        (swiper))))
#+end_src

*** =uniquify=                                                      :builtin:

=uniquify= 茅s responsable d'assignar noms 煤nics als buffers quan hi ha
conflictes. Suporta diferents estils.

#+begin_src emacs-lisp :tangle yes
  (use-package uniquify
    :defer t
    :config
    (customize-set-value 'uniquify-buffer-name-style 'reverse))
#+end_src

*** =which-key=

https://github.com/justbur/emacs-which-key

=which-key= mostra les combinacions de tecles disponibles.

#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :commands which-key-mode
    :config
    (setq which-key-idle-delay 0.75)
    (setq which-key-sort-order 'which-key-description-order)
    (which-key-setup-side-window-right)
    :diminish "")
#+end_src

#+begin_src emacs-lisp :tangle yes
  (which-key-mode 1)
#+end_src

*** =workgroups=                                                 :desactivat:

Permet definir /workgroups/ (distribucions de finestres emacs) i
alternar entre ells.

Mai vaig aconseguir integrar-lo en el meu workflow i el paquet ja no
茅s mantingut. Es mant茅 com un recordatori.

#+begin_src emacs-lisp :tangle no
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))
(workgroups-mode 1)
(setq wg-morph-on nil)

(set-face-attribute 'wg-mode-line-face nil
                    :foreground "black"
                    :background "#2fadff")
#+end_src

*** =xt-mouse=                                           :builtin:desactivat:

Afegeix suport m铆nim pel ratol铆 quan emacs s'executa en una terminal:

#+begin_src emacs-lisp :tangle no
  (unless (display-graphic-p)
    (use-package xt-mouse
      :config (xterm-mouse-mode)))
#+end_src

20190629: no aprofito la funcionalitat i en contrapartida perdo la
possibilitat que oferix X de seleccionar amb el ratoli.

*** =yasnippet=

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :config
    (add-to-list 'yas-snippet-dirs
                 (arv/path-concat arv/emacs-conf-dir "shared" "yasnippet"))
    (setq yas-prompt-functions '(yas-ido-prompt yas-x-prompt yas-completing-prompt))
    (add-to-list 'auto-mode-alist '("\\.yas$" . snippet-mode))
    :diminish yas-minor-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
    (yas-global-mode 1)
#+end_src

En la [[https://github.com/joaotavora/yasnippet/blob/5a29fe67d70de3749e30ebb37206395b4d1a51a8/NEWS][release 0.13]] es van eliminar tots els snippets del paquet, s'han
mogut al paquet =yasnippet-snippets=.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :ensure t)
#+end_src

** Modes

Aquesta secci贸 inclou la configuraci贸 dels /modes/ que utilitzo
habitualment.

L'estructura utilitzada per documentar/configurar els modes 茅s /work
in progress/ per貌 l'organitzaci贸 seg眉ent sembla raonable:

#+begin_src org :tangle no
  ,*** mode
  ,**** =paquet 1=
  ,**** =paquet 2=
  ...
  ,**** =paquet N=
  ,**** Funcions d'utilitat
  ,**** Combinacions de tecles
  ,**** /Hook/
#+end_src

Tot i que =use-package= permet definir les tecles emprant la directiva
=:bind= trobo m茅s prctic agrupar totes les definions en una
secci贸. Un avantatge de =:bind= 茅s que defineix automticament
=autoloads= pels simbols que no son funcions (segons =fboundp=).

*** apropos

#+begin_src emacs-lisp :tangle yes
  (use-package apropos
    :commands (apropos-comand
               apropos-documentation)
    :config
    (set-face-attribute 'apropos-symbol nil
                        :foreground "chartreuse"
                        :bold t)
    (set-face-attribute 'apropos-keybinding nil
                        :foreground "medium spring green"
                        ))
#+end_src

*** C
**** gtk-doc

https://github.com/federicomenaquintero/gnome-emacs-utils

Funcions variades per facilitar el desenvolupament de/amb gnome.
M'interessa la funcionalitat per generar comentaris de les funcions.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/federicomenaquintero/gnome-emacs-utils
  ./scripts/compile_package gnome-emacs-utils
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package gtk-doc
    :ensure nil
    :load-path "site-lisp/gnome-emacs-utils"
    :commands (gtk-doc-insert
               gtk-doc-insert-section))
#+end_src

**** cc-mode

Configuraci贸 del c-mode.

#+begin_src emacs-lisp :tangle yes
  (use-package cc-mode
    :commands (c-mode c++-mode)
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (setq indent-tabs-mode nil)
                (setq c-default-style "k&r")
                (setq c-basic-offset 4)
                ;; company-mode
                (company-mode t))))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "cc-mode"
    (arv/bind-keys
     c-mode-map
     '(("C-c m d f" gtk-doc-insert)
       ("C-c m d s" gtk-doc-insert-section)
       )))
#+end_src

*** css

**** Funcions d'utilitat

M'agrada que quan es guarda un arxiu =.scss= es recompili
automticament el codi CSS. Per fer-ho servir cal definir unes
variables (veure codi).

Per definir variables per projecte es poden utilitzar variables locals
de directori.

#+begin_src emacs-lisp :tangle yes
  (defvar sass-project-root nil
    "Arrel del projecte.")
  (defvar sass-project-main-file nil
    "Arxius arrel del projecte, relatiu a `sass-project-root'.")
  (defvar sass-project-output-file nil
    "Arxiu de sortida, relatiu a `sass-project-root'.")
  (defvar sass-command "sass --style compressed %s %d"
    "Comanda per executar sass.

  Permet interpolar alguns elements:

  - %r: directori arrel del projecte
  - %s: ruta absoluta de l'arxiu origen (source)
  - %d: ruta absoluta de l'arxiu de sortida (dest)
  ")

  (require 'format-spec)

  (defun arv/sass-compile-on-save ()
    "Compila el projecte SASS al guardar.

  Quan un arxiu amb extensi贸 '.scss' es guarda dins el directori
  `sass-project-root' o un subdirectori s'executa la comanda
  `sass-command' substituint:

  - %r: `sass-project-root'
  - %s: `sass-project-main-file'
  - %d: `sass-project-output-file'."
    (if (and (string-match-p "\.scss$" (buffer-file-name))
             (s-starts-with-p sass-project-root (buffer-file-name)))
        (compilation-start
         (format-spec
          sass-command
          (list
           (cons ?r sass-project-root)
           (cons ?s (arv/path-concat sass-project-root sass-project-main-file))
           (cons ?d (arv/path-concat sass-project-root sass-project-output-file))))
         t
         (lambda (mode) "*sass*"))))
#+end_src

**** Combinacions de tecles
**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'css-mode-hook
            (lambda ()
              (rainbow-mode t)))
  (add-hook 'after-save-hook 'arv/sass-compile-on-save)
#+end_src

*** emacs-lisp, ielm
**** =elisp-slime-nav=

https://github.com/purcell/elisp-slime-nav

#+begin_src emacs-lisp :tangle yes
  (use-package elisp-slime-nav
    :ensure t
    :commands elisp-slime-nav-mode
    :diminish "")
#+end_src

**** =macrostep=

=macrostep= permet expandir macros /inline/.

#+begin_src emacs-lisp :tangle yes
  (use-package macrostep
    :ensure t
    :commands macrostep-mode)
#+end_src

**** =package-lint=

https://github.com/purcell/package-lint

This library provides a linter for the metadata in Emacs Lisp files
which are intended to be packages.

#+begin_src emacs-lisp :tangle yes
  (use-package package-lint
    :ensure t
    :commands (package-lint-current-buffer
               package-lint-buffer))
#+end_src

**** =paredit=

#+begin_src emacs-lisp :tangle yes
  (use-package paredit
    :ensure t
    :commands paredit-mode
    :diminish "")
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/scratch ()
    "Activa el buffer *scratch*, creant-lo si 茅s necessari."
    (interactive)
    (let ((current-mode major-mode))
      (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (if (memq current-mode lisp-mode)
          (funcall current-mode))))

  (defun arv/emacs-lisp-insert-grave ()
    "Inserts `' within a string or just ` otherwise."
    (interactive)
    (if (nth 8 (syntax-ppss))
        (progn
          (insert "`'")
          (backward-char 1))
      (insert "`")))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "lisp-mode"
    (arv/bind-keys emacs-lisp-mode-map
                   '(("s-SPC" company-complete)
                     ("<f9>" (lambda () (interactive) (ert t)))
                     ("M-<f1>" (lambda () (interactive) (info "elisp")))
                     ("`" arv/emacs-lisp-insert-grave)
                     ("s-c" arv/startup-byte-recompile)
                     ("C-c m b" eval-buffer)
                     ("C-c m c" cancel-debug-on-entry)
                     ("C-c m d" debug-on-entry)
                     ("C-c m e" toggle-debug-on-error)
                     ("C-c m f" find-function)
                     ("C-c m F" emacs-lisp-byte-compile-and-load)
                     ("C-c m l" find-library)
                     ("C-c m m" macrostep-mode)
                     ("C-c m p" paredit-mode)
                     ("C-c m r" eval-region)
                     ("C-c m s" arv/scratch)
                     ("C-c m v" find-variable)
                     ("C-c m ?" elisp-slime-nav-describe-elisp-thing-at-point)
                     ("C-h e V" apropos-value)
                     ("C-c m z" byte-recompile-directory)
                     ("C-c C-z" ielm)))

    (let ((keywords '(("\\<ert-deftest\\>" . font-lock-keyword-face)
                      ("\\<should\\>" . font-lock-keyword-face)
                      ("\\<should-not\\>" . font-lock-keyword-face))))
      (font-lock-add-keywords 'emacs-lisp-mode keywords)
      (font-lock-add-keywords 'lisp-interaction-mode keywords)))

  (with-eval-after-load "paredit"
    (arv/bind-keys paredit-mode-map
                   '(("C-<right>" nil)
                     ("C-<left>" nil)
                     ("M-<right>" paredit-forward-slurp-sexp)
                     ("M-<left>" paredit-forward-barf-sexp))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (paredit-mode 1)
              (elisp-slime-nav-mode 1)
              (prettify-symbols-mode 1)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-hook 'ielm-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (elisp-slime-nav-mode 1)))
#+end_src
*** go                                                      :desactivat:brut:

Aquest mode actualment no l'utilitzo. S'inclou la configuraci贸,
desactivada, per accelerar la migraci贸.

#+begin_src emacs-lisp :tangle no
  (require 'company)
  (require 'company-go)
  (require 'go-eldoc)
  (require 'go-mode)
  (require 'projectile)

  (defun arv/gobuild ()
    "Jumps to project root and runs 'go build -v'."
    (interactive)
    (compile (format "cd %s && go build -v" (projectile-project-root)) 't))

  (defun arv/goinstall ()
    "runs 'go install' on current package."
    (interactive)
    (compile (format "cd %s && go install" (file-name-directory (buffer-file-name))) 't))

  (defun arv/gotest ()
    "runs 'go test' on current package."
    (interactive)
    (compile (format "cd %s && go test" (file-name-directory (buffer-file-name))) 't))

  (eval-after-load "go-mode"
    '(progn
       (setq gofmt-command "goimports")
       ;; flymake
       (require 'flymake-go)
       ;; documentation
       (setq godoc-at-point-function 'godoc-gogetdoc)
       (define-key go-mode-map (kbd "C-c m d") 'godoc-at-point)
       ;; jumping around
       (define-key go-mode-map (kbd "C-c j a") 'go-goto-arguments)
       (define-key go-mode-map (kbd "C-c j d") 'go-goto-docstring)
       (define-key go-mode-map (kbd "C-c j i") 'go-goto-imports)
       (define-key go-mode-map (kbd "C-c j m") 'go-goto-method-receiver)
       (define-key go-mode-map (kbd "C-c j n") 'go-goto-function-name)
       (define-key go-mode-map (kbd "C-c j r") 'go-goto-return-values)
       (define-key go-mode-map (kbd "M-.") 'godef-jump)
       ;; compilation
       (define-key go-mode-map (kbd "<f9>") 'arv/gobuild)
       (define-key go-mode-map (kbd "C-<f9>") 'arv/gotest)
       (define-key go-mode-map (kbd "M-<f9>") 'arv/goinstall)
       ))

  (add-hook 'go-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'gofmt-before-save)
              ;; autocompletion. Depends on external command gocode
              (set (make-local-variable 'company-backends) '(company-go))
              (company-mode)
              ;; eldoc
              (go-eldoc-setup)))
#+end_src

*** html
**** =emmet= (anteriorment =zencoding=)

https://github.com/smihica/emmet-mode

=emmet= facilita generar html (xml) a partir d'una especificaci贸 en un
format compacte. Tamb茅 suporta CSS per貌 resulta massa criptic i pel
meu cas d'us no aporta res.

#+begin_src emacs-lisp :tangle yes
  (use-package emmet-mode
    :ensure t
    :commands emmet-mode
    :config
    (setq emmet-indentation 2)
    (define-key emmet-mode-keymap (kbd "C-j") nil)
    (set-face-attribute 'emmet-preview-input nil
                        :box nil)
    ;; No aconsegueixo redefinir el color, utilitza el de hightlight
    ;; (del que hereta). Aquesta face 煤nicament s'utilitza, breument,
    ;; quan es confirma el resultat, en un flash.
    (set-face-attribute 'emmet-preview-output nil
                        :background "green"
                        :box nil)
    :diminish "")
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'html-mode-hook
            (lambda ()
              (rainbow-mode t)
              (emmet-mode t)))
#+end_src

*** javascript
**** =tern=

http://ternjs.net/

Integra la comanda externa =tern= dins emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package tern
    :ensure t
    :commands tern-mode
    :diminish "")
#+end_src

**** =company-tern=

https://github.com/proofit404/company-tern

Implementa un /backend/ per =company-mode= basat en =tern=.

#+begin_src emacs-lisp :tangle no
  (use-package company-tern
    :ensure t
    :after tern
    :config
    (add-to-list 'company-backends 'company-tern))
#+end_src

**** =js2-refactor=

https://github.com/magnars/js2-refactor.el

Refactoritzaci贸 de codi js.

#+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :ensure t
    :after js2-mode
    :commands js2-refactor-mode
    :diminish "")
#+end_src

**** =js2-mode=

#+begin_src emacs-lisp :tangle yes
  (use-package js2-mode
    :ensure t
    :commands js2-mode)

  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

**** =xref-js2=                                                  :desactivat:

https://github.com/NicolasPetton/xref-js2

Aquest apareix a una recepta que vaig trobar que explica com
configurar un entorn javascript. Depen de la comanda =ag=. Mai l'he
utilitzat. =tern= sembla prometedor.

#+begin_src emacs-lisp :tangle no
  (use-package xref-js2
    :ensure t)
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'js2-mode
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    (js2r-add-keybindings-with-prefix "C-c m r")
    (add-hook 'js2-mode-hook (lambda ()
                               (js2-imenu-extras-mode)
                               (js2-refactor-mode)
                               (tern-mode)
                               (company-mode))))
#+end_src

*** org
**** Instal路laci贸

Al instal路lar /org/ des d'ELPA el codi compilat m'ha donat problemes
([[https://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks][enlla莽]]) aix铆 que he optat per instal路lar-lo directament des del codi
font ([[https://orgmode.org/worg/dev/org-build-system.html][instruccions]]).

En =init.el= es modifica el valor de =load-path= per garantir que es
carrega la versi贸 correcta de /org/ abans de processar aquesta
configuraci贸.

Per instal路lar:

#+begin_src sh :tangle yes
  [ -d ~/.local/src ] || mkdir -p ~/.local/src
  pushd ~/.local/src
  if [ ! -d org-mode ] ; then
      echo "Descarregant i instal路lant 'org-mode'."
      git clone --quiet https://code.orgmode.org/bzg/org-mode.git
      cd org-mode
      make local.mk
      sed -i -r -e 's!^prefix\s+=.*$!prefix = $(HOME)/.local/share!' local.mk
      make
      make install
  fi
  popd
#+end_src

Per actualitzar la versi贸 instal路lada:

#+begin_src sh :tangle no
  cd ~/.local/src/org-mode
  git pull
  make
  make install
#+end_src

**** M貌duls extra

/org/ no carrega tots els m貌duls disponibles. Segons la documentaci贸
es pot modificar el valor de la variable =org-modules= per afegir nous
m貌duls, per貌 no tinc clar si modificar-la ac铆 tindr efecte, una
vegada carregat /org/, o cal fer-ho en =init.el=, abans de
carregar-lo.

Aparentment =org-modules= t茅 un /setter/ que fara algo al assignar-li
un valor amb =customize-set-value=, probablement carregar els m貌duls.

Mentre ho esbrino els m貌duls es carreguen manualment.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (when (string-greaterp org-version "9")
      (require 'org-tempo)))
#+end_src

**** Plantilles estructurals (temporals)

Plantilla que expandeix =<S= en un bloc de codi /emacs-lisp/ marcat
amb =:tangle yes=. Probablement es podr esborrar quan s'hagi
completat la migraci贸 de la configuraci贸.

En algun punt entre /org/ 8.2.10 i 9.1.7 s'ha canviat la forma en que
s'expandeixen les [[info:org#Structure%20templates][plantilles estructurals]].

#+begin_src emacs-lisp :tangle yes
  ;; No tinc clara la versi贸 en que a莽貌 va canviar. En el meu context
  ;; (emacs 25.3.1 + org 8.2.10 i org 9.1.7) "9" 茅s suficientment bo.

  (if (string-greaterp org-version "9")
      (add-to-list 'org-structure-template-alist
                   '(?S . "src emacs-lisp :tangle yes"))
    (add-to-list 'org-structure-template-alist
                 '("S"
                   "#+begin_src emacs-lisp :tangle yes\n?\n#+end_src"
                   "</src>\n?\n<src lang=\"emacs-lisp\" tangle=\"yes\">"))
    (add-to-list 'org-structure-template-alist
                 '("x"
                   "#+end_src\n?\n#+begin_src emacs-lisp :tangle yes"
                   "</src>\n?\n<src lang=\"emacs-lisp\" tangle=\"yes\">")))
#+end_src

Utilitzo els estats seg眉ents per gestionar les tasques.

#+begin_src plantuml :file estats_org.png
  [*] --> TODO
  TODO --> STRT
  TODO --> CANC
  STRT --> PAUS
  STRT --> WAIT
  STRT --> DONE
  STRT --> CANC
  PAUS --> STRT
  WAIT --> STRT
  DONE --> [*]
  CANC --> [*]
#+end_src

**** =babel=

Llista de llenguatges que es poden avaluar directament des d'un bloc
de codi.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     (let ((langs '((emacs-lisp . t)
                    (python . t)
                    (plantuml . t))))
       ;; https://lists.gnu.org/archive/html/emacs-orgmode/2015-11/msg00425.html
       (if (string-greaterp org-version "8.3")
           (cons '(shell . t) langs)
         (cons '(sh . t) langs)))))
#+end_src

Al exportar un document cada vegada demana confirmaci贸 per avaluar els
blocs de codi /plantuml/, resulta molest.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ob-core
    (setq org-confirm-babel-evaluate
          (lambda (lang body)
            (not (member lang '("plantuml"))))))
#+end_src

**** =emacs-htmlize=                                                 :manual:

L'exportaci贸 a HTML en org 9.1.8 requereix que estigui instal路lat
=emacs-htmlize=, el problema 茅s que no apareix a ELPA (melpa?):

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/hniksic/emacs-htmlize.git
  ./scripts/compile_package emacs-htmlize
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :after org
    :load-path "site-lisp/emacs-htmlize")
#+end_src

**** =ob-plantuml=

=ob-plantuml= permet integrar diagrames /plantuml/ dins els documents
/org/. Per exemple:

#+begin_src org
  ,#+begin_src plantuml :file tryout.png
    Alice -> Bob: synchronous call
    Alice ->> Bob: asynchronous call
  ,#+end_src
#+end_src

Requereix un /jar/ (java archive) que es pot descarregar des de
http://plantuml.com/download. Tamb茅 requereix el JRE. Provat amb la
versi贸 8.0.131.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ob-plantuml"
    (customize-set-value
     'org-plantuml-jar-path
     (expand-file-name "~/.local/lib/plantuml/plantuml.jar")))
#+end_src

**** =org=

Defineix el comportament quan s'edita un bloc plegat.

#+begin_src emacs-lisp :tangle yes
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

Les opcions disponibles es troben a l'[[help:org-catch-invisible-edits][ajuda]].

Defineix el nombre de l铆nies en blanc necessaries per mantindre una
l铆nia en blanc entre seccions col路lapsades. Personalment prefeixo que
les cap莽aleres apareguin juntes.

#+begin_src emacs-lisp :tangle yes
  (setq org-cycle-separator-lines 0)
#+end_src

**** =ox-twbs=

https://github.com/marsmining/ox-twbs

Exporta a HTML + bootstrap. No mata per貌 茅s m茅s agradable visualment
que el format per defecte.

Cal importar el paquet perqu猫 es registri i que aparegui en la
pantalla d'exportaci贸 (=C-c C-e=). Malauradament no hi ha cap /event/
que permeti retardar l'operaci贸 aix铆 que espera uns segons
d'inactivitat per carregar-lo.

#+begin_src emacs-lisp :tangle yes
  (use-package ox-twbs
    :ensure t
    :defer 4)
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-emphasize (char)
    (if mark-active
        (org-emphasize char)
      (insert char)))
#+end_src

Afegeix automticament la data en que es creen les entrades =TODO=:

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-add-creation-date (&rest ignore)
    "Log TODO creation time in the property drawer under the key 'CREATED'."
    (when (and (org-get-todo-state)
               (not (org-entry-get nil "CREATED")))
      (org-entry-put nil "CREATED" (format-time-string (cdr org-time-stamp-formats)))))

  (advice-add 'org-insert-todo-heading :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-heading-respect-content :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-subheading :after #'arv/org-add-creation-date)
#+end_src

**** Faces

Perqu猫 el valor de =org-todo-keyword-faces= tingui efecte sembla que
cal /declarar/ els estats amb algo tipus:

#+begin_src org
  ,#+TODO: TODO STRT PAUS(@) WAIT(@) DONE(@)
  ,#+TODO: | CANC(c@)
#+end_src

Pel que entenc 茅s necessari perqu猫 org spiga que s贸n estats finals i
que no. En funci贸 d'aix貌 s'aplica un estil.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"

        (set-face-attribute 'org-mode-line-clock nil
                            :background "green yellow")
        (set-face-attribute 'org-document-title nil
                            :foreground "pale turquoise"
                            :weight 'bold
                            :height 1.5)
        (set-face-attribute 'org-level-1 nil
                            :weight 'bold
                            :height 1.2)
        (set-face-attribute 'org-block-begin-line nil
                            :weight 'normal
                            :background "#202020")
        (set-face-attribute 'org-block nil
                            :background "black")
        (set-face-attribute 'org-block-end-line nil
                            :weight 'normal
                            :background "#202020")

        (setq org-todo-keyword-faces
              '(("TODO" . arv/hi-red)
                ("STRT" . hi-blue)
                ("PAUS" . arv/hi-orange)
                ("WAIT" . hi-pink)
                ("DONE" . arv/hi-green)
                ("CANC" . hi-green-b))))
#+end_src

**** Configuraci贸 de tecles                                      :desactivat:

Cal revisar el paquet =arv/org=. Fins aleshores es desactiva.

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "/") (lambda () (interactive) (arv/org-emphasize ?/)))
    (define-key org-mode-map (kbd "*") (lambda () (interactive) (arv/org-emphasize ?*)))
    (define-key org-mode-map (kbd "_") (lambda () (interactive) (arv/org-emphasize ?_)))
    (define-key org-mode-map (kbd "=") (lambda () (interactive) (arv/org-emphasize ?=)))
    (define-key org-mode-map (kbd "~") (lambda () (interactive) (arv/org-emphasize ?~)))
    (define-key org-mode-map (kbd "+") (lambda () (interactive) (arv/org-emphasize ?+)))
    (define-key org-mode-map (kbd "C-c M-q") 'arv/org-remove-reduntant-tags)
    (define-key org-mode-map (kbd "C-c q")   'arv/org-add-inherited-tags)
    (define-key org-mode-map (kbd "C-c $") 'arv/org-archive-subtree)
    (define-key org-mode-map (kbd "C-c C-w") 'arv/org-refile))
#+end_src

**** Plantilles de captura

Veure [[info:org#Capture%20templates][Capture templates]] per detalls.


Aquesta serveix per capturar notes relacionades amb la configuraci贸
d'emacs:

#+begin_src emacs-lisp :tangle yes
  (setq org-capture-templates
        `(("t"
           "TODO emacs"
           entry
           (file+headline "~/.emacs.d/conf.d/notes.org" "Bugs, mol猫sties, millores etc.")
           ,(concat "** TODO %^{Heading} %^g\n"
                    "   :PROPERTIES:\n"
                    "   :CREATED: %U\n"
                    "   :REFERER: %a\n"
                    "   :END:\n\n"
                    "%?")
           :empty-lines 1)))
#+end_src

Aquesta la utilitzo per capturar notes quan treballo en Hera. Potser
es podria generalitzar a notes per projecte.

#+begin_src emacs-lisp :tangle yes
  (when (getenv "HERA_ROOT")
    (push `("p"
            "TODO Hera"
            entry
            (file+headline ,(arv/path-concat (getenv "HERA_ROOT") "doc_dev" "TODO.org") "TODOs")
            ,(concat "** TODO %^{Heading} %^g\n"
                     "   :PROPERTIES:\n"
                     "   :CREATED: %U\n"
                     "   :REFERER: %a\n"
                     "   :END:\n\n"
                     "%?")
            :prepend t
            :empty-lines 1)
          org-capture-templates))
#+end_src

**** LaTeX

Classe basada en =report=. Defineix canvis en la presentaci贸 (font,
color dels enlla莽os i marges) i en l'estructura (el primer element 茅s
=chapter= no =part=).

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ox-latex"
    (add-to-list 'org-latex-classes
         '("informe" "\\documentclass[paper=a4, fontsize=10pt]{report}
  \\usepackage{fourier}
  \\usepackage[]{babel}
  \\usepackage[margin=3.5cm]{geometry}
  \\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
  \\linespread{1.5}
  \\setlength{\\parskip}{0.3cm}"
           ("\\chapter{%s}" . "\\chapter*{%s}")
           ("\\section{%s}" . "\\section*{%s}")
           ("\\subsection{%s}" . "\\subsection*{%s}")
           ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

**** Configuracions desactivades

A莽貌 茅s part de la configuraci贸 original que mai vaig acabar d'integrar
en el meu workflow. Es mant茅 per si de cas.

#+begin_src emacs-lisp :tangle no
  (defvar -refcard-directory-root (arv/path-join data-directory "refcards"))
  (defvar -org-refcard (arv/path-join -refcard-directory-root "orgcard.pdf"))

  (when (file-readable-p -org-refcard)
    (eval-after-load "org"
      '(progn
         (define-key org-mode-map (kbd "M-<f1>")
           (lambda () (interactive) (find-file -org-refcard))))))


  ;; define 'ecfg:' links
  (eval-after-load "org"
    '(progn
       (org-add-link-type "ecfg" 'arv/org-ecfg-open)
       (add-hook 'org-store-link-functions 'arv/org-ecfg-store-link)
       (define-key org-mode-map (kbd "C-c M-l") 'arv/org-ecfg-insert-link-at-point)
       ))


  ;; capture
  (setq org-capture-templates
        '(("i" "Interrupcio" entry (file+headline "gtd.org" "Interrupcions")
           (file "templates/interrupt.tmpl")
           :empty-lines 1 :clock-in t :clock-resume nil)
          ("t" "Todo" entry (file+headline "gtd.org" "Tasks")
           (file "templates/todo.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t)
          ("f" "Todo followup" entry (clock)
           (file "templates/todo_followup.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)
          ("s" "Sibling" entry (function (lambda () (org-up-heading-safe) (org-end-of-subtree t)))
           (file "templates/sibling.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)))


  ;; agenda
  (setq org-agenda-files "~/.emacs.d/org/agenda_files")

  (setq org-agenda-custom-commands
        '(("x" tags "TIPUS=\"error\"")
          ("v" todo "DONE|CANCELLED")))


  ;; options
  (eval-after-load "org"
    '(progn
       (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
       (setq org-id-track-globally t)))


  ;;; workflow
  ;;
  ;; TODO(t) STRT(s!) PAUS(p@) HOLD(i!) WAIT(w@) | DONE(d!) CANC(c@)
  ;;
  ;; - TODO: no action taken, just created the note.
  ;; - STRT: currently working on, there can be only one.
  ;; - PAUS: paused, still not finished.
  ;; - HOLD: interrupted, there can be only one.
  ;; - WAIT: paused, waiting for external feedback.
  ;; - DONE: finished, no further action is required.
  ;; - CANC: canceled, no further action is required.

  (eval-after-load "org"
    '(progn
       (setq org-todo-keywords
             '((sequence "TODO(t)" "STRT(s!)" "PAUS(p@)" "HOLD(i!)"
                         "WAIT(w@)" "|" "DONE(d!)" "CANC(c@)")))
       (setq org-directory "~/.emacs.d/org")
       (setq org-startup-folded t)
       (require 'arv-org)
       (setq arv/org-interrupt-resumed-state "STRT")
       (setq arv/org-interrupt-interrupted-state "HOLD")
       (setq arv/org-interrupt-capture-key "i")
       (setq arv/org-sctc-entering-state-clocking-actions
             '(("STRT" . nil)
               ("PAUS" . nil)
               ("WAIT" . nil)))
       (setq arv/org-sctc-paused-state "PAUS")
       (arv/org-sctc-setup)))
#+end_src

*** perl                                                         :desactivat:

Fa anys que no programo en perl i espero no haver de tornar a fer-ho.
S'inclou la configuraci贸 per nostlgia.

#+begin_src emacs-lisp :tangle no
  (add-hook 'perl-mode-hook
            (lambda()
          (set-variable 'show-trailing-whitespace t)
          (setq perl-indent-level 4)
          (turn-on-font-lock)))
#+end_src

*** po

=po-mode= es distribueix com part del codi font de =gettext= que es
pot descarregar des de:

ftp://ftp.gnu.org/pub/gnu/gettext/gettext-latest.tar.xz

El fitxers =po-mode.el= i =po-compat.el= s'han copiat dins el
directori =site-lisp=. La inicialitzaci贸 seg眉ent 茅s una adaptaci贸 de
=start-po.el=.

#+begin_src emacs-lisp :tangle yes
  (use-package po-mode
    :load-path "conf.d/site-lisp"
    :commands po-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.po\\'\\|\\.po\\." . po-mode)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package po-compat
    :load-path "conf.d/site-lisp"

    ;; :command comprova si el s铆mbol est definit (fboundp), en cas
    ;; negatiu genera un autoload i en cas afirmatiu no fa res. A莽貌 es
    ;; equivalent al que fa start-po.el.
    :commands po-find-file-coding-system

    :init
    (modify-coding-system-alist 'file "\\.po[t]?\\'\\|\\.po\\."
                                'po-find-file-coding-system))
#+end_src

*** prog-mode

Mode base pels modes de programaci贸.

Aquesta configuraci贸 permet utilitzar etiquetes, normalment dins
comentaris, que es destacaran utilitzant colors. El significat 茅s el
seg眉ent:

- /FIXME/: roig, cal una acci贸 *immediata*. Falta implementar algo,
  algo est mal etc. El codi no funcionar com s'espera fins que es
  faci l'acci贸.

- /HACK/, /OPTIMIZE/, /REVIEW/, /TODO/: taronja, cal un acci贸. El codi
  funcionar per貌 podria funcionar millor, ser m茅s net etc.

- /IMPORTANT/, /NOTE/, /WARNING/: verd, no cal acci贸. S'utilitza per
  destacar certs tipus de comentaris.

**** Combinacions de tecles

Cap tecla definida.

**** /Hook/

#+name: target-prog-mode-hook
#+begin_src emacs-lisp :tangle yes
  ;; (eval-after-load "linum"
  ;;   '(progn
  ;;      (require 'relative-linum)))

  (add-hook 'prog-mode-hook
            (lambda ()
              (linum-mode 0)
              (show-paren-mode 1)
              (set-variable 'show-trailing-whitespace t)

              (flyspell-prog-mode)
              ;; flyspell defineix C-, i C-. que ja tinc assignades i
              ;; interioritzades.
              (define-key flyspell-mode-map (kbd "C-,") nil)
              (define-key flyspell-mode-map (kbd "C-.") nil)

              ;; hi-lock

              ;; HACK: 20180818, no tinc clara la causa per貌, si no
              ;; s'activa font-lock, hi-lock no ressalta els nous
              ;; elements, nom茅s els existens en obrir l'arxiu. A莽貌
              ;; sembla consistent amb el que diu la documentaci贸:
              ;;
              ;;   In buffers where Font Lock mode is enabled, patterns
              ;;   are highlighted using font lock. In buffers where
              ;;   Font Lock mode is disabled, patterns are applied
              ;;   using overlays; in this case, the highlighting will
              ;;   not be updated as you type.
              ;;
              ;; font-lock s'activa globalment. La teoria 茅s que el hook
              ;; s'executa abans que s'hagi activat font-lock.

              (font-lock-mode 1)

              (hi-lock-mode 1)
              (hi-lock-face-buffer "\\bFIXME:" 'arv/hi-red)
              (hi-lock-face-buffer "\\bHACK:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bIMPORTANT:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bNOTE:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bOPTIMIZE:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bREVIEW:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bTODO:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bWARNING:" 'arv/hi-green)))
#+end_src

*** python
**** =arv-py=                                                        :manual:

https://github.com/patxoca/arv-py

Funcions d'utilitat per treballar amb codi python.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/arv-py.git
  ./scripts/compile_package arv-py
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pyx
    :ensure nil
    :load-path "site-lisp/arv-py"
    :commands (pyx/add-setup-dependency
               pyx/electric-colon
               pyx/insert-current-package-name
               pyx/make
               pyx/nav-goto-first-import
               pyx/refactor-wrap-for
               pyx/refactor-wrap-if-else
               pyx/refactor-wrap-try-except
               pyx/refactor-wrap-while
               pyx/refactor-wrap-with
               pyx/smart-grave
               pyx/visit-setup-py
               pyx/visit-test-module))
#+end_src

**** =elpy=

https://github.com/jorgenschaefer/elpy

Documentaci贸 https://elpy.readthedocs.io/en/latest/index.html

Pel seu funcionament requereix algunes comandes externes:

#+begin_src sh :tangle no
  pip install jedi flake8 autopep8 yapf
#+end_src

=M-x elpy-config= per veure si estan instal路lades.

#+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :config
    (defun arv/elpy-nav-forward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-forward-block))

    (defun arv/elpy-nav-backward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-backward-block))

    (arv/bind-keys elpy-mode-map
                   '(("C-<down>" arv/elpy-nav-forward_block)
                     ("C-<up>" arv/elpy-nav-backward_block)
                     ("C-<left>" nil)
                     ("C-<right>" nil)
                     ("C-c m d" elpy-doc)))

    (customize-set-value 'elpy-syntax-check-command "flake8")

    (customize-set-value 'elpy-modules
                         '(elpy-module-company
                           ;; elpy-module-django
                           elpy-module-eldoc
                           elpy-module-flymake
                           ;; elpy-module-highlight-indentation
                           elpy-module-pyvenv
                           elpy-module-sane-defaults
                           elpy-module-yasnippet)))
#+end_src

La comanda =flake8= es pot configurar des de l'arxiu
=~/.config/flake8=.

**** =pep8=                                                          :manual:

https://gist.github.com/ieure/302847

Pel seu funcionament requereix una comanda externa:

#+begin_src sh :tangle no
  pip install pycodestyle
#+end_src

La configuraci贸 detecta si =pycodestyle= est disponible. En cas
negatiu utiliza la comanda =pep8=.

#+begin_src emacs-lisp :tangle yes
  (use-package python-pep8
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands (python-pep8 pep8)
    :config
    (when (executable-find "pycodestyle")
      (customize-set-value 'python-pep8-command "pycodestyle"))
    (customize-set-value 'python-pep8-options '("--repeat" "--max-line-length=150")))
#+end_src

**** =pylookup=                                                  :desactivat:

https://github.com/tsgates/pylookup

Acc茅s a la documentaci贸. Sembla que cal baixar la documentaci贸 en
format HTML i executar un programa per indexar-la i crear una mena de
base de dades. Suposo que funcionaria per qualsevol documentaci贸, no
sols la de python.

Mai he aconseguit integrar-ho en el meu workflow, segons el que
necessito en cada cas tiro de /eldoc/, busco la definici贸 i miro el
codi font, accedeixo a la documentaci贸 online o tiro de google.

#+begin_src emacs-lisp :tangle no
  (autoload 'pylookup-lookup "pylookup")
  (autoload 'pylookup-update "pylookup")

  (eval-after-load "python"
    '(progn
       (define-key python-mode-map (kbd "C-c h") 'pylookup-lookup)))

  (add-hook 'python-mode-hook
            (lambda()
              (let ((pylookup-dir (arv/startup-get-absolute-path "site-lisp/pylookup")))
                (setq pylookup-program (arv/path-join pylookup-dir "pylookup.py"))
                (setq pylookup-db-file (arv/path-join pylookup-dir "pylookup.db"))
                )))
#+end_src

**** =pydoc info=                                                :desactivat:

https://bitbucket.org/jonwaltman/pydoc-info/

Acc茅s a la documentaci贸 en format /info/ (p.e. la generada per
/sphinx/ per python, django etc). Tampoc vaig aconseguir integrar-ho
en el workflow.

[[http://www.draketo.de/light/english/free-software/read-your-python-module-documentation-emacs][Guia de configuraci贸.]]

#+begin_src emacs-lisp :tangle no
  (autoload 'info-lookup-add-help "info-look" "" nil nil)

  (eval-after-load "python"
    '(progn
       (info-lookup-add-help
        :mode 'python-mode
        :parse-rule 'pydoc-info-python-symbol-at-point
        :doc-spec
        '(("(python)Index" pydoc-info-lookup-transform-entry)
          ("(django14)Index" pydoc-info-lookup-transform-entry)))))
#+end_src

**** =pylint=                                                        :manual:

https://github.com/PyCQA/pylint/tree/master/elisp

El paquet =pylint.el= no est disponible en /ELPA/. Forma part de la
distribuci贸 de =pylint= i s'ha copiat dins el directori
=site-packages=. Requereix la comanda externa =pylint=, prove茂da pel
paquet python =pylint=:

#+begin_src sh :tangle no
  pip install pylint
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pylint
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pylint)
#+end_src

**** =pytest=                                                        :manual:

Integra el paquet python =pytest= dins emacs. La implementaci贸
original 茅s de [[https://github.com/ionrock/pytest-el][ionrock]] per貌 utilitzo un [[https://github.com/patxoca/pytest-el][fork]] propi.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/pytest-el.git
  ./scripts/compile_package pytest-el
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pytest
    :load-path "site-lisp/pytest-el"
    ;; 煤nicament es defineixen autoloads per les funcions utilitzades en
    ;; la configuraci贸.
    :commands (pytest-all
               pytest-one
               pytest-rerun-last
               pytest-mode-enable-if-test-module)

    :init
    ;; cal definir-la abans d'activar el mode
    (setq pytest-mode-keymap-prefix "C-c m t")

    :config
    (arv/bind-keys pytest-mode-map
                   '(("<f12>" pytest-one)))

    ;; WARNING: definir `pytest-cmd-flags' com segura per qualsevol
    ;; cadena 茅s potencialment perill贸s, deixa la porta oberta a valors
    ;; maliciosos com ara " ; rm -Rf $HOME/ #"
    (put 'pytest-cmd-flags 'safe-local-variable 'stringp))
#+end_src

**** =python=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (setq python-shell-virtualenv-path (getenv "VIRTUAL_ENV"))
    (setq python-indent-guess-indent-offset nil)

    ;; defineix l'interpret
    (customize-set-value 'python-shell-interpreter "ipython")
    (customize-set-value 'python-shell-interpreter-args "-i --simple-prompt")


    ;; activates source tracking when debugging with pdb from a shell
    ;; buffer
    (add-hook 'comint-output-filter-functions 'python-pdbtrack-comint-output-filter-function)

    (elpy-enable))
#+end_src

**** =sphinx-doc=

https://github.com/naiquevin/sphinx-doc.el

=sphinx-doc= is an emacs minor mode for inserting docstring skeleton
for Python functions and methods. The structure of the docstring is as
per the requirement of the Sphinx documentation generator.

#+begin_src emacs-lisp :tangle yes
  (use-package sphinx-doc
    :ensure t
    :commands sphinx-doc-mode)
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (arv/bind-keys
     python-mode-map
     '(("C-c m 8" python-pep8)
       ("C-c m m" pyx/make)
       ("C-c m p" pylint)
       ("C-c m w f" pyx/refactor-wrap-for)
       ("C-c m w i" pyx/refactor-wrap-if-else)
       ("C-c m w t" pyx/refactor-wrap-try-except)
       ("C-c m w w" pyx/refactor-wrap-while)
       ("C-c m i s d " pyx/add-setup-dependency)
       ("C-c m i p n" pyx/insert-current-package-name)

       ;; pytest
       ("<f12>" pytest-all)
       ("C-<f12>" pytest-rerun-last)

       ("<f9>" pyx/make)
       ("s-<tab>" python-indent-shift-right)
       ("s-<iso-lefttab>" python-indent-shift-left)
       (":" pyx/electric-colon)
       ("`" pyx/smart-grave)
       ("C-m" newline-and-indent)
       ("C-c j i" pyx/nav-goto-first-import)
       ("C-c j S" pyx/visit-setup-py)
       ("C-c j T" pyx/visit-test-module)
       ("C-=" arv/rst-underline-header)
       ("C-," arv/wm-cycle-2)
       ("C->" indent-rigidly-right-to-tab-stop)
       ("C-<" indent-rigidly-left-to-tab-stop)
       ))
    (define-key python-mode-map (kbd "C-<tab>")
      (make-hippie-expand-function
       '(try-expand-dabbrev
         ;; try-expand-tags
         try-expand-dabbrev-all-buffers)
       t)))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'python
    (add-hook 'python-mode-hook
              (lambda ()
                ;; outline
                (outline-minor-mode t)
                (set
                 (make-local-variable 'outline-regexp)
                 "[\t ]*\\(class\\|def\\|if\\|elsif\\|else\\|while\\|for\\|try\\|except\\|finally\\)\\>")

                ;; ressalta les l铆nies on hi ha un breakpoint
                (highlight-lines-matching-regexp "^[[:space:]]*import i?pdb")
                (highlight-lines-matching-regexp "^[[:space:]]*i?pdb.set_trace()")

                ;; company-mode
                (company-mode t)

                ;; afecta a indent-rigidly-(left|righ)-to-tab-stop
                (setq python-indent-offset 4)
                (setq tab-width python-indent-offset)

                ;; ressalta els nivell d'indentacio
                ;; (arv/highlight-indentation-mode 0)

                ;; pylint/flymake-pylint
                ;; (pylint-add-menu-items)
                ;; (flymake-mode 1)

                ;; sphinx-doc
                (sphinx-doc-mode t)

                (superword-mode 1)
                (pytest-mode-enable-if-test-module)
                )))
#+end_src

*** python-django

Configuracions per facilitar el treball en projectes django:

- introspecci贸: obtindre les apps, els models etc. (=djira-el=).

- operacions amb les /apps/: visitar un model, una vista, consultar la
  documentaci贸 etc. (=django-el=).

- edici贸 de plantilles (=pony-tpl=).

**** =django-el=                                                     :manual:

https://github.com/patxoca/django-el.git

Biblioteca que implementa funcions que faciliten la navegaci贸 dins un
projecte django.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/django-el.git
  ./scripts/compile_package django-el
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package django-el
    :ensure nil
    :load-path "site-lisp/django-el"
    :init (setq django-el-prefix-key "C-c d")
    :commands (django-el-mode
               django-el-jump-to-javascript-controller
               django-el-jump-to-template
               django-el-autopair-template-tag))
#+end_src

**** =djira-el=                                                   :manual:

https://github.com/patxoca/djira-el

Biblioteca que permet accedir a la api definida per =djira= ([[https://github.com/patxoca/djira][github]]).
Aquest paquet substitueix a =python-django=, que ja no 茅s mantingut.

Pel seu funcionament requereix que django estigui executant-se i que
tingui instal路lada l'aplicaci贸 =djira=.


#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/djira-el.git
  ./scripts/compile_package djira-el
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package djira
    :ensure nil
    :load-path "site-lisp/djira-el"
    :commands (djira-buffer-belongs-in-app-p))
#+end_src

**** =pony-tpl=                                                      :manual:

https://github.com/davidmiller/pony-mode

=pony-tpl= defineix un mode menor per editar plantilles django. Forma
part de =pony-mode= (abandonat?).

S'ha incorporat una versi贸 local dins el directori =site-lisp= de la
configuraci贸 en la que s'han eliminat les depend猫ncies de =pony-mode=.

#+begin_src emacs-lisp :tangle yes
  (use-package pony-tpl
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pony-tpl-mode)
#+end_src

**** Configuraci贸

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (arv/bind-keys python-mode-map
                   '(("C-c j t" django-el-jump-to-template)
                     ("C-c j j" django-el-jump-to-javascript-controller))))

  (with-eval-after-load "sgml-mode"
    (arv/bind-keys html-mode-map
                   '(("C-c j t" django-el-jump-to-template)
                     ("%" django-el-autopair-template-tag)))
    (add-hook 'html-mode-hook
              (lambda ()
                (when (djira-buffer-belongs-in-app-p (current-buffer))
                  (pony-tpl-mode)))))
#+end_src

*** rst
**** Funcions auxiliars
***** Documents =rst=

Funcions per treballar amb documents =rst=.

#+begin_src emacs-lisp :tangle yes
  (defun arv/rst-underline-header (caracter)
    (interactive "cCaracter: ")
    (let ((l (length (buffer-substring-no-properties (progn
                                                       (back-to-indentation)
                                                       (point))
                                                     (progn
                                                       (end-of-line)
                                                       (point)))))
          (indentation-level (progn
                               (back-to-indentation)
                               (current-column))))
      (when l
        (end-of-line)
        (insert "\n")
        (insert (make-string indentation-level ?\s))
        (insert (make-string l caracter))
        (insert "\n\n")
        (insert (make-string indentation-level ?\s)))))

  (defun arv/-rst-after-role-p ()
    "Return t if point is after a role."
    (looking-back ":\\w+:" (line-beginning-position)))

  (defun arv/rst-smart-grave ()
    "Tries to be smart about common ` usage patterns.

  If point is after a role (like :xref:) inserts ``, elsewhere
  inserts ```` (inline code literal). Point is left in the middle.

  If the region is active surround it and point is left at the
  end."
    (interactive)
    (let ((begin (point))
          (end   (point))
          (active (region-active-p))
          (delimiter))
      (when active
        (setq begin (min (region-beginning) (region-end)))
        (setq end   (max (region-beginning) (region-end))))
      (goto-char begin)
      (setq delimiter (if (arv/-rst-after-role-p)
                          "`"
                        "``"))
      (insert delimiter)
      (goto-char (+ end (length delimiter)))
      (insert delimiter)
      (unless active
        (backward-char (length delimiter)))))

  (defun arv/rst-smart-asterisk ()
    "Tries to be smart about * usage.

  If there's only withespace before point it assumes that it's a
  list bullet and inserts '* ', otherwise it inserts '**' and
  leaves point in the middle."
    (interactive)
    (if (string-match-p "^\s*$"
                        (buffer-substring-no-properties (line-beginning-position) (point)))
        (insert "* ")
      (insert "**")
      (backward-char 1)))
#+end_src

***** /sphinx/

Comandes per facilitar el treball amb documentaci贸 processada amb
[[http://www.sphinx-doc.org/en/master/][sphinx]].

Les funcions per compilar el projecte operen amb el Makefile generat
per sphinx. El Makefile es busca en el directori actual (on est
l'arxiu del buffer actual) i en els directoris pare.

#+begin_src emacs-lisp :tangle yes
  (defun arv/-sphinx-locate-makefile ()
    "Busca l'arxiu Makefile comen莽ant en el directori on est el
  buffer actual i visitant els directoris pare.

  Si troba el Makefile retorna la ruta absoluta del directori que
  el conte. Retorna nil si no el troba."
    (let ((cwd (file-name-directory (expand-file-name (buffer-file-name)))))
      (while (and (not (string= cwd "/"))
                  (not (file-exists-p (concat cwd "Makefile"))))
        (setq cwd (file-name-directory (directory-file-name cwd))))
      (if (string= cwd "/")
          nil
        cwd)))

  (defun arv/-sphinx-build (target)
    "Intenta executar 'make <target>'"
    (let ((makefile (arv/-sphinx-locate-makefile)))
      (unless (null makefile)
        (compilation-start (format "make -k -C %s %s" makefile target)
                           t
                           (lambda (mode) "*sphinx*")))))

  (defun arv/sphinx-build-latexpdf ()
    "Genera PDF"
    (interactive)
    (arv/-sphinx-build "latexpdf"))

  (defun arv/sphinx-build-html ()
    "Genera HTML"
    (interactive)
    (arv/-(setq  )phinx-build "html"))

  (defun arv/sphinx-run-doctest ()
    "Executa els doctest"
    (interactive)
    (arv/-sphinx-build "doctest"))
#+end_src

***** cpctelera

Apanyo rpid per facilitar compilar AGD.

#+begin_src emacs-lisp :tangle yes
  (defun cpct_make ()
    "Executa make dins un projecte de la cpctelera."
    (interactive)
    (arv/-sphinx-build ""))
#+end_src

**** Definicions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "rst"
    (arv/bind-keys
     rst-mode-map
     '(("*" arv/rst-smart-asterisk)
       ("`" arv/rst-smart-grave)
       ("<f9>" arv/sphinx-build-latexpdf)
       ("C-<f9>" arv/sphinx-run-doctest)
       ("M-<f9>" arv/sphinx-build-html)
       ("C-=" arv/rst-underline-header))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'rst-mode-hook
            (lambda ()
              (auto-fill-mode 1)
              (flyspell-mode 0)
              ;; activa el resaltat d'espai en blanc al final de l铆nia
              (set-variable 'show-trailing-whitespace t)
              ;; customize-face (suposo) te problemes quan la llista
              ;; d'atributs esta buida, sembla que ho interpreta com "no
              ;; canviar res" enlloc de "borrar tots els atributs"
              (set-face-attribute 'rst-level-1 nil :background nil)
              (set-face-attribute 'rst-level-2 nil :background nil)
              (set-face-attribute 'rst-level-3 nil :background nil)
              (set-face-attribute 'rst-level-4 nil :background nil)
              (set-face-attribute 'rst-level-5 nil :background nil)
              (set-face-attribute 'rst-level-6 nil :background nil)
              ))
#+end_src

*** vue                                                          :desactivat:

Actualment no l'utilitzo.

#+begin_src emacs-lisp :tangle no
(require 'mmm-mode)
(require 'vue-mode)
(mmm-add-mode-ext-class nil "\\.vue\\'" 'vue-mode)
#+end_src

*** zope

Associa modes als arxius relacionats amb zope:

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.pt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.cpt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.zpt$" . html-mode))

  (add-to-list 'auto-mode-alist '("\\.vpy$" . python-mode))
  (add-to-list 'auto-mode-alist '("\\.cpy$" . python-mode))

  (add-to-list 'auto-mode-alist '("\\.css.dtml$" . css-mode))
#+end_src

** Variat

Ressalta el par猫ntesi corresponent a l'actual.

#+begin_src emacs-lisp :tangle yes
  (show-paren-mode 1)
#+end_src

Esborra els espais en blanc al final de les l铆nies en el moment de
guardar l'arxiu.

#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Si estem en un GUI canvia el t铆tol de la finestra per mostrar el nom
del buffer actiu i la ruta de l'arxiu.

#+begin_src emacs-lisp :tangle yes
(when window-system
  (setq frame-title-format '("emacs %b (%f)")))
#+end_src

De vegades es guarda repetidament la mateixa marca. Aquest /advice/
elimina les repeticions, accelerant la navegaci贸.

http://endlessparentheses.com/faster-pop-to-mark-command.html

#+begin_src emacs-lisp :tangle yes
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+end_src

Per recuperar les marques de la pila cal utilitzr =C-u C-SPC= per cada
marca, poc gil. Aquest canvi permet utilitzar =C-u C-SPC C-SPC ...=

#+begin_src emacs-lisp :tangle yes
  (setq set-mark-command-repeat-pop t)
#+end_src

En el meu mon les frases es separen amb un espai, no dos.

#+begin_src emacs-lisp :tangle yes
  (customize-set-value 'sentence-end-double-space nil)
#+end_src

Prefereixo utilitzar espais pel sagnat, conserven el format.

#+begin_src emacs-lisp :tangle yes
  (customize-set-variable 'indent-tabs-mode nil)
  (customize-set-variable 'tab-width 4)
#+end_src

Algunes comandes, que es consideren /perilloses/ pels /novatos/, estan
desactivades. A aquestes al莽ades crec que puc activar-les totes:

#+begin_src emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+end_src

Per classificar:

#+begin_src emacs-lisp :tangle yes
  (setq inhibit-eol-conversion nil)

  (setq text-scale-mode-step 1.1)

  ;; assorted
  (setq ansi-color-for-comint-mode t)
  (setq current-language-environment "UTF-8")

  ;; display-buffer-reuse-frames is a variable defined in `window.el'.
  ;; Its value is nil
  ;;
  ;;   This variable is obsolete since 24.3;
  ;;   use a `reusable-frames' alist entry in `display-buffer-alist'.
  ;;
  ;; Documentation:
  ;; Non-nil means `display-buffer' should reuse frames.
  ;; If the buffer in question is already displayed in a frame, raise
  ;; that frame.
  (setq display-buffer-reuse-frames t)

  (setq next-line-add-newlines nil)
  (setq scroll-preserve-screen-position t)
  (setq scroll-step 1)
  (setq tooltip-mode t)
  (setq transient-mark-mode t)
  (setq visible-bell nil)
#+end_src

*** Backups

El 99% del temps els arxius de backup creats durant l'edici贸 s贸n m茅s
una mol猫stia que altra cosa. Es mouen a un directori de backup per si
cal recuperar-los.

#+begin_src emacs-lisp :tangle yes
  (let ((backup-dir (arv/path-concat user-emacs-directory "backups" "files")))
    (unless (file-directory-p backup-dir)
      (make-directory backup-dir t))
    (setq backup-directory-alist `(("." . ,backup-dir))))
#+end_src

*** Faces

#+begin_src emacs-lisp :tangle yes
(set-face-attribute 'cursor  nil
                    :background "#fce94f")
(set-face-attribute 'default nil
                    :height 100)
#+end_src

Canvia el color del cursor per indicar que ens troben en mode inserci贸
o sobreescriptura.

#+begin_src emacs-lisp :tangle yes
  (defadvice overwrite-mode (after overwrite-mode-adjust-cursor activate)
    "Change cursor color when enabling/disabling overwrite mode."
    (set-cursor-color (if overwrite-mode
                          "purple"
                        "#fce94f")))
#+end_src

** Comandes

Comandes que proveeixen funcionalitat a l'usuari (i poden estar
lligades a combinacions de tecles).

*** =arv/alternar-mida-font=

De vegades 茅s interessant augmentar temporalment la mida de la font
(una visita amb qui cal revisar codi). Fins ara utilitzava =C-+= i
=C--= per貌 no funciona b茅 amb =company-mode=, cal fer-ho buffer a
buffer i cada buffer acaba amb una mida de lletra diferent.

Aquesta funci贸 alterna entre una mida per defecte i una de gran.

Pel moment les mides estan fixades al cos de la funci贸. s frgil. He
provat guardant la mida inicial i comparant amb aquest valor per
determinar l'estat per貌 no funciona. El valor guardat 茅s 100 (el
assigant en la secci贸 [[*Faces][Faces]]) per貌 el llegit posteriormente en la
funci贸 茅s 98. No s茅 si el tema o algun paquet canvia el valor o si 茅s
algun tipus d'arrodoniment de la mida. Fins que esbrini una soluci贸
millor 茅s queda fixat i s'utilitza un /flag/ bi-estat per seguir la
pista de l'esta.

#+begin_src emacs-lisp :tangle yes
  (defvar arv/big-font-enabled nil)

  (defun arv/alternar-mida-font ()
    "Alterna entre font 'normal' i 'gran'."
    (interactive)
    (set-face-attribute 'default nil
                        :height (if arv/big-font-enabled
                                    98
                                  140))
    (setq arv/big-font-enabled (not arv/big-font-enabled)))
#+end_src

*** =arv/downcase-word= i =arv/upcase-word=

Converteix a maj煤scules/min煤scules la paraula en el punt. A difer猫ncia
de =upcase-word= i =downcase-word=, no cal situar el punt al
comen莽ament de la paraula.

/Robat/ de http://oremacs.com/2014/12/23/upcase-word-you-silly/

#+begin_src emacs-lisp :tangle yes
  (defun arv/upcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'upcase-word))))

  (defun arv/downcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'downcase-word))))
#+end_src

*** =arv/duplicate-line-or-region-dwim=

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-dwim (arg)
    "Duplicate current line.

  - Without prefix argument duplicate current line.

  - Positive prefix ARG means include previous ARG lines plus the
    current one.

  - If ARG is negative include current line plus next ARG lines.

  - If the region is active duplicates all the complete lines
    intersecting with the region. ARG is ignored."
    (interactive "P")
    (let (start
          end
          where
          text)
      (cond
       ((region-active-p)
        (setq beg (save-excursion
                    (goto-char (min (point) (mark)))
                    (line-beginning-position)))
        (setq end (save-excursion
                    (goto-char (max (point) (mark)))
                    (forward-line)
                    (line-beginning-position)))
        (setq where end))
       ((null arg)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position 2))
        (setq where end))
       ((< arg 0)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position (+ (- arg) 2)))
        (setq where beg))
       (t
        (setq beg (line-beginning-position (+ (- arg) 1)))
        (setq end (line-beginning-position 2))
        (setq where end)))
      (save-excursion
        (goto-char end)
        (when (eobp)
          (newline)
          (setq end (1+ end))
          (unless (= where beg)
            (setq where end))))
      (setq text (buffer-substring-no-properties beg end))
      (goto-char where)
      (insert text)
      (goto-char where)
      (back-to-indentation)))
#+end_src

*** =arv/duplicate-line-or-region-and-comment-dwim=

#+begin_src emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-and-comment-dwim (start stop)
    "Duplicate the whole lines i region and comment them.
  Mostly equivalent to select region, copy, paste, select again and
  comment region, but the region is not copied to the kill ring and
  the text properties are removed."
    (interactive "r")
    (let* ((beg (progn (goto-char start) (line-beginning-position)))
           (end (progn (goto-char stop) (line-end-position)))
           (text (buffer-substring-no-properties beg end)))
      (goto-char end)
      (newline)
      (insert text)
      (comment-region beg end)))
#+end_src

*** =arv/generate-random-uuid= i =arv/insert-random-uuid=

#+begin_src emacs-lisp :tangle yes
  (defun arv/generate-random-uuid ()
    (with-temp-buffer
      (shell-command "uuidgen -r" t)
      (beginning-of-buffer)
      (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/insert-random-uuid ()
    "Insert random UUID"
    (interactive)
    (insert (arv/generate-random-uuid)))
#+end_src

*** =arv/goto-line=

Com =goto-line= per貌 activa =linum-mode= per facilitar identificar la
l铆nia.

No ho utilitzo gaire.

#+begin_src emacs-lisp :tangle yes
  (defun arv/goto-line ()
    "Like `goto-line' but temporarily display absolute line
  numbers."
    (interactive)
    (let ((linum-enabled linum-mode))
      (unwind-protect
          (let ((relative-linum-enabled nil))
            (linum-mode 1)
            (call-interactively 'goto-line))
        (unless linum-enabled
          (linum-mode -1)))))
#+end_src

*** =arv/grin=

La implementaci贸 per defecte de la funci贸 =grin= realitza la cerca en
el directori actual, el que no resulta massa prctic. La funci贸
definida ac铆 demana el directori on fer la cerca.

#+begin_src emacs-lisp :tangle yes
  (defun arv/grin ()
    (interactive)
    (let ((default-directory (ido-read-directory-name "Directory: " nil nil t)))
      (grin)))
#+end_src

*** =arv/kill-ring-save-word-at-point=

#+begin_src emacs-lisp :tangle yes
  (defun arv/kill-ring-save-word-at-point ()
    "Copia un text en el kill ring. El seu comportament varia
  depenent de si la marca est o no activa:

  - si est activa delega en `kill-ring-save' i es copia el text
    seleccionat.

  - sin贸 es copia el s铆mbol sobre el que est situat el cursor."
    (interactive)
    (if mark-active
        (call-interactively 'kill-ring-save)
      (kill-new (thing-at-point 'symbol))))
#+end_src

*** =arv/open-line-after-and-indent=, =arv/open-line-before-and-indent=

#+begin_src emacs-lisp :tangle yes
  (defun arv/open-line-before-and-indent (n)
    "Insereix una l铆nia abans de l'actual i indenta. Amb un prefix
  num猫ric N insereix N l铆nies."
    (interactive "*p")
    (open-line n)
    (indent-according-to-mode))

  (defun arv/open-line-after-and-indent (n)
    "Insereix una l铆nia despr茅s de l'actual i indenta. Amb un
  prefix num猫ric N insereix N l铆nies."
    (interactive "*p")
    (end-of-line)
    (newline n)
    (indent-according-to-mode))
#+end_src

*** =arv/query-replace=

#+begin_src emacs-lisp :tangle yes
  (defun arv/query-replace (&optional arg)
    "Replacement for `query-replace'.

  - It proposes the symbol at point as the initial value for the
    search string.

  - If the region is active it contraints the replacement,
    otherwise operate on the whole buffer.

  - Without prefix argument performs `query-replace'.

  - With C-u performs `replace-string'.

  In any case point is preserved."
    (interactive "*P")
    (let* ((old-string (read-string "Replace: " (thing-at-point 'symbol)))
           (new-string (read-string (concat "Replace " old-string " with: ") ""))
           (start (if mark-active (min (mark) (point)) (point-min)))
           (end   (if mark-active (max (mark) (point)) (point-max))))
      (save-excursion
        (if (not arg)
            (query-replace old-string new-string nil start end)
          (goto-char start)
          (while (search-forward old-string end t)
            (replace-match new-string))))))
#+end_src

*** =arv/visit-emacs-config=

Visita aquest arxiu de configuraci贸:

#+begin_src emacs-lisp :tangle yes
  (defun arv/visit-emacs-config ()
    "Visita l'arxiu de configuraci贸 d'emacs."
    (interactive)
    (let ((settings-org (arv/path-concat arv/emacs-conf-dir "settings.org")))
      (find-file settings-org)))
#+end_src

*** Comentari dins rectangle

http://pragmaticemacs.com/emacs/comment-boxes/

Semblant a [[help:comment-box][=comment-box=]], fa que el retangle tingui una amplada m铆nima
igual a =fill-column=.

#+begin_src emacs-lisp :tangle yes
  (defun bjm-comment-box (b e)
    "Draw a box comment around the region but arrange for the
  region to extend to at least the fill column. Place the point
  after the comment box."

    (interactive "r")

    (let ((e (copy-marker e t)))
      (goto-char b)
      (end-of-line)
      (insert-char ?  (- fill-column (current-column)))
      (comment-box b e 1)
      (goto-char e)
      (set-marker e nil)))
#+end_src

*** Partir finestres

Idea treta del v铆deo [[https://www.youtube.com/watch?v=nKCKuRuvAOw&t=252][Emacs microhabit - Switching windows]] de Sacha
Chua: parteix una finestra horitzontal/verticalment i mostra un buffer
diferent en la nova finestra.

La versi贸 de Sacha Chua selecciona automticament el buffer, no m'he
pogut acostumar. Aquesta versi贸 permet triar el buffer (o arxiu) que
es mostrar en la nova finestra.

#+begin_src emacs-lisp :tangle yes
  (defun arv/split-windows-bellow (prefix)
    "Parteix la finestra verticalment i tria el buffer a mostrar.

  Al partir una finestra permet seleccionar quin buffer es mostrar
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estndard estan disponibles. Especialment 煤tils s贸n:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel路la la selecci贸, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-below)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))

  (defun arv/split-windows-right (prefix)
    "Parteix la finestra horitzontalment i tria el buffer a mostar.

  Al partir una finestra permet seleccionar quin buffer es mostrar
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estndard estan disponibles. Especialment 煤tils s贸n:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel路la la selecci贸, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-right)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))
#+end_src

*** conversi贸 d'entitats HTML <-> carcter

Modificacions menors al codi trobat en:

https://stackoverflow.com/questions/24085067/is-there-an-emacs-package-for-html-escaping

- afegit =save-excursion=

- fer expl铆cit que cal concondncia maj煤scules/min煤scules en les
  cerques.

#+begin_src emacs-lisp :tangle yes
  (setq ar-html2uml
    '(
      ("&AElig;" "")
      ("&Aacute;" "")
      ("&Acirc;" "")
      ("&Agrave;" "")
      ("&Aring;" "")
      ("&Atilde;" "")
      ("&Auml;" "")
      ("&Ccedil;" "")
      ("&ETH;" "")
      ("&Eacute;" "")
      ("&Ecirc;" "")
      ("&Egrave;" "")
      ("&Euml;" "")
      ("&Iacute;" "")
      ("&Icirc;" "")
      ("&Igrave;" "")
      ("&Iuml;" "")
      ("&Ntilde;" "")
      ("&Oacute;" "")
      ("&Ocirc;" "")
      ("&Ograve;" "")
      ("&Oslash;" "")
      ("&Otilde;" "")
      ("&Ouml;" "")
      ("&Ouml;" "")
      ("&THORN;" "")
      ("&Uacute;" "")
      ("&Ucirc;" "")
      ("&Ugrave;" "")
      ("&Uuml;" "")
      ("&Yacute;" "")
      ("&aacute;" "谩")
      ("&acirc;" "芒")
      ("&acute;" "\x{00B4}")
      ("&aelig;" "忙")
      ("&agrave;" "")
      ("&aring;" "氓")
      ("&atilde;" "茫")
      ("&auml;" "盲")
      ("&brvbar;" "\x{00A6}")
      ("&ccedil;" "莽")
      ("&cedil;" "\x{00B8}")
      ("&cent;" "垄")
      ("&copy;" "漏")
      ("&curren;" "\x{00A4}")
      ("&deg;" "掳")
      ("&divide;" "梅")
      ("&eacute;" "茅")
      ("&ecirc;" "锚")
      ("&egrave;" "猫")
      ("&eth;" "冒")
      ("&euml;" "毛")
      ("&frac12;" "\x{00BD}")
      ("&frac14;" "\x{00BC}")
      ("&frac34;" "\x{00BE}")
      ("&iacute;" "铆")
      ("&icirc;" "卯")
      ("&iexcl;" "隆")
      ("&igrave;" "矛")
      ("&iquest;" "驴")
      ("&iuml;" "茂")
      ("&laquo;" "芦")
      ("&macr;" "炉")
      ("&micro;" "碌")
      ("&middot;" "路")
      ;; ("&nbsp;" " ")
      ("&not;" "卢")
      ("&ntilde;" "帽")
      ("&oacute;" "贸")
      ("&ocirc;" "么")
      ("&ograve;" "貌")
      ("&ordf;" "陋")
      ("&ordm;" "潞")
      ("&oslash;" "酶")
      ("&otilde;" "玫")
      ("&ouml;" "枚")
      ("&para;" "露")
      ("&plusmn;" "卤")
      ("&pound;" "拢")
      ("&raquo;" "禄")
      ("&reg;" "庐")
      ("&sect;" "搂")
      ("&shy;" "颅")
      ("&sup1;" "鹿")
      ("&sup2;" "虏")
      ("&sup3;" "鲁")
      ("&szlig;" "")
      ("&thorn;" "镁")
      ("&times;" "")
      ("&uacute;" "煤")
      ("&ucirc;" "没")
      ("&ugrave;" "霉")
      ("&uml;" "\x{00A8}")
      ("&uuml;" "眉")
      ("&yacute;" "媒")
      ("&yen;" "楼")
      ("&yuml;" "每")
      ))

  (defun ar-uml2html ()
    "Translate chars into html entities"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil)
          erg)
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (cadr ele) nil t 1)
            (setq erg (car ele))
            ;; Replacing with code starting from & upcases
            ;; Emacs bug?
            (replace-match "")
            (insert erg))))))

  (defun ar-html2uml ()
    "Translate html entities into text"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil))
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (car ele) nil t 1)
            (replace-match "")
            (insert (cadr ele)))))))

#+end_src

*** conversi贸 de format DOS <-> UNIX

#+begin_src emacs-lisp :tangle yes
  (defun unix-to-dos ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun dos-to-unix ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix))
#+end_src

*** =endless/comment-line-or-region=

Comment or uncomment current line and leave point after it. With
positive prefix, apply to N lines including current one. With negative
prefix, apply to -N lines above. If region is active, apply to active
region instead.

http://endlessparentheses.com/implementing-comment-line.html

#+begin_src emacs-lisp :tangle yes
  (defun endless/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above.
  If region is active, apply to active region instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range)))
      (forward-line 1)
      (back-to-indentation)))
#+end_src

*** =endless/isearch-symbol-with-prefix=

Like isearch, unless prefix argument is provided. With a prefix
argument P, isearch for the symbol at point.

http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html

#+begin_src emacs-lisp :tangle yes
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))
#+end_src

*** =zap-up-to-char=

Kill up to but not including ARGth occurrence of CHAR. Case is ignored
if `case-fold-search' is non-nil in the current buffer. Goes backward
if ARG is negative; error if CHAR not found.

#+begin_src emacs-lisp :tangle yes
(defun zap-up-to-char (arg char)
  "Kill up to but not including ARGth occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     (read-char "Zap up to char: " t)))
  (zap-to-char arg char)
  (insert char)
  (when (> arg 0)
    (forward-char -1)))
#+end_src

** Mini paquets

Implementaci贸 de funcionalitat que requereix m茅s que una funci贸 per貌
no t茅 un paquet pr貌pi.

*** =arv-org=                                               :desactivat:brut:

#+begin_src emacs-lisp :tangle no
  ;;; assorted utilities

  (autoload 'org-agenda-files "org" "" nil nil)

  (defun arv/org-visit-agenda-file ()
    ""
    (interactive)
    (find-file
     (ido-completing-read "Agenda file:" (org-agenda-files) nil t)))


  (defun arv/org--get-tags ()
    (delete "" (split-string (or (org-entry-get (point) "TAGS") "") ":")))

  (defun arv/org--get-parent-tags ()
    (save-excursion
      (save-restriction
        (widen)
        (if (org-up-heading-safe)
            (delete "" (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
          nil))))

  (defun arv/org-remove-reduntant-tags ()
    "Walks the tree-at-point removing redundant tags."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         (lambda ()
           (let ((tags    (arv/org--get-tags))
                 (alltags (arv/org--get-parent-tags)))
             (dolist (tag tags)
               (when (member tag alltags)
                 (org-toggle-tag tag 'off)))))
         nil 'tree)))
    ;; Something gets corrupted and tags are not displayed. That
    ;; happens in my real org file, in test.org (simplest) it works ok.
    ;; Collapsing works around the issue.
    (org-shifttab 2))

  (defun arv/org-add-inherited-tags ()
    "Add inherited tags to sutree-at-point."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-back-to-heading)
        (let ((tags    (arv/org--get-tags))
              (alltags (arv/org--get-parent-tags)))
          (dolist (tag alltags)
            (unless (member tag tags)
              (org-toggle-tag tag 'on))))
        nil 'tree)))

  (defun arv/org-refile (&rest args)
    "Like org-refile but updates tags."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-refile args)
    (save-excursion
      (org-refile '(16))                 ;goto insertion
      (arv/org-remove-reduntant-tags)))


  (defun arv/org-archive-subtree (&rest args)
    "Add inherited tags on archiving."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-archive-subtree args))


  (defun arv/org-start ()
    "Start org agenda within emacs server."
    (interactive)
    (server-start)
    (org-agenda nil "a"))
#+end_src

**** Codi desactivat                                             :desactivat:

Els enlla莽os /ecfg/ permeten referenciar la configuraci贸 d'emacs. Al
moure la configuraci贸 dins un document /org/ probablement ja no s贸n
necessaris.

Es mant茅 com exemple.

#+begin_src emacs-lisp :tangle no
  ;;; 'ecfg:' links
  ;;
  ;; 'ecfg:' URLs point to files in my emacs configuration. The links
  ;; are relative to `emacs-startup-dir'. Useful for tasks/notes when
  ;; hacking my emacs configuration.

  (defun arv/org-ecfg--relativize-to-startup-dir-maybe (path)
    "Converts .PATH into a path relative to
  `emacs-startup-dir'. Returns the relative path or nil if PATH is
  outside `emacs-startup-dir'.

  PATH must be absolute."
    (let ((abs-startup-dir (file-name-as-directory (expand-file-name emacs-startup-dir))))
      (if (s-starts-with-p abs-startup-dir path)
          (s-chop-prefix abs-startup-dir path)
        nil)))

  (defun arv/org-ecfg--link-at-point-get-range ()
    "Returns a list with the start and end position for the link at
  point. A link is delimited by blanks and beggining/end of line."
    (let ((start (save-excursion
                   (skip-syntax-backward "^-" (line-beginning-position))
                   (point)))
          (end (save-excursion
                 (skip-syntax-forward "^-" (line-end-position))
                 (point))))
      (list start end)))

  (defun arv/org-ecfg-open (path)
    "Visit the file within `emacs-startup-dir'."
    (find-file (arv/path-join emacs-startup-dir path)))

  (defun arv/org-ecfg-store-link ()
    "Store a link to an emacs config file."
    (let ((link (arv/org-ecfg--relativize-to-startup-dir-maybe (buffer-file-name))))
      (when link
        (org-store-link-props
         :type "ecfg"
         :link (concat "ecfg:" link)
         :description (format "%s" link)))))

  (defvar arv/org-ecfg-insert-link-at-point-history nil)

  (defun arv/org-ecfg-insert-link-at-point (arg)
    "Insert a ecfg link using the text around the point. By default
  the description part is the same as the text. Use the prefix
  command in order to edit the description."
    (interactive "*P")
    (let* ((range (if mark-active
                      (list (point) (mark))
                    (arv/org-ecfg--link-at-point-get-range)))
           (text (apply 'buffer-substring-no-properties range))
           (link (if (s-starts-with-p "ecfg:" text)
                     text
                   (concat "ecfg:" text)))
           (description (if (s-starts-with-p "ecfg:" text)
                            (mapconcat 'identity (cdr (s-split ":" text)) ":")
                          text)))
      (if mark-active
          (deactivate-mark))
      (if arg
          (setq description (read-from-minibuffer "Description:" description
                                                  nil nil
                                                  'arv/org-ecfg-insert-link-at-point-history)))
      (apply 'delete-region range)
      (insert (format "[[%s][%s]]" link description))))
#+end_src

Funcionalitat relacionada amb el seguiment del temps invertit en
tasques, gesti贸 de interrupcions etc. Maig vaig aconsseguir
integrar-ho en el workflow.

#+begin_src emacs-lisp :tangle no
  ;;; state change and clock
  ;;
  ;; I want the clock to automatically start/stop clocking whenever a
  ;; task's state changes.
  ;;
  ;; Entering a state may trigger an action:
  ;;
  ;; - start: start clocking the current task. Clock-out the active task
  ;;   if any.
  ;;
  ;; - stop: stop clocking, but only if the current task is the active
  ;;   task. That's required in order to ensure that changing a task
  ;;   from a /paused/ state to other /paused/ state (from PAUSE to WAIT
  ;;   btw) does not clocks-out the active task,
  ;;
  ;; The mapping between states and actions is stored in the alist
  ;; `arv/org-sctc-entering-state-clocking-actions'. If an state is
  ;; missing or its associated action is nil then no action is performed
  ;; when it's entered.
  ;;
  ;; In case a task is being paused as a consequence of other being
  ;; started it will be put in the state defined in the variable
  ;; `arv/org-sctc-paused-state'.
  ;;
  ;; In order to enable that functionalitty call `arv/org-sctc-setup'
  ;; with no argument or nil. Passing an argument other than nil will
  ;; disable it.

  (defvar arv/org-sctc-entering-state-clocking-actions nil
    "alist mapping states to actions.")

  (defvar arv/org-sctc-paused-state nil
    "Stated for the task being paused.")


  (defvar arv/org-sctc--previous-active-task-marker nil)

  (defun arv/org-sctc--get-state-action (to)
    (cdr (assoc to arv/org-sctc-entering-state-clocking-actions)))

  (defun arv/org-sctc--pause-other-task ()
    (when arv/org-sctc--previous-active-task-marker
      (unwind-protect
          (save-excursion
            (goto-char arv/org-sctc--previous-active-task-marker)
            ;; IMPORTANT: calling org-todo may produce infinite
            ;; recursion, be careful when changing the code!!
            (org-todo arv/org-sctc-paused-state))
        (progn
          (set-marker arv/org-sctc--previous-active-task-marker nil)
          (setq arv/org-sctc--previous-active-task-marker nil)
          (remove-hook 'post-command-hook 'arv/org-sctc--pause-other-task)))))

  (defun arv/org-sctc--state-change (from to)
    (when (and (null arv/org-sctc--previous-active-task-marker)
               (not (string= from to)))
      (let ((action (arv/org-sctc--get-state-action to)))
        (unless (null action)
          (cond
           ((eq action 'start)
            (when (org-clock-is-active)
              (setq arv/org-sctc--previous-active-task-marker (copy-marker org-clock-marker))
              (org-clock-out)
              (add-hook 'post-command-hook 'arv/org-sctc--pause-other-task 'append))
            (org-clock-in))
           ((eq action 'stop)
            (let ((org-state "DONE") ;; hackish, review!!
                  (org-clock-out-when-done t))
              (org-clock-out-if-current)))
           (t (user-error "Unknown action.")))))))

  (defun arv/org-sctc--state-change-callback (p)
    (let ((type (plist-get p :type))
          (from (plist-get p :from))
          (to   (plist-get p :to)))
      (when (eq type 'todo-state-change)
        (arv/org-sctc--state-change from to))))

  (defun arv/org-sctc-setup (&optional disable)
    (if disable
        (remove-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)
      (add-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)))

  ;;; Interruption handling
  ;;
  ;; I want to be able to track interruptions and resume interrupted
  ;; tasks.
  ;;
  ;; Execute `arv/org-interrupt-interrupt-active-task' to put the active
  ;; task in hold, pause the clock and start capturing.
  ;;
  ;; Execute `arv/org-interrupt-resume-last-active-task' to resume the
  ;; last interrupted task, if any.

  (defvar arv/org-interrupt-resumed-state nil
    "State to put the task on when resuming after an
  interruption.")

  (defvar arv/org-interrupt-interrupted-state nil
    "State to put the task on when interrupted.")

  (defvar arv/org-interrupt-capture-key nil
    "Key for the capture template used by the interruption.")

  (defvar arv/org-interrupt--last-active-task nil
    "Private")

  (defun arv/org-interrupt-interrupt-active-task ()
    "Interrupts the active task (if any) and starts capturing an
  interruption.

  If there's an active task its ID is saved in the variable
  `arv/org-interrupt--last-active-task'."
    (interactive)
    (save-excursion
     (when (org-clock-is-active)
       (org-clock-goto)
       (setq arv/org-interrupt--last-active-task (org-id-get-create))
       (org-todo arv/org-interrupt-interrupted-state)))
    (org-capture nil arv/org-interrupt-capture-key))

  (defun arv/org-interrupt-resume-last-active-task ()
    "If there's an interrupted task jump to it and start it again.

  Currently this function relies on the value of the variable
  `arv/org-interrupt--last-active-task' in order to locate the
  interrupted task. The value of this variable won't survive
  restarting emacs and won't be saved."
    (interactive)
    (when arv/org-interrupt--last-active-task
      (org-id-goto arv/org-interrupt--last-active-task)
      (setq arv/org-interrupt--last-active-task nil)
      (org-todo arv/org-interrupt-resumed-state)))
#+end_src

*** =arv-template=

=arv-template= aprofita =yasnippet= per oferir plantilles amb
contingut inicial al crear nous arxius.

El funcionament es basa en que quan es crea un nou buffer, si compleix
certes condicions (estar buid, tindre associat un fitxer etc.),
s'insereix el text =header= (configurable en la variable
=arv/template-snippet-key=) i s'utilitza =yasnippet= per expandir-lo.

Per utilitzar-lo nom茅s cal crear /snippets/ amb la clau (=key=)
=header=.

**** Codi

This works by letting =yasnippet= expand the value of the customizable
variable =arv/template-snippet-key= (=header= by default) whenever
visiting a new file.

Two questions arise:

- when to insert/expand the key?

- what to do if the expansion fails?

In order to find the right snippet the buffer must be already in the
right major mode. My first attempt was hooking a function to
=find-file-not-found-functions=, but this didn't work because at that
point the buffer is still in =fundamental-mode=.

So I have decided to track the mode changes using
=after-change-major-mode-hook=, this has a couple of drawbacks:

- apparently a newly created buffer is put in =fundamental-mode= and
  then switched to its final mode, so the functions hooked to
  =after-change-major-mode-hook= should account for being called at
  least twice.

- the function must determine by itself if the buffer is visiting a
  new file or an existing one.

Finally, if the expansion fails the key ("header") must be removed. At
first I tried with =undo= but emacs complained "no further undo
information" so I decided to explicitly delete the key.

#+begin_src emacs-lisp :tangle yes
  (defgroup arv/template nil
    "Insert documentation here."
    :group 'arv)

  (defcustom arv/template-snippet-key "header"
    "Name of the snippet."
    :group 'arv/template
    :type  'string
    :safe  'stringp)


  (defun arv/template-insert-header ()
    (when (and (not buffer-read-only)
               (not (eq major-mode 'fundamental-mode))
               (buffer-file-name)
               (save-excursion (goto-char (point-min))
                               (eobp)) ; empty buffer?
               (not (file-exists-p (buffer-file-name))))
      (let ((pos (point)))
        (insert arv/template-snippet-key)
        (unless (yas-expand-from-trigger-key)
          (goto-char pos)
          (delete-char (length arv/template-snippet-key) nil)
          (set-buffer-modified-p nil)))))


  (defun arv/template-setup ()
    (add-hook 'after-change-major-mode-hook 'arv/template-insert-header))
#+end_src

**** Instal路laci贸/activaci贸

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'yas-snippet-dirs
               (arv/path-concat arv/emacs-conf-dir "shared" "templates"))
  (arv/template-setup)
#+end_src

*** =arv-test=

Helpers per simplificar els tests. Molt probablement existir una
biblioteca que proveeixi aquesta funcionalitat.

#+begin_src emacs-lisp :tangle yes
  (defun arv-test--mk-buffer (&optional content mode point-marker)
    "Creates a buffer with the given content, mode and point."
    (let ((buffer (generate-new-buffer "*test_buffer*")))
      (with-current-buffer buffer
        (when content
          (insert content))
        (when point-marker
          (goto-char (point-min))
          (when (search-forward point-marker)
            (delete-char (- (length point-marker)))))
        buffer)))

  (defmacro arv-test-with-buffer (content mode point-marker &rest body)
    (declare (indent 1) (debug t))
    `(save-current-buffer
       (set-buffer (arv-test--mk-buffer ,content ,mode ,point-marker))
       ,@body
       (kill-buffer)))
#+end_src

*** =arv-yasnippet=

Colecci贸 ca貌tica de funcions (i una variable) que faciliten la
definici贸 de snippets.

#+begin_src emacs-lisp :tangle yes
  (defvar django-widget-types '("CheckboxInput"
                                "CheckboxSelectMultiple"
                                "DateInput"
                                "DateTimeInput"
                                "FileInput"
                                "HiddenInput"
                                "MultipleHiddenInput"
                                "NullBooleanSelect"
                                "PasswordInput"
                                "RadioSelect"
                                "Select"
                                "SelectMultiple"
                                "Textarea"
                                "TextInput"
                                "TimeInput"))
#+end_src

Operacions amb cadenes:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-uncamelize (text sep)
    "Retorna text sense 'camelitzar'.

  Si 'text' es 'CamelCase' i 'sep' es '-' retorna 'camel-case'.

  Es suposa que 'text' es un identificador valid escrit en
  CamelCase. 'sep' es un string.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'downcase (s-split-words text) sep)))

  (defalias 'arv-yas-uncamelize 'arv/yas-uncamelize)

  (defun arv/yas-camelize (text)
    "Retorna TEXT 'camelitzat'.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'capitalize (s-split-words text) "")))

  (defun arv/yas-substring (text start end)
    "Retorna un substring.

  Esta versio de substring s'ajusta als limits i, a diferencia de
  substring, no produeix cap error si es sobrepassen.
  "
    (substring text (max 0 start) (min end (length text))))

  (defalias 'arv-yas-substring 'arv/yas-substring)

  (defun arv/string-strip-delimiters (text delimiters)
    "Strip trailing and leading chars from TEXT if they are equal
  and appear in the string DELIMITERS.

  \"+foo+\" \"$\" -> \"+foo+\"
  \"+foo+\" \"$+\" -> \"foo\"
  \"+foo-\" \"+-\" -> \"+foo-\"
  "
    (if (< (length text) 2)
        text
      (let ((delimiters (delete "" (split-string delimiters "")))
            (left-char (substring text 0 1))
            (right-char (substring text (1- (length text)))))
        (if (and (string= left-char right-char)
                 (member left-char delimiters))
            (substring text 1 (1- (length text)))
          text))))

  (defun arv/string-replace-unwanted-chars (value predicate &optional replacement)
    "Returns a string built replacing the chars from the string
  VALUE for whom the function PREDICATE returns nil with the string
  REPLACEMENT.

  If REPLACEMENT is omitted or nil the empty string is used as the
  replacement."
    (let ((replacement (or replacement "")))
      (mapconcat (lambda (x) (cond
                         ((string= x "") "")
                         ((funcall predicate x) x)
                         (t replacement)))
                 (split-string value "")
                 "")))
#+end_src

Funcions especialitzades en codi javascript:

#+begin_src emacs-lisp :tangle yes
  (defun arv/js-make-identifier (text)
    "Replace invalid chars from TEXT with an underscore in order to
  make a valid javascrip identifier."
    (let ((result (arv/string-replace-unwanted-chars
                   text (lambda (x) (string-match "[$a-zA-Z0-9_]" x)) "_")))
      (if (string-match "^[$a-zA-Z_]" result)
          result
        (concat "_" result))))

  (defun arv/yas-js-amd-params-from-modules (text)
    "Given the modules of and AMD `define' generates the names of
  the corresponding function parametres.

  '\"dojo/foo\", \"digit/a_plugin!parameters\"' -> 'foo, a_plugin'
  "
    (s-join ", " (mapcar (lambda (x) (arv/js-make-identifier (car (last (s-split "/" (car (s-split "!" (arv/string-strip-delimiters (s-trim x) "'\""))))))))
                         (s-split "," text))))

  (defun arv/yas-js-get-parameter-names (text)
    (delete "" (mapcar 's-trim (split-string text ","))))

  (defun arv/yas-js-function-parameters-documentation (text &optional header)
    (let ((header (or header "Parameters"))
          (params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (- (current-column) 2) 32) "// ")))
      (if params
          (concat indent
                  header
                  indent
                  (mapconcat (lambda (x) (format "- %s : " x)) params indent))
        "")))

  (defun arv/yas-js-function-store-parameters (text)
    (let ((params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (current-column) 32))))
      (if params
          (concat indent
                  (mapconcat (lambda (x) (format "this._%s = %s;" x x)) params indent))
        "")))
#+end_src

Funcions especialitzades en codi python:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-py-parse-parameters (text)
   "Parseja els arguments d'una funci铆/m猫tode.

  'foo, bar=value' -> (('foo') ('bar' 'value'))"
     (mapcar (lambda (x)
               (mapcar 's-trim (split-string x "=")))
             (split-string text ",")))

  (defalias 'arv-yas-py-parse-parameters 'arv/yas-py-parse-parameters)


  (defun arv/yas-py-get-parameter-names (text &optional exclude)
    "Retorna el nom dels parmetres.

  Mira de netejar anomalies com parametres sense nom. Si
  s'especifica un valor diferent de `nil' per `exclude' s'exclouen
  el parmetres '*args' i '**kw' si estan presents (es comprova que
  comencin per * no el nom concret).

  'foo, bar=value' -> ('foo', 'bar')
  'foo,, bar=value' -> ('foo', 'bar')
  'foo, bar=value, *args' -> ('foo', 'bar', '*args')

  Especificant `exclude':

  'foo, bar=value, *args' -> ('foo', 'bar')"
    (delq nil
          (mapcar (lambda (x)
                    (let ((name (nth 0 x)))
                      (unless (or (string= name "")
                                  (and (not (null exclude))
                                       (s-starts-with-p "*" name)))
                        name)))
                  (arv-yas-py-parse-parameters text))))

  (defalias 'arv-yas-py-get-parameter-names 'arv/yas-py-get-parameter-names)


  (defun arv/yas-py-function-parameters-documentation (text)
    "Retorna la documentaci贸 pels parmetres d'una funci贸.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    :param foo:
    :param bar:
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat ":param " x ":"))
       (arv-yas-py-get-parameter-names text 't)
       indent)))

  (defalias 'arv-yas-py-function-parameters-documentation 'arv/yas-py-function-parameters-documentation)


  (defun arv/yas-py-constructor-store-arguments (text)
    "Retorna l'assignaci贸 a atributs en el constructor.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    self._foo = foo
    self._bar = bar
    self._args = args
    self._kw = kw
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat "self._" x " = " x))
       (mapcar
        (lambda (x)
          (s-chop-prefix "*" (s-chop-prefix "*" x)))
        (arv-yas-py-get-parameter-names text))
       indent)))

  (defalias 'arv-yas-py-constructor-store-arguments 'arv/yas-py-constructor-store-arguments)
#+end_src

Funcions especialitzades en codi sh:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-sh-getopt-case-options (text)
    "Retorna les opcions de 'case'.

  Converteix:

      a:b

  en:

      a) OPT_A=$OPTARG ;;
      b) OPT_B=1 ;;
  "
    (let ((indent (concat "\n" (make-string (current-column) 32)))
          (result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (and (> (length text) 1) (char-equal (aref text 1) ?:))
              (progn
                (setq text (substring text 2))
                (setq result (cons (format "%s) OPT_%s=$OPTARG ;;" char CHAR) result)))
            (setq result (cons (format "%s) OPT_%s=1 ;;" char CHAR) result))
            (setq text (substring text 1))
            )))
      (concat indent
              (mapconcat (lambda (x) x) (reverse result) indent))))

  (defun arv/yas-sh-getopt-var-declaration (text)
    "Retorna les variables.

  Converteix:

      a:b

  en:

      OPT_A=
      OPT_B=
  "
    (let ((result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (not (string-equal char ":"))
              (setq result (cons (format "OPT_%s=" CHAR) result)))
          (setq text (substring text 1))))
      (mapconcat (lambda (x) x) (reverse result) "\n")))
#+end_src

Funcions variades:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-today (&optional fmt)
    (let ((fmt (or fmt "%Y-%m-%d")))
      (format-time-string fmt)))

  (defun arv/yas-year ()
    (format-time-string "%Y"))

  (defun arv/yas-buffer-name ()
    (file-name-nondirectory (buffer-file-name)))

  (defun arv/yas-buffer-name-upcase ()
    (upcase (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans ()
    (file-name-sans-extension (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans-upcase ()
    (upcase (arv/yas-buffer-name-sans)))

  (defun arv/yas-buffer-name-sans-camelcase ()
    (arv/yas-camelize (arv/yas-buffer-name-sans)))

  (defun arv/yas-author-name ()
    user-full-name)

  (defun arv/yas-author-email ()
    user-mail-address)
#+end_src

** Combinacions de tecles globals

Aquest apartat 茅s un copiar/enganxar de la configuraci贸 original. En
aquest punt moltes de les comandes no estan definides, d'altres s贸n
redundants o mai les he arribat a incorporar en el /workflow/.

#+begin_src emacs-lisp :tangle yes
  ;; disable some keybindings

  ;; disable arrow  keys
  ;; (progn
  ;;   (global-unset-key (kbd "<up>"))
  ;;   (global-unset-key (kbd "<down>"))
  ;;   (global-unset-key (kbd "<left>"))
  ;;   (global-unset-key (kbd "<right>"))
  ;;   (global-unset-key (kbd "C-<up>"))
  ;;   (global-unset-key (kbd "C-<down>"))
  ;;   (global-unset-key (kbd "C-<left>"))
  ;;   (global-unset-key (kbd "C-<right>"))
  ;;   (global-unset-key (kbd "M-<up>"))
  ;;   (global-unset-key (kbd "M-<down>"))
  ;;   (global-unset-key (kbd "M-<left>"))
  ;;   (global-unset-key (kbd "M-<right>")))

  ;; (progn
  ;;   (global-set-key (kbd "M-n") 'forward-paragraph)
  ;;   (global-set-key (kbd "M-p") 'backward-paragraph))

  ;; ocasionally I press C-x C-c by accident, define a more complex
  ;; keybinding to kill emacs
  (global-unset-key (kbd "C-x C-c"))
  (global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)

  ;; On X11 C-z serves no purpose since the wm defines keybindings to
  ;; minimize windows. OTOH is very annoying when pressed by
  ;; accident. In any case C-x C-z is still available.
  (when (display-graphic-p)
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z") 'shell))


  ;; emacs overrides
  ;; (global-set-key (kbd "C-s") #'endless/isearch-symbol-with-prefix)
  (global-set-key (kbd "C-x 2") #'arv/split-windows-bellow)
  (global-set-key (kbd "C-x 3") #'arv/split-windows-right)

  (global-set-key (kbd "C-o") #'arv/open-line-before-and-indent)
  (global-set-key (kbd "C-S-o") #'arv/open-line-after-and-indent)

  ;; let's give a try to swiper
  (global-set-key (kbd "C-s") 'arv/swiper-symbol-with-prefix)
  (global-set-key (kbd "C-S-s") 'isearch-forward)

  (global-set-key (kbd "M-z") 'zap-up-to-char)

  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "M-u") 'arv/upcase-word)
  (global-set-key (kbd "M-l") 'arv/downcase-word)
  (global-set-key (kbd "M-;") 'endless/comment-line-or-region)


  (global-set-key (kbd "s-y") 'arv/duplicate-line-or-region-dwim)
  (global-set-key (kbd "C-M-y") 'arv/duplicate-line-or-region-and-comment-dwim)


  ;; other bindings

  (global-set-key (kbd "<f1>") (lambda () (interactive) (info)))
  (global-set-key (kbd "C-<f1>") (lambda () (interactive) (info "emacs")))
  (global-set-key (kbd "<f7>") 'next-error)
  (global-set-key (kbd "<f8>") 'previous-error)
  (global-set-key (kbd "<f9>") 'compile)

  (global-set-key (kbd "s-g") 'arv/goto-line)
  ;;; es un incordio tener que teclear yes para confirmar
  (global-set-key (kbd "C-<return>") "yes\C-m")

  (global-set-key (kbd "M-%") 'arv/query-replace)
  (global-set-key (kbd "M-w") 'arv/kill-ring-save-word-at-point)

  (global-set-key (kbd "C-<tab>") 'dabbrev-expand)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
                                          ; Una altra alternativa si
                                          ; aquesta no em conven莽 茅s
                                          ; buffer-menu

  ;; insert map

  (global-set-key (kbd "C-c i l") 'lorem-ipsum-insert-paragraphs)
  (global-set-key (kbd "C-c i L") 'lorem-ipsum-insert-sentences)
  (global-set-key (kbd "C-c i f") 'figlet)
  (global-set-key (kbd "C-c i F") 'figlet-no-comment)
  (global-set-key (kbd "C-c i u") 'arv/insert-random-uuid)

  ;; jump map

  (global-set-key (kbd "C-c j c") 'avy-goto-char-2)
  (global-set-key (kbd "C-c j e") 'arv/visit-emacs-config)
  (global-set-key (kbd "C-c j l") 'avy-goto-line)
  (global-set-key (kbd "C-c j s") 'imenu)
  (global-set-key (kbd "C-c j w") 'avy-goto-word-1)

  ;; embrace
  (global-set-key (kbd "C--") 'embrace-commander)

  ;; grin
  (global-set-key (kbd "C-莽") 'arv/grin)

  ;; keybindings per subversion: C-c s
  (global-set-key (kbd "C-c s =") 'svn-file-show-svn-diff)
  (global-set-key (kbd "C-c s l") 'svn-status-show-svn-log)
  (global-set-key (kbd "C-c s s") 'svn-status)

  ;; keybindings per magit: C-c g
  (global-set-key (kbd "C-c g s") 'magit-status)

  ;; expand-region
  (global-set-key (kbd "C-.") 'er/expand-region)

  ;; multi-line
  (global-set-key (kbd "C-c r m") 'multi-line)

  ;; find-file-in-project
  (global-set-key (kbd "C-x f") 'find-file-in-project)

  ;; org
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c o s") 'org-sort)

  ;; smex
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; toggle map
  (global-set-key (kbd "C-c t c") 'column-number-mode)
  (global-set-key (kbd "C-c t B") 'arv/alternar-mida-font)
  (global-set-key (kbd "C-c t f") 'auto-fill-mode)
  (global-set-key (kbd "C-c t F") 'toggle-fullscreen)
  (global-set-key (kbd "C-c t l") 'linum-mode)
  (global-set-key (kbd "C-c t L") 'line-number-mode)
  (global-set-key (kbd "C-c t r") 'read-only-mode)

  ;; word-mode
  (global-set-key (kbd"C-,") 'arv/wm-cycle)

  (global-set-key (kbd "C-c b b") 'bjm-comment-box)

#+end_src

** hydras

Pel moment definir茅 les hidres ac铆. La idea 茅s utilitzar-les per fer
accessibles comandes relacionades que em resulten 煤tils per貌 utilitzo
tan ocasionalment que no recordo les tecles. Per facilitar-ho es
definiran dins el mapa =C-c h=.

*** smerge

El paquet =smerge= facilita resoldre conflictes al fer un merge en un
control de revisions.

L'origen d'aquesta hydra 茅s un [[https://irreal.org/blog/?p=5651][post de Irreal]].

#+begin_src emacs-lisp
  (defhydra hydra-smerge
    (:color red :hint nil :pre (smerge-mode 1))
    "
  ^Move^    ^Keep^    ^Diff^    ^Pair^
  ------------------------------------------------------
  _n_ext    _b_ase    _R_efine  _<_: base-mine
  _p_rev    _m_ine    _E_diff   _=_: mine-other
  ^ ^       _o_ther   _C_ombine _>_: base-other
  ^ ^       _a_ll     _r_esolve
  _q_uit    _RET_: current
  "
    ("RET" smerge-keep-current)
    ("C" smerge-combine-with-next)
    ("E" smerge-ediff)
    ("R" smerge-refine)
    ("a" smerge-keep-all)
    ("b" smerge-keep-base)
    ("m" smerge-keep-mine)
    ("n" smerge-next)
    ("o" smerge-keep-other)
    ("p" smerge-prev)
    ("r" smerge-resolve)
    ("<" smerge-diff-base-mine)
    ("=" smerge-diff-mine-other)
    (">" smerge-diff-base-other)
    ("q" nil :color blue))

  (global-set-key (kbd "C-c h s") 'hydra-smerge/body)
#+end_src

* Parxes

Recull de parxes que resolen incompatibilitats etc. La idea 茅s
agrupar-los ac铆 per facilitar localitzar-los i eliminar-los quan
estiguin resolts.

Estaria b茅 afegir alarmes per comprovar si ja hi ha una soluci贸.

- 20180601: Corregeix [[https://github.com/jorgenschaefer/elpy/issues/1379][un error amb emacs 26.1 i elpy 1.21]]: =M-x= salta
  a un TAG, no utilitza la funcionalitat de =elpy=.

  #+begin_src emacs-lisp :tangle yes
    (with-eval-after-load 'elpy
      (when (and (string= emacs-version "26.1")
                 (string= elpy-version "1.21.0"))
        (defun elpy--xref-backend ()
          "Return the name of the elpy xref backend."
          (if (or (and (not (elpy-rpc--process-buffer-p elpy-rpc--buffer))
                       (elpy-rpc--get-rpc-buffer))
                  elpy-rpc--jedi-available)
              'elpy
            nil))))
  #+end_src

- 20180818: amb emacs 26 el comportament de =hi-lock= no 茅s el mateix
  que amb la versi贸 25: sembla que nom茅s ressalta els elements que hi
  ha al obrir l'arxiu, no els que s'afegeixen posteriorment.

  Veure comentari/soluci贸 en el [[target-prog-mode-hook][hook que configura =hi-lock=]].

  El parxe sembla /correcte/ per貌 no estic segur. Investigar-ho amb
  m茅s calma.

* Incubadora

Noves funcionalitats que estic provant. Si em convencen es mouen a
l'apartat /Configuraci贸/.

En aquest apartat l'organitzaci贸 茅s la inversa, tot va dins una
subsecci贸 per tractar cada nova funcionalitat com un tot. Si
s'accepta, el contingut es distribueix on correspongui.

All铆 on tingui sentit, el nom dels elements haurien de comen莽ar amb el
prefix =x-arv= per identificar que son experimentals. Probablement amb
la API p煤blica (comandes?) sigui suficient.

** =winner-mode=

En general no el veig prctic per貌 hi ha un cas d'煤s en que podria ser
煤til: quan s'obre una finestra tipus ajuda, compilaci贸 etc. i la vull
fer desapareixer.

#+begin_src emacs-lisp :tangle yes
  (use-package winner
    :commands winner-mode
    :config
    (setq winner-ring-size 50)
    (setq winner-boring-buffers '("*Apropos*"
                                  "*Buffer List*"
                                  "*Compile-Log*"
                                  "*Completions*"
                                  "*grep*"
                                  "*Help*"
                                  "*hera-events*"
                                  "*Occur*"
                                  "*pytest*"
                                  "*svn-diff*"
                                  "*svn-info*"
                                  "*svn-info-output*"
                                  "*svn-log*"
                                  "*svn-log-edit*"
                                  "*svn-property-edit*"
                                  )))
#+end_src

A莽貌 anir en alguna secci贸 /global/.

#+begin_src emacs-lisp :tangle yes
  (winner-mode t)
#+end_src

** =arv/camelize=

De vegades vull convertir =foo_bar= en =FooBar= i al rev茅s:

#+begin_src emacs-lisp :tangle yes
  (defun x-my/camelize ()
    (interactive)
    (when (looking-at-p "\\sw\\|\\s_")
      (let* ((begin (save-excursion
                      (while (and (not (bobp)) (looking-back "\\sw\\|\\s_"))
                        (backward-word))
                      (point)))
             (end (save-excursion
                    (while (and (not (eobp)) (looking-at "\\sw\\|\\s_"))
                      (forward-word))
                    (point)))
             (text (buffer-substring-no-properties begin end))
             (replacement (with-syntax-table (standard-syntax-table)
                            (if (and (string-match-p "^\\sw+$" text)
                                     (s-mixedcase-p text))
                                ;; CamelCase -> camel_case
                                (mapconcat 'downcase (s-split-words text) "_")
                              ;; camel_case -> CamelCase
                              (mapconcat 'capitalize (s-split-words text) "")
                              ))))
        (save-excursion
          (goto-char begin)
          (delete-region begin end)
          (insert replacement)
          )
        )))
#+end_src

El separador est fixat al codi per貌 pel moment 茅s suficientment b贸.
El provar茅 en =python-mode= per veure que tal. Si resulta 煤til acabar茅
de polir-la.

En certa forma a莽貌 茅s una generalitzaci贸 de =capitalize=:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "M-c") 'x-my/camelize)
#+end_src

** repetici贸 de comandes

Pot resultar prctic per貌 no acabo de trobar un 煤s.

- [[https://github.com/myuhe/smartrep.el][smartrep.el]]: support sequential operation which omit prefix key.
  Latest commit f0ff5a6 on 9 May 2015.

  #+begin_src emacs-lisp :tangle no
    (smartrep-define-key
     global-map "M-g"
     '(("n" . next-line)
       ("p" . previous-line)))
  #+end_src

- [[https://github.com/abo-abo/hydra][hydra]]: make Emacs bindings that stick around. Latest commit 62e0f37
  on 27 Feb 2018.

  #+begin_src emacs-lisp :tangle no
    (use-package hydra
      :ensure t
      :config
      (defhydra hydra-zoom (global-map "C-c r")
        "multi-line"
        ("m" multi-line)))
  #+end_src

- configuraci贸 de Sacha Chuar: based on
  http://oremacs.com/2015/01/14/repeatable-commands/ . Modified to
  accept =nil= as the first value if you don't want the keymap to run
  a command by default, and to use =kbd= for the keybinding
  definitions.

  #+begin_src emacs-lisp :tangle no
    (defun my/def-rep-command (alist)
      "Return a lambda that calls the first function of ALIST.
    It sets the transient map to all functions of ALIST,
    allowing you to repeat those functions as needed."
      (let ((keymap (make-sparse-keymap))
            (func (cdar alist)))
        (mapc (lambda (x)
                (when x
                  (define-key keymap (kbd (car x)) (cdr x))))
              alist)
        (lambda (arg)
          (interactive "p")
          (when func
            (funcall func arg))
          (set-transient-map keymap t))))
  #+end_src

** /Unfill/ pargraf

De vegades, al enganxar un pargraf, =M-q= no fal el que vull i l'he
de convertir en una 煤nica l铆nia (a base de =C-e SUPR SPC=) o corregir
el sagnat manualment per tornar a ajustar-lo. Per exemple:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
  facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
  quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
  Sed bibendum.
#+end_example

Aquesta comanda, copiada de la configuraci贸 de Sacha Chua, automatitza
aquesta transformaci贸:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum.
#+end_example

i el pargraf resultat ara es pot ajustar satisfactoriament amb =M-q=:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
    facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
    quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
    Sed bibendum.
#+end_example

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (bind-key "M-Q" 'my/unfill-paragraph)
#+END_SRC

En funci贸 de l'煤s que en fci potser valdria la pena definir una
comanda equivalment a =M-Q M-q=.

* Descartat

Funcionalitats experimental que no he acosseguit /interioritzar/.

** Inici de l铆nia

Copiat de
http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/:

#+begin_src emacs-lisp :tangle no
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+end_src

#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "C-a") #'my/smarter-move-beginning-of-line)
#+end_src

** Desactivar tecles del cursor

Porto massa anys utilitzant les tecles del cursor i he desenvolupat
habits per mourem rpidament amb elles. El canvi em trenca massa el
ritme de treball i resulta frustrant.

L'objectiu 茅s acostumar-me a no utilitzar les tecles del cursor pels
despla莽aments i no haver de moure la ma fora de la /fila principal/.

#+begin_src emacs-lisp :tangle no
  (defun comanda-desactivada ()
    (interactive)
    (let ((visible-bell t))
      (ding)))

  (global-set-key (kbd "<up>") #'comanda-desactivada)
  (global-set-key (kbd "<down>") #'comanda-desactivada)
  (global-set-key (kbd "<left>") #'comanda-desactivada)
  (global-set-key (kbd "<right>") #'comanda-desactivada)
#+end_src

* Per mirar
** =define-compilation-mode=

En alguns m貌duls utilitzo buffers de compilaci贸 per mostrar el
resultat d'executar una comanda externa (p.e. llistar events i
subscriptors en Hera). Mirar si aquesta macro aporta cap avantatge.

** ressaltar insert/overwrite en la modeline

Ressaltar el mode insert/overwrite en la modeline utiltizant un color
de fons. Actualment /insert/ no es visualitza.

** revisar les [[info:elisp#Coding%20Conventions][info:elisp#Coding Conventions]].
** [[https://melpa.org/#/redshank][redshank]]

Common Lisp Editing Extensions. Espec铆ficament m'interesa la part que
permet refactoritzar codi.

** lpy

https://github.com/abo-abo/lpy/blob/master/lpy.el

This is an attempt to implement a variant of `lispy-mode'
(https://github.com/abo-abo/lispy) for Python. Unfortunately, Python
isn't nearly as well-structured as LISP. But Python is ubiquitous, and
the less powerful `lpy-mode' is better than nothing at all.

The basic idea of `lpy-mode' is to increase the editing efficiency by
binding useful navigation, refactoring and evaluation commands to
unprefixed keys, e.g. "j" or "e". But only in certain point positions,
so that you are still able to use uprefixed keys to insert themselves.

Example, here "|" represents the point position:

  print |("2+2=%d" % (2 + 2))

Here, if you press the key "e", the whole line will be evaluated and
"2+2=4" will be printed in the Echo Area. Note that if `lpy-mode' was
off, pressing "e" would instead result in:

  print e|("2+2=%d" % (2 + 2))

So inserting any key isn't actually useful with that point position
and e.g. the "e" can be used for evaluating the current statement.

But, for instance, if you wanted to edit "print" into "printe", you
could do that in a straightforward way, just like you would with
`lpy-mode' off : with "C-b e".
