#+TITLE: Configuraci贸 d'emacs d'Alexis Roda
#+OPTIONS: toc:4 h:4
#+STARTUP: overview

#+LANGUAGE: ca
#+LATEX_CLASS: informe

# Afegeix una refer猫ncia en l'arxiu ".el" que apunta al bloc de codi
# org. Veure la funci贸 "org-babel-tangle-jumpt-to-org".
#+PROPERTY: header-args:emacs-lisp    :padline true :comments link

#+begin_abstract
Aquesta 茅s la tercera encarnaci贸 de la configuraci贸 d'emacs. Els
objectius que es volen aconsseguir s贸n:

- reduir el temps de crrega.

- prendre el control del caos en que havia esdevingut la segona
  encarnaci贸 i mantindre una baixa entropia.

- automatitzar el desplegament de la configuraci贸 a nous sistemes.

Per貌 la veritat 茅s que 茅s divertit .
#+end_abstract

* Instal路laci贸

En teoria aquesta configuraci贸 hauria de funcionar amb emacs 24.4 o
posterior. En la prctica nom茅s est provada amb emacs 25.2.1 i
25.3.1.

Depend猫ncies: =git=, =make= i =makeinfo= (per instal路lar org). En
ubuntu el paquet /texinfo/ proveeix la comanda =makeinfo=.

#+begin_src sh :tangle no
  mkdir ~/.emacs.d
  cd ~/.emacs.d
  git clone https://github.com/patxoca/dot-emacs.git conf.d
  ln -s conf.d/init.el .
  emacs
#+end_src

#+begin_warning
Actualment 茅s *imprescindible* que el directori on es clona el
repositori sigui =conf.d=. Aquest valor est fixat en algunes parts de
la configuraci贸.
#+end_warning

Al executar /emacs/ sobre una copia de treball neta es generaran els
fitxers =settings.el= i =settings.sh=. El primer cont茅 la configuraci贸
d'/emacs/ i el segon comandes /sh/ per configurar l'entorn. A
continuaci贸 es carregar =settings.el= i per acabar s'executar
=settings.sh=.

El primer arranc pot trigar uns minuts, mentre es descarreguen i
instal路len tots els paquets.

En arrancs posteriors el fitxer =settings.el= s'actualitzar
automticament si s'ha fet cap canvi en aquest document.

El fitxer =settings.sh= mai s'actualitza, cal esborrar-lo i es
generar i executar novament en el seg眉ent arranc.

* Introducci贸

En aquest apartat es dona una visi贸 general de la configuraci贸 i es
detallen algunes guies/recomanacions per ajudar a mantindre la
consist猫ncia i un nivell baix de caos.

** Versi贸 de org

La configuraci贸 dep猫n de que /org/ estigui instal路lat, concretament el
m貌dul /babel/, per extreure (/tangle/) els blocs de codi i generar
l'arxiu de configuraci贸 /real/ (=settings.el=).

Cal que aquesta configuraci贸 /sigui compatible/, almenys pel que
respecta a l'extracci贸 dels blocs de codi, amb la versi贸 de /org/ que
s'utilitzar durant el /bootstrap/. En cas de problemes caldr
actualitzar la versi贸 de /org/.

Durant el primer arranc es descarregar el codi font de /org/ i
s'instal路lar baix la jerarquia de directoris =~/.local=. En els
arrancs subseq眉ents s'utilitzar la nova versi贸.

** Configuraci贸 de paquets

La configuraci贸 dels paquets nom茅s pot incloure modificaci贸 d'elements
definits pel propi paquet. No pot definir tecles globals, no pot
activar cap funcionalitat etc.

La idea 茅s mantindre la localitat separant responsabilitats.

Actualment alguns paquets no ho compleixen.

** Configuraci贸 de modes

Un mode en ess猫ncia 茅s un paquet per貌 en aquest punt encara no he
decidit com organitzar-ho.

Tampoc he decidit si tots paquets han d'anar a la mateixa secci贸 o
poden apareixer en la secci贸 del mode en que s'utilitzen (com est
ara).

** Blocs de codi sh

Un dels objectius 茅s automatitzar la configuraci贸 inicial de l'entorn.
Una de les eines utilitzades per aconsseguir-ho s贸n el blocs de codi
/sh/.

Els bloc /sh/ s'utilitzen en varis contexts:

- s'insereixen en un arxiu per formar un 煤nic script =settings.sh=.
  Aquest script ser executat automticament durant el primer arranc
  d'emacs.

- s'avaluen individualment des del propi document. Per exemple, quan
  s'afegeix un nou paquet a la configuraci贸 i cal instal路lar-lo
  avaluant el bloc de codi.

- en un sistema ja configurat en el que s'ha esborrat l'arxiu
  =settings.sh=. s igual que el punt 1 per貌 l'entorn ja est
  configurat.

Cal tindre cura al escriure aquests blocs de codi per tal de garantir
que funcionin en tots els contexts:

- cal preservar l'entorn d'execuci贸: si es modifica l'entorn
  d'execuci贸, en la modalitat /script/ (contexts 1 i 3), els canvis
  afectaran als blocs que s'executin a continuaci贸.

  En particular cal preservar el directori de treball. El codi pot
  assumir que el directori de treball 茅s =~/.emacs.d/conf.d=. Al
  finalitzar ha de restaurar el directori de treball (utilitzant
  =pushd= i =popd= enlloc de =cd=, per exemple).

- cal que sigui independent: el codi ha de funcionar tant si s'executa
  en modalitat /script/ com en modalitat /bloc/.

- cal que sigui idempotent: el codi pot executar-se m茅s d'una vegada i
  ha de funcionar corretament tant la primera com la resta.

El directori =scripts= cont茅 alguns scripts per simplificar les
tasques m茅s habituals:

- =clone_git=: =clone-git URL= clona un repositori git dins el
  directori =~/.emacs.d/site-lisp=. Si el repositori ja est clonat no
  fa res.

- =compile_package=: =compile_package NOM= compila els fitxers emacs
  lisp del directori =~/.emacs.d/site-lisp/<NOM>= i actualitza
  =~/.emacs.d/site-lisp/loaddefs.el=.

# Cap莽alera de l'arxiu generat a partir dels blocs de codi sh:

#+begin_src sh :tangle yes :exports none
  #!/bin/bash

  cd ~/.emacs.d/conf.d

#+end_src

** Tecles i /keymaps/ personalitzats

Cal definir els keymaps i regles generals per organitzar les
definicions de tecles globals i per modes.

Agrupar les tecles globals tenia sentit quan la configuraci贸 estava
repartida entre varis m貌duls. Al agrupar-la tota en un 煤nic document
=org= potser resulta m茅s clar moure les assignacions de tecles al
corresponent =use-package=. No m'acaba d'agradar.

Pel que fa als keymaps /locals/ hi ha varies opcions:

- en =use-package= 煤nicament es poden modificar tecles ja definides
  pel pr貌pi paquet.

- en =use-package= es pot modificar el /keymap/ local, sempre que el
  comandes siguin locals.

- altres?


#+BEGIN_QUOTE
Reconfiguracio de tecles globalment.  Per evitar conflictes, els
comandos personals els configuro sota el prefix C-c C-a i segueixo el
conveni de que els moduls que escric defineixen el seu propi
"subespai" de tecles (p.e. todo.el utilitza C-c C-a C-r).
#+END_QUOTE

** Directori =site-lisp=

Desenvolupar.

Dos directoris =site-lisp=, que ficar en cadascun, no abusar. Gesti贸.

* Configuraci贸
** /Lexical binding/

El /lexical binding/ permet utilitzar clausures.

#+begin_src emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
#+end_src

** Depuraci贸 de la configuraci贸

Ocasionalment a莽貌 pot ajudar a depurar errors en la configuraci贸.

Per activar-ho cal canviar a =:tangle yes=.

#+begin_src emacs-lisp :tangle no
  (setq debug-on-error t)
#+end_src


** Inicialitzaci贸

Aquesta secci贸 definex la base sobre la que s'implementen la resta de
les seccions.

*** Funcions auxiliars

Funcions utilitzades en la pr貌pia configuraci贸. Aquestes funcions no
poden dependre de biblioteques de tercers i no proveeixen
funcionalitat utilitzable directament per l'usuari, 煤nicament per la
configuraci贸. Les comandes d'usuari van en la secci贸 [[id:02df8b30-de79-489f-b4c9-13162d5d2784][Comandes]].

**** =my/bind-keys=

No tinc clar quin /keymap/ es afectat per la clausula =:bind= de
=use-package=, la q眉esti贸 茅s que en alguns casos (configuraci贸 de
=paredit= p.e.) no acaba de funcionar com espero.

La funci贸 =my/bind-keys= intenta fer menys verbosa la definici贸 de
les tecles quan no queda m茅s remei que fer-ho manualment.

#+begin_src emacs-lisp :tangle yes
  (defun my/bind-keys (map key-definitions)
    (dolist (item key-definitions)
      (let ((key (car item))
            (command (cadr item)))
        (define-key map (kbd key) command))))
#+end_src

Exemple:

#+begin_src emacs-lisp :tangle no
  (my/bind-keys some-mode-map
                '(("C-c f" do-foo)
                  ("C-c b" do-bar)))
#+end_src

**** =my/host-reachable=

Comprova si un host est disponible. La disponibilitat es determina
fent un ping.

S'utilitza principalment per condicionar parts de la configuraci贸 a la
disponibilitat de serveis en la xarxa local. Per exemple, a casa
executo un servidor privat de "melpa".

#+begin_src emacs-lisp :tangle yes
  (defun my/host-reachable (host)
    (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1" host)))
#+end_src

**** =arv/generate-lab-faces=

Genera /faces/:

#+begin_src emacs-lisp :tangle yes
  (require 'color)

  (defun arv/generate-lab-faces (name count &optional lightness saturation group-name)
    "Generate `count' faces named `<name>-01-face' to
  `<name>-nn-face' within the group `group-name'.

  `name' and `group-name' must be strings, not symbols.

  ,* `lightness' defaults to 45
  ,* `saturation' defaults to 40
  ,* `group-name' defaults to `<name>-faces'
  "
    (let ((group-name (intern (or group-name (concat name "-faces"))))
          (lightness (or lightness 45))
          (saturation (or saturation 40))
          (format-string (concat name "-%02i-face")))
      (custom-declare-group group-name nil "Autogenerated faces" :group 'faces)
      (cl-loop for i from 1 to count do
               (let* ((angle (* 2 pi (/ i (float count))))
                      (a (* saturation (cos angle)))
                      (b (* saturation (sin angle)))
                      (name (intern (format format-string i))))
                 (custom-declare-face name '((t nil))
                                      "Prova face."
                                      :group group-name)
                 (set-face-attribute
                  name nil
                  :foreground (apply 'color-rgb-to-hex (color-lab-to-srgb lightness a b)))
                 ))))
#+end_src

*** Instncies m煤ltiples

Ocasionalment l'entorn en que s'utilitza aquesta configuraci贸 pot ser
lleugerament diferent i pot requerir petites variacions, per exemple
la configuraci贸 de la impressora.

Per suportar aquesta necessitat cada /sistema/ pot tindre una
configuraci贸 diferent. Un sistema s'identifica mitjan莽ant el valor de
la variable d'entorn =EMACS_INSTANCE= o, si no est definida, el nom
de /host/ (sense el domini). El nom del sistema 茅s accessible en la
constant =arv/instance-name=.

#+begin_src emacs-lisp :tangle yes
  (defconst arv/emacs-customize-dir
    (arv/path-concat arv/emacs-conf-dir "customize")
    "Directori on es guarda la personalitzaci贸 de cada sistema.")

  (defconst arv/instance-name
    (or
     (getenv "EMACS_INSTANCE")
     (car (split-string (system-name) "\\.")))
    "Nom del sistema/instncia.")

  (setq custom-file
        (arv/path-concat arv/emacs-customize-dir
                         (concat arv/instance-name ".el")))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

*** Repositoris de paquets

#+begin_src emacs-lisp :tangle yes
  (package-initialize)

  (setq package-archives
        '(("gnu"          . "https://elpa.gnu.org/packages/")
          ("casa"         . "https://a13x15.noip.me/melpa/packages/")
          ("melpa"        . "https://melpa.org/packages/")
          ))
#+end_src

Utilitzar =M-x package-refresh-contents= per recarregar la llista de
paquets.

*** =use-package=

La variable =use-package-always-pin= permet configurar el repositori
que s'utilitzar quan un paquet no especifica la clausula =:pin=.

Sembla que 茅s bastant estricte: al configurar el valor /melpa stable/
el paquet =rainbow-mode=, 煤nicament disponible en el repositori /gnu/,
ha desaparegut. Ha calgut afegir =:pin gnu= per poder instal路lar-lo.

Mentre no activi el repositori /melpa/ no tinc cap prefer猫ncia
respecte al repositori a utilitzar i preveig problemes si el fixo
(/pin/) globalment.

#+begin_src emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (customize-set-value 'use-package-minimum-reported-time 0.05)
  (customize-set-value 'use-package-verbose t)
  ;; (customize-set-value 'use-package-always-pin "melpa stable")

  (require 'use-package)
#+end_src

*** =auto-compile=                                               :desactivat:

No acava de funcionar (provat amb =psvn.el=), probablement per la meva
ignorancia, i ralentitza l'arranc. El desactivo fins que pugar
mirar-m'ho.

https://github.com/emacscollective/auto-compile

Intenta garantir que els arxius compilats (=.elc=) no estan desfasats
repecte del corresponent arxiu font (=.el=).

#+begin_src emacs-lisp :tangle no
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
#+end_src

En cas que l'arxiu =.elc= estigui desfasat carrega el =.el=.

#+begin_src emacs-lisp :tangle yes
  (setq load-prefer-newer t)
#+end_src

*** =transient=

https://github.com/magit/transient

Facilita contruir l铆nies de comandes interactivament (s'utilitza en
=magit=).

#+begin_src emacs-lisp :tangle yes
  (use-package transient
    :ensure t)
#+end_src

*** Directori =site-lisp= local

El subdirectori =site-lisp= de la configuraci贸 s'utilitza per guardar
paquets no disponibles en els repositoris (elpa o git).

Tot i que no 茅s habitual, els paquets poden necessitar canvis
espordics per resoldre errors, mantindre la compatibilitat etc. Per
facilitar-me la vida l'arxiu =loaddefs.el= es genera si no existeix o
est desactualitzat respecte als corresponents =.el=.

#+begin_src emacs-lisp :tangle yes
  (let* ((site-lisp-path (expand-file-name (arv/path-concat arv/emacs-conf-dir "site-lisp")))
         (generated-autoload-file (arv/path-concat site-lisp-path "loaddefs.el")))
    (unless (and (file-exists-p generated-autoload-file)
                 (null (cl-remove-if
                        (lambda (x) (or (string= generated-autoload-file x)
                                   (file-newer-than-file-p generated-autoload-file x)))
                        (directory-files site-lisp-path t "\\.el$"))))
      (update-directory-autoloads site-lisp-path))
    (load generated-autoload-file))
#+end_src

Encara que =use-package= permet definir /autoloads/ l'煤s de
=loaddef.el= 茅s recomanable i no penalitza el temps d'arranc de manera
apreciable.

*** Biblioteques addicionals

Biblioteques de funcions utilitzades en la configuraci贸.

**** =cl-lib=                                                       :builtin:

Implementa funcionalitats de /common lisp/ en emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package cl-lib)
#+end_src

**** =f=
     :PROPERTIES:
     :ID:       22d6bbbb-d859-4388-8bdd-36df7c6cff48
     :END:

https://github.com/rejeep/f.el

Una API moderna per treballar amb arxius i directoris des d'emacs.

Pel tipus de paquet (biblioteca de funcions) s'hauria d'instal路lar
automticament com una depend猫ncia i no directament, per貌 alguns dels
meus paquets (no en elpa) la utilitzen.

#+begin_src emacs-lisp :tangle yes
  (use-package f
    :ensure t)
#+end_src

**** =s=

https://github.com/magnars/s.el

Col路lecci贸 de funcions per manipular cadenes.

#+begin_src emacs-lisp :tangle yes
  (use-package s
    :ensure t)
#+end_src

*** Compatibilitat

Aquesta secci贸 defineix funcions que faciliten mantindre la
compatibilitat amb diferents instal路lacios d'Emacs.

- Emacs 24 no defineix =string-greaterp= (ni =string>=), curiosament
  s铆 defineix =string-lessp= i =string<=.

  #+begin_src emacs-lisp :tangle yes
    (unless (fboundp 'string-greaterp)
      (defun string-greaterp (a b)
	(not (or (string= a b)
		 (string< a b)))))
  #+end_src

- Si compilo emacs en un entorn minimalista les funcions seg眉ents no
  estan definides:

  #+begin_src emacs-lisp :tangle yes
    (unless (fboundp 'scroll-bar-mode)
      (defun scroll-bar-mode (x)))

    (unless (fboundp 'mouse-wheel-mode)
      (defun mouse-wheel-mode (x)))
  #+end_src

** Informaci贸 personal

L'adre莽a d'e-mail pot variar depenent del sistema. Per defecte
s'inicialitza a partir de la variable d'entorn =EMAIL=. Probablement
sigui preferible a definir un valor fix en la configuraci贸.

#+begin_src emacs-lisp :tangle yes
  (setq user-full-name "Alexis Roda"
        user-mail-address "alexis.roda.villalonga@gmail.com")
#+end_src
** Interf铆cie d'usuari

#+begin_src emacs-lisp :tangle yes
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (customize-set-value 'inhibit-startup-screen t)
  ;; cursor blinks forever
  (customize-set-value 'blink-cursor-blinks -1)
#+end_src

** Tema

Crec que la millor forma d'organitzar la configuraci贸 de les /faces/
茅s concentrar-les en una 煤nica secci贸, facilita el canvi de tema.

*** Variables

Aquesta secci贸 defineix variables relacionades amb les /faces/. Es
defineixen per garantir que existeixen pero el seu valor s'ha de
canviar, si escau, dins les funcions que personalitzen els temes, no
ac铆.

Color utilitzat en el cursor quan estem en mode /insert/.

#+begin_src emacs-lisp :tangle yes
  (defvar my/face-cursor-insert-background-color nil)
#+end_src

Color utilitzat en el cursor quan estem en mode /overwrite/.

#+begin_src emacs-lisp :tangle yes
  (defvar my/face-cursor-overwrite-background-color "purple")
#+end_src

*** Noves faces

Aquesta secci贸 defineix noves faces utilitzades en la configuraci贸. Es
defineixen per garantir que existeixen pero el valor s'ha de canviar,
si escau, dins les funcions que personalitzen els temes, no ac铆.

**** =hi-lock=

Faces utilitzades per ressaltar alguns elements. Empra un codi de tres
colors que ressembla un semfor per indicar tres nivells de
/gravetat/, /atenci贸/ etc.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "hi-lock"
    (defface arv/hi-green
      '((((min-colors 88)) (:weight bold :foreground "black" :background "light green"))
        (t (:weight bold :background "green")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-orange
      '((((min-colors 88)) (:weight bold :foreground "black" :background "orange"))
        (t (:weight bold :background "orange")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-pink
      '((((min-colors 88)) (:weight bold :foreground "white" :background "magenta"))
        (t (:weight bold :background "magenta")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces)

    (defface arv/hi-red
      '((((min-colors 88)) (:weight bold :background "red1" :foreground "white"))
        (t (:weight bold :background "red" :foreground "white")))
      "Face for hi-lock mode."
      :group 'hi-lock-faces))
#+end_src

*** doom-one

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-doom-one ()
    ;; El color dels comentaris contrasta poc amb el color de fons i
    ;; dificulta la lectura.

    (set-face-attribute 'font-lock-comment-face nil
                        :foreground "#83898d")

    ;; Els colors de =display-line-numbers= destaquen massa i em distreuen
    ;; del text que estic editant. Aquesta combinaci贸 utilitza un color m茅s
    ;; fosc i ressalta la l铆nia actual.

    (set-face-attribute 'line-number nil
                        :foreground "grey30"
                        :background "#202020")
    (set-face-attribute 'line-number-current-line nil
                        :foreground "#b2731d"
                        :background "#21242b")
    (set-face-attribute 'mode-line nil
                        :background "#b88fc2"
                        :foreground "black")
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "#b4b4b4"
                        :background "#68217a")

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui.

      (when (display-graphic-p)
        (set-face-attribute 'aw-leading-char-face nil
                            :height 4.0
                            :weight 'bold)))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-warning nil
                          :underline nil
                          :foreground "white"
                          :background "#d56d00")
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :foreground "white"
                          :background "#a80000"))

    (with-eval-after-load "diff-hl"
      (set-face-attribute 'diff-hl-change nil
                          :foreground "blue3"
                          :background "#333355")
      (set-face-attribute 'diff-hl-delete nil
                          :foreground "red3"
                          :background "#553333")
      (set-face-attribute 'diff-hl-insert nil
                          :foreground "green4"
                          :background "#335533"))

    (with-eval-after-load "magit"
      (set-face-attribute 'magit-diff-added nil
                          :foreground "#98be65"
                          :background "#21242b")
      ;; (set-face-attribute 'magit-diff-added-highlight nil
      ;;                     :foreground "#98be65"
      ;;                     :background "#21242b")
      (set-face-attribute 'magit-diff-removed nil
                          :foreground "#ff6c6b"
                          :background "#23272e")
      ;; (set-face-attribute 'magit-diff-removed-highlight nil
      ;;                     :foreground "#ff6c6b"
      ;;                     :background "#23272e"))
      )

    (with-eval-after-load "diff-mode"
      (set-face-attribute 'diff-hunk-header nil
                          :weight 'bold
                          :foreground "#282c34"
                          :background "#a9a1e1"
                          ;; extend no funciona, crec que degut a que la
                          ;; face no inclou el salt de l铆nia. Ho deixo
                          ;; com una intenci贸.
                          :extend t)
      (set-face-attribute 'diff-added nil
                          :weight 'bold
                          :foreground "#98be65"
                          :background "#3e493d"
                          :extend t)
      (set-face-attribute 'diff-removed nil
                          :weight 'bold
                          :foreground "#ff6c6b"
                          :background "#4f343a"
                          :extend t)
      (set-face-attribute 'diff-header nil
                          :background "royalblue4"
                          :weight 'bold
                          :extend t)))
#+end_src

*** wombat

Personalitzaci贸 del tema /wombat/. El nom 茅s circumstancial, 茅s
l'煤ltim tema fosc que he utilitzat abans d'animar-me a provar
=modus-operandi=. Aquesta configuraci贸 ha evolucionat segons he anat
canviant de tema (/zenburn/, /tango-dark/, /doom-one/ i /wombat/ que
recordi) i hauria de funcionar m茅s o menys b茅 amb un tema fosc.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-wombat ()
    (set-face-attribute 'button nil
                        :foreground "#8ac6f2"
                        :underline t)

    ;; cursor
    (set-face-attribute 'cursor  nil
                        :background "#fce94f")

    ;; Els colors de =display-line-numbers= destaquen massa i em distreuen
    ;; del text que estic editant. Aquesta combinaci贸 utilitza un color m茅s
    ;; fosc i ressalta la l铆nia actual.

    (set-face-attribute 'line-number nil
                        :foreground "grey30"
                        :background "#202020")
    (set-face-attribute 'line-number-current-line nil
                        :foreground "#b2731d"
                        :background "grey20")

    ;; El color per defecte per la mode-line dificulta diferenciar les
    ;; finestres. El color que he triat no em conven莽 per貌 almenys facilita
    ;; veure el l铆mit de les finestres. Una altra combinaci贸 utilitza el
    ;; mateix groc que utilitzo a i3 per ressaltar la finestra activa, actiu
    ;; =#ffcc00= i inactiu =#aa8900=.

    (set-face-attribute 'mode-line nil
                        :box nil
                        :background "#00ad50"
                        :foreground "black"
                        :height 0.85)
    (set-face-attribute 'mode-line-highlight nil
                        :box nil
                        :background "orange"
                        :foreground "black")
    (set-face-attribute 'mode-line-inactive nil
                        :inherit 'mode-line
                        :box nil
                        :background "#004f24"
                        :foreground "#999999"
                        :weight 'light)

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui. Crec que la familia
      ;; es podria eliminar. Defineix altres aspectes a mes de colors,
      ;; suposo que 茅s acceptable.

      (if (display-graphic-p)
          (set-face-attribute 'aw-leading-char-face nil
                              :family "ubuntu mono"
                              :height 4.0
                              :weight 'bold
                              :background "chartreuse"
                              :foreground "black")
        (set-face-attribute 'aw-leading-char-face nil
                            :background "white"
                            :foreground "black"))
      )

    (with-eval-after-load "apropos"
      (set-face-attribute 'apropos-symbol nil
                          :foreground "chartreuse"
                          :bold t)
      (set-face-attribute 'apropos-keybinding nil
                          :foreground "medium spring green"
                          ))

    (with-eval-after-load "compile"
      (set-face-attribute 'compilation-error nil
                          :underline nil
                          :weight 'normal))

    (with-eval-after-load "diff-hl"
      ;; En alguns temes (detectat en =doom-one=) la definici贸 de les
      ;; faces de =diff-hl= t茅 problemes quan el frame es parteix en dos
      ;; verticalment, en la finestra de la dreta no es visualitza
      ;; correctament. Funciona millor si s'utilitza un color solid
      ;; enlloc de ressaltar nom茅s la vora.

      (set-face-attribute 'diff-hl-change nil
                          :foreground "blue3"
                          :background "#333355")
      (set-face-attribute 'diff-hl-delete nil
                          :foreground "red3"
                          :background "#553333")
      (set-face-attribute 'diff-hl-insert nil
                          :foreground "green4"
                          :background "#335533"))

    (with-eval-after-load "dired"
      (set-face-attribute 'dired-directory nil
                          :foreground "#729fcf"))

    (with-eval-after-load "eldoc"
      (set-face-attribute 'eldoc-highlight-function-argument nil
                          :underline nil
                          :foreground "yellow"
                          :weight 'bold))

    (with-eval-after-load "emmet-mode"
      (set-face-attribute 'emmet-preview-input nil
                          :box nil)
      ;; No aconsegueixo redefinir el color, utilitza el de hightlight
      ;; (del que hereta). Aquesta face 煤nicament s'utilitza, breument,
      ;; quan es confirma el resultat, en un flash.
      (set-face-attribute 'emmet-preview-output nil
                          :background "green"
                          :box nil))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :background "Firebrick4"))

    (with-eval-after-load "hl-line"
      (if (display-graphic-p)
          (set-face-attribute 'hl-line nil
                              :foreground "white"
                              :background "black")
        (set-face-attribute 'hl-line nil
                            :foreground "black"
                            :background "yellow"))
      (set-face-attribute 'hl-line nil
                          :underline nil))

    (with-eval-after-load "ido"
      (set-face-attribute 'ido-first-match nil
                          :background "pale green"
                          :foreground "black"))

    (with-eval-after-load "org"
      (set-face-attribute 'org-mode-line-clock nil
                          :background "green yellow")
      (set-face-attribute 'org-document-title nil
                          :foreground "pale turquoise"
                          :weight 'bold
                          :height 1.5)
      (set-face-attribute 'org-level-1 nil
                          :weight 'bold
                          :height 1.2)
      (set-face-attribute 'org-block-begin-line nil
                          :weight 'normal
                          :background "#202020")
      (set-face-attribute 'org-block nil
                          :background "black")
      (set-face-attribute 'org-block-end-line nil
                          :weight 'normal
                          :background "#202020"))

    (with-eval-after-load "rst"
      ;; customize-face (suposo) te problemes quan la llista
      ;; d'atributs esta buida, sembla que ho interpreta com "no
      ;; canviar res" enlloc de "borrar tots els atributs"

      (set-face-attribute 'rst-level-1 nil :background nil)
      (set-face-attribute 'rst-level-2 nil :background nil)
      (set-face-attribute 'rst-level-3 nil :background nil)
      (set-face-attribute 'rst-level-4 nil :background nil)
      (set-face-attribute 'rst-level-5 nil :background nil)
      (set-face-attribute 'rst-level-6 nil :background nil))

    (with-eval-after-load "term"
      ;; Els colors per defecte de =term= no em convencen. Aquesta
      ;; combinaci贸 m'agrada m茅s:

      (custom-set-faces
       '(term-color-black ((t (:foreground "#242424" :background "#242424"))))
       '(term-color-red ((t (:foreground "#ef2929" :background "#ff1313"))))
       '(term-color-green ((t (:foreground "#8ae234" :background "#4e9a06"))))
       '(term-color-yellow ((t (:foreground "#fce94f" :background "#c4a000"))))
       '(term-color-blue ((t (:foreground "#729fcf" :background "#3465a4"))))
       '(term-color-magenta ((t (:foreground "#ad7fa8" :background "#75507b"))))
       '(term-color-cyan ((t (:foreground "#34e2e2" :background "#06989a"))))
       '(term-color-white ((t (:foreground "#eeeeec" :background "#d3d7cf"))))

       '(term-default-fg-color ((t (:inherit term-color-white))))
       '(term-default-bg-color ((t (:inherit term-color-black))))))

    (with-eval-after-load "transient"
      ;; El color que utilitza =transient= per ressaltar les opcions
      ;; /actives/ no destaca gaire.

      (custom-set-faces
       '(transient-argument ((t (:foreground "green" :weight bold))))))
    )
#+end_src

*** modus-operandi

Personalitzaci贸 de =modus-operandi=.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-theme-modus-operandi ()

    ; redueix la mida del text de la modeline
    (set-face-attribute 'mode-line nil :height 94)
    (set-face-attribute 'mode-line-inactive nil :height 94)

    (with-eval-after-load "ace-window"
      ;; en ace-window fa que el selector destaqui.

      (when (display-graphic-p)
        (set-face-attribute 'aw-leading-char-face nil
                            :height 4.0
                            :weight 'bold)))

    (with-eval-after-load "hl-line"
      ;; la face hl-line definida en modus-operandi no combina b茅 amb
      ;; text clar sobre fons de colors (ho he detectat en alguns
      ;; hi-lock personalitzats amb text blanc sobre fons roig p.e.).
      ;; Pel momen prefereixo perdre els colors i que tot el text sigui
      ;; llegible.

      (when (display-graphic-p)
        (set-face-attribute 'hl-line nil
                            :foreground "black")))

    (with-eval-after-load "flymake"
      (set-face-attribute 'flymake-warning nil
                          :underline nil
                          :foreground "white"
                          :background "#d56d00")
      (set-face-attribute 'flymake-error nil
                          :underline nil
                          :foreground "white"
                          :background "#a80000"))

    (with-eval-after-load "rst"
      ;; customize-face (suposo) te problemes quan la llista
      ;; d'atributs esta buida, sembla que ho interpreta com "no
      ;; canviar res" enlloc de "borrar tots els atributs"

      (set-face-attribute 'rst-level-1 nil :background nil)
      (set-face-attribute 'rst-level-2 nil :background nil)
      (set-face-attribute 'rst-level-3 nil :background nil)
      (set-face-attribute 'rst-level-4 nil :background nil)
      (set-face-attribute 'rst-level-5 nil :background nil)
      (set-face-attribute 'rst-level-6 nil :background nil))

    )
#+end_src

*** Elements independents del tema

En aquesta secci贸 es configuren elements independents del tema. A莽貌
exclou colors.

#+begin_src emacs-lisp :tangle yes
  (defun my/customize-faces-common ()
    (with-eval-after-load "org"
      (custom-set-faces
       '(org-document-title ((t (:height 1.5 :weight bold))))
       '(org-level-1 ((t (:inherit outline-1 :height 1.25 :weight bold))))
       '(org-level-2 ((t (:inherit outline-2 :height 1.188 :weight bold))))
       '(org-level-3 ((t (:inherit outline-3 :height 1.125 :weight bold))))
       '(org-level-4 ((t (:inherit outline-4 :height 1.063 :weight bold))))
       '(org-level-5 ((t (:inherit outline-5 :height 1.0 :weight bold)))))
      )
    )
#+end_src

*** Activaci贸 del tema

#+begin_src emacs-lisp :tangle yes
  ;; (load-theme 'wombat)
  ;; (my/customize-theme-wombat)

  ;; (use-package modus-operandi-theme
  ;;   :ensure t
  ;;   :config
  ;;   (my/customize-theme-modus-operandi))

  (use-package doom-themes
    :ensure t
    :config
    (load-theme 'doom-one)
    (my/customize-theme-doom-one)
    (my/customize-faces-common))

  (when (display-graphic-p)
    ;; x-display-pixel-height necessita un entorn graphic
    (set-face-attribute 'default nil
                        :family "JetBrains Mono"
                        :height (if (> (x-display-pixel-height) 1080) 94 88)))
#+end_src

** Paquets

Aquesta secci贸 inclou la configuraci贸 de paquets d'us general.

*** =abbrev=                                                        :builtin:

[[info:emacs#Abbrevs][=abbrev=]] 茅s semblant a =yasnippet= per貌 menys potent. Tot i aix貌
resulta 煤til com una mena d'autocorrector.

#+begin_src emacs-lisp :tangle yes
  (use-package abbrev
    :commands abbrev-mode
    :config
    (customize-set-value 'abbrev-file-name
                         (arv/path-concat arv/emacs-conf-dir "shared" "abbrev_defs"))
    (customize-set-value 'save-abbrevs t)
    :diminish "")
#+end_src

La variable =abbrev-mode= 茅s buffer local amb el que no es pot
utilitzar =setq=. Canviant el valor per defecte s'aconsegueix activar
=abbrev= en tots els modes. Si no es vol utilitzar en un mode nom茅s
cal desactivar-lo des del /hook/ amb =(abbrev-mode 0)= o =(setq
abbrev-mode nil)=.

#+begin_src emacs-lisp :tangle yes
  (set-default 'abbrev-mode t)
#+end_src

La documentaci贸 recomana activar =abbrev= amb la funci贸 =abbrev-mode=,
no assignant-li un valor a la variable =abbrev-mode=. Per una altra
banda, activar una funcionalitat sembla que no pertany a aquesta
secci贸 sin贸 a la configuraci贸 d'algun mode
(=fundamental-mode=?). Finalment la funci贸 =abbrev-mode= activa
=abbrev= en el buffer actual, per tant s铆 o s铆 s'ha de moure al
/hook/. Pel moment, mentre la configuraci贸 acaba de prendre forma, es
mant茅 el canvi del valor per defecte de la variable.

*** =ace-window=

https://github.com/abo-abo/ace-window

=ace-window= agilitza la navegaci贸 entre les finestres.

#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :ensure t
    :commands ace-window
    :config
    (customize-set-value 'aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?帽))
    (customize-set-value 'aw-scope 'frame))
#+end_src

*** =apropos=                                                       :builtin:

Mai l'he incorporat al meu workflow per貌 sembla una bona forma de
trobar informaci贸.

Per efici猫ncia =apropos= 煤nicament busca en un subconjunt de les
possibilitats. L'opci贸 [[help:apropos-do-all][apropos-do-all]] controla l'espai de cerca i pot
ralentitzar-la. Si esdev茅 un problema caldr restaurar el valor per
defecte (=nil=) i acostumar-se a utilitzar la comanda prefix (=C-u=).

#+begin_src emacs-lisp :tangle yes
  (customize-set-value 'apropos-do-all t)
#+end_src

*** =avy=

https://github.com/abo-abo/avy

=avy= agilitza el despla莽ament dins un buffer.

Per defecte =avy= permet saltar a qualsevol finestra dins el frame
actual. No acostumo a saltar entre finestres i tendeix a generar
seq眉猫ncies llargues de fins tres lletres, especialment en pantalles
grans. Per aquest motiu ho restringeixo a salts dins el buffer actiu.

#+begin_src emacs-lisp :tangle yes
  (use-package avy
    :ensure t
    :commands (avy-goto-char-2
               avy-goto-line
               avy-goto-word-1)
    :config
    (setq avy-all-windows nil))
#+end_src

*** =beacon=

https://github.com/Malabarba/beacon

Whenever the window scrolls a light will shine on top of your cursor
so you know where it is.

#+begin_src emacs-lisp :tangle yes
  (use-package beacon
    :ensure t
    :config
    (customize-set-value 'beacon-color
                         (face-attribute 'cursor :background))
    (customize-set-value 'beacon-size 60)
    (customize-set-value 'beacon-blink-duration 0.5)
    (beacon-mode 1))
#+end_src

*** =browse-url=                                                    :builtin:

Integraci贸 d'emacs amb un navegador web extern.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'browse-url
    (customize-set-value 'browse-url-browser-function 'browse-url-generic)
    (customize-set-value 'browse-url-generic-program "firefox"))
#+end_src

*** =embrace=

https://github.com/cute-jumper/embrace.el

Facilita manipular (afegir, modificar, eliminar) parelles de
/par猫ntesis/.

#+begin_src emacs-lisp :tangle yes
  (use-package embrace
    :ensure t
    :commands embrace-commander)
#+end_src

*** =calendar=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'calendar
    (customize-set-value 'calendar-day-abbrev-array
                         ["Dg" "Dl" "Dt" "Dc" "Dj" "Dv" "Ds"])
    (customize-set-value 'calendar-day-name-array
                         ["Diumenge" "Dilluns" "Dimarts" "Dimecres"
                          "Dijous" "Divendres" "Dissabte"])
    (customize-set-value 'calendar-month-name-array
                         ["Gener" "Febrer" "Mar莽" "Abril" "Maig"
                          "Juny" "Juliol" "Agost" "Setembre"
                          "Octubre" "Novembre" "Desembre"])
    (customize-set-value 'calendar-week-start-day 1))
#+end_src

*** =company=

https://github.com/company-mode/company-mode

/Complete anything/ 茅s un /framework/ per completar text en emacs. T茅
una arquitectura de /plugins/ i inclou m煤ltiples /backends/.

#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :commands company-mode
    :config
    (setq company-minimum-prefix-length 1)
    (setq company-idle-delay 0.5)
    (setq company-tooltip-align-annotations t)
    :diminish "")
#+end_src

*** =compilation=                                                   :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package compile
    :commands compile
    :config
    (customize-set-value 'compilation-message-face 'default))
#+end_src

*** =dash=

https://github.com/magnars/dash.el

A modern list api for Emacs. No 'cl required.

#+begin_src emacs-lisp :tangle yes
  (use-package dash
    :config (dash-enable-font-lock))
#+end_src

*** =diff-hl-mode=

https://github.com/dgutov/diff-hl

=diff-hl-mode= highlights uncommitted changes on the left side of the
window, allows you to jump between and revert them selectively.

[[https://github.com/syohex/emacs-git-gutter][git-gutter]] 茅s una alternativa en cas que aquest no em convenci, per貌
sembla abandonat.

#+begin_src emacs-lisp :tangle yes
  (use-package diff-hl
    :ensure t
    :commands (diff-hl-margin-mode
               global-diff-hl-mode
               turn-on-diff-hl-mode)
    :config
    (use-package psvn
      :defer t
      :config
      (defadvice svn-status-update-modeline (after svn-update-diff-hl activate)
        (diff-hl-update)))
    (use-package magit
      :defer t
      :config
      (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+end_src

A莽貌 anir en algun /hook/ o configuraci贸 global:

#+begin_src emacs-lisp :tangle yes
  (global-diff-hl-mode)
  (unless (display-graphic-p)
    (diff-hl-margin-mode))
#+end_src

Aquesta paquet defineix algunes comandes interessants:

- =diff-hl-revert-hunk= (=C-x v n=)

- =diff-hl-prev-hunk= (=C-x v [=)

- =diff-hl-next-hunk= (=C-x v ]=)

*** =diff-mode=                                                     :builtin:

Per defecte al accedir a un /hunk/ amb les comandes =diff-hunk-next=
(=<tab>=) o =diff-hunk-prev= (=s-<tab>=) es refina la difer猫ncia
ressaltant els canvis individuals.

Tindre-ho activat per defecte em distreu, en general trobo que afegeix
massa soroll. Ho desactivo. Es pot activar en el /hunk/ actual amb la
comanda =diff-refine-hunk= (=C-r=).

#+begin_src emacs-lisp :tangle yes
  (use-package diff-mode
    :config
    (add-hook 'diff-mode-hook (lambda () (diff-auto-refine-mode 0)))
    :bind (:map diff-mode-map
                ("C-r" . diff-refine-hunk)))
#+end_src

*** =diminish=

#+begin_src emacs-lisp :tangle yes
  (use-package diminish
    :ensure t
    :commands diminish)
#+end_src

*** =dired=                                                         :builtin:

=dired= per defecte crea un nou buffer al visitar un directori o
fitxer. Personalment prefereixo evitar la proliferaci贸 de buffers.

#+begin_src emacs-lisp :tangle yes
  (defun arv/dired-up-directory ()
    "Visita el directori pare, en el mateix buffer."
    (interactive)
    (find-alternate-file ".."))
#+end_src

Permet crear un arxiu buid (quasi buid, cont茅 un salt de l铆nia) des de
=dired=. L'alternativa actual 茅s obrir amb =C-x C-f=, modificar,
guardar i tancar un arxiu.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "dired"
    (require 'f)

    (defun my/dired-create-empty-file ()
      "Crea un arxiu buid en un buffer dired."
      (interactive)
      (let* ((arxiu (read-string "File name: "))
             (ruta (f-join (dired-current-directory) arxiu)))
        (unless (file-exists-p ruta)
          (shell-command  (format "touch '%s'" ruta) nil)
          (revert-buffer)))))
#+end_src

Afegim les comandes al /keymap/.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "dired"
    (my/bind-keys dired-mode-map
                  '(("M-<up>" arv/dired-up-directory)
                    ("^" arv/dired-up-directory)
                    ("C-m" dired-find-alternate-file)
                    ("c" my/dired-create-empty-file))))
#+end_src

*** =display-line-numbers=

En emacs 26 la numeraci贸 de l铆nies ha millorat en quant a rendiment
respecte a =linum= i similars. Li donar茅 una segona oportunitat.

Personalment trobo m茅s 煤til veure valors relatius a absoluts.

Em resulta molest que canvi茂 l'ample per adaptar-se al nombre de
d铆gits, m茅s quan utilizo numeraci贸 relativa que rarament requereix m茅s
de dos d铆gits.

Per minimitzar l'efecte es fixa l'ample i es configura per mai
disminuir. Amb la pantalla vertical necessito fins 3 d铆gits (mostra
poc m茅s de 100 l铆nies). En la majoria d'arxius 3 茅s suficient
(rarament utilitzo arxius de m茅s de 1000 l铆nies). En arxius m茅s llargs
pot creixer si cal.

Preferiria que mostr茅s el valor zero per la l铆nia actual (estic
acostumat a consultar la l铆nia actual en la /modeline/) i evitar el
creixement per貌 no sembla que sigui possible configurar-ho.

#+begin_src emacs-lisp :tangle yes
  (defun my/enable-line-numbers-mode ()
    ;; HACK: en un parell de llocs de la configuraci贸 activo
    ;; display-line-numbers-mode. El problema 茅s que si el desactivo i
    ;; l'activo utiliza numeraci贸 absoluta. Mentre esbrino com
    ;; configurar-ho, aquesta funci贸 ho centralitza.
    (display-line-numbers-mode 1)
    (setq display-line-numbers 'relative))

  (setq display-line-numbers-grow-only t
        display-line-numbers-width-start 3)
#+end_src

*** =ediff=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ediff
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

*** =eglot=

Client =lsp= (/language server protocol/). Aquesta secci贸 cont茅
configuraci贸 global. La configuraci贸 de cada llenguatge es fa en la
secci贸 /mode/ corresponent.

Una alternativa 茅s =lsp-mode=. No he pogut fer-lo funcionar amb la
cpctelera (crec que el problema 茅s de =clangd= no de =lsp-mode=). M'ha
semblat una mica intrusiu.

#+begin_src emacs-lisp :tangle yes
  (use-package eglot
    :ensure t
    :commands eglot)
#+end_src

*** =eldoc=                                                         :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package eldoc
    :commands eldoc-mode
    :diminish "")
#+end_src

*** =electric-pair=                                                 :builtin:

Activa globalment el mode =electric-pair=: al inserir un par猫ntesi
(clau, claudtor etc.) obert automticament s'insereix el corresponent
par猫ntesi tancat.

#+begin_src emacs-lisp :tangle yes
  (electric-pair-mode 1)
#+end_src

Es desactiva en el minibuffer, vull valorar si 茅s m茅s una mol茅stia o
una ajuda:

#+begin_src emacs-lisp :tangle yes
  (defun my/inhibit-electric-pair-mode-in-modeline (char)
    (minibufferp))

  (setq electric-pair-inhibit-predicate
        #'my/inhibit-electric-pair-mode-in-modeline)
#+end_src

*** =engine-mode=

https://github.com/hrs/engine-mode

=engine-mode= facilita integrar dins emacs diferents cercadors web.

#+begin_src emacs-lisp :tangle yes
  (use-package engine-mode
    :ensure t
    :config
    (engine-mode t)

    ;; els engines s'ordenen per keybinding per facilitar identificar
    ;; els conflictes al definir les tecles

    (defengine diec2
      "dlc.iec.cat/results.asp?txtEntrada=%s"
      :keybinding "c"
      :term-transformation-hook (lambda (term) (encode-coding-string term latin-1)))

    (defengine django
      "https://docs.djangoproject.com/search/?q=%s&release=11"
      :keybinding "d")

    (defengine emacs-stack-exchange
      "http://emacs.stackexchange.com/search?q=%s"
      :keybinding "e")

    (defengine google
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g")

    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "G")

    (defengine rfcs
      "http://pretty-rfc.herokuapp.com/search?q=%s"
      :keybinding "r")

    (defengine stack-overflow
      "https://stackoverflow.com/search?q=%s"
      :keybinding "s")

    (defengine sdl
      "http://wiki.libsdl.org/%s"
      :keybinding "S")

    (defengine wikipedia
      "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
      :keybinding "w")

    (defengine wordreference
      "http://www.wordreference.com/redirect/translation.aspx?w=%s&dict=enes"
      :keybinding "W")

    (defengine z80heaven
      "http://z80-heaven.wikidot.com/instructions-set:%s"
      :keybinding "z"))
#+end_src

*** =expand-region=

https://github.com/magnars/expand-region.el

#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t
    :commands er/expand-region)
#+end_src

*** =figlet=                                                         :manual:

https://gist.github.com/digash/392649

Insereix text gran. Requereix la comanda externa =figlet=.

#+begin_src emacs-lisp :tangle yes
  (use-package figlet
    :ensure nil
    :load-path "conf.d/site-lisp"
    :config
    (setq figlet-font-dir "/usr/share/figlet")
    (setq figlet-default-font "standard")
    :commands (figlet
               figlet-no-comment
               banner
               banner-no-comment))
#+end_src

*** =flymake=                                                       :builtin:

Aparentment he estat utilitzant =flycheck=. Vaig a donar-li una
oportunitat a =flymake=. En les comparatives que he llegit deixen
millor a =flycheck= per貌 afegeix una depend猫ncia externa.

#+begin_src emacs-lisp :tangle yes
  (use-package flymake
    :commands flymake-mode)
#+end_src

*** =font-lock=                                                     :builtin:

#+begin_src emacs-lisp :tangle yes
  (global-font-lock-mode t)
  (customize-set-value 'font-lock-maximum-decoration t)
#+end_src

No tinc clar si activar-lo ac铆 茅s preferible a fer-ho en algun hook.

*** =grin=

=grin= 茅s una utilitat tipus =grep=, escrita en python. Es pot
descarregar des de https://pypi.python.org/pypi/grin.

La integraci贸 amb emacs est basada en [[https://bitbucket.org/dariusp686/emacs-grin/src][emacs-grin]].

#+begin_src emacs-lisp :tangle yes
  (use-package grin
    :load-path "site-lisp")
#+end_src

Al estar escrita en python pot donar problemes si s'executa dins un
directori amb codi python que cont茅 m貌duls que poden interferir amb
els =import= que fa =grin=. Ho vaig detectar, crec recordar, intentant
executar-lo dins el =site-packages= d'un /virtualenv/, no recordo els
detalls concrets.

=ag=[[[https://github.com/ggreer/the_silver_searcher][enlla莽]]] 茅s una alternativa semblant, escrita en C, per tant m茅s
rpida i que no t茅 conflictes amb arbres de codi python.

El que em tira enrere per canviar 茅s la interf铆cie del m貌dul
=ag.el=[[[https://github.com/Wilfred/ag.el][enlla莽]]], defineix moltes comandes per fer diferents tipus de
cerques (text en directori, text en directori nom茅s en certs arxius,
regex en directori, text en projecte, text en certs arxius del
projecte, regex en projecte ...). Massa comandes/combinacions de
tecles que recordar i poca flexibilitat. M'agrada m茅s l'enfoc de
=grin.el=, una 煤nica comanda que demana el directori i la l铆nia de
comandes.

El problema amb =grin= 茅s anecd貌tic en el meu cas d'us i no hi ha
urg猫ncia en fer el canvi. A莽貌 茅s m茅s un recordatori.

*** =hi-lock=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package hi-lock
    :diminish "")
#+end_src

*** =highlight-indentation=

https://github.com/antonj/Highlight-Indentation-for-Emacs

=highlight-indentation= mostra /regles/ verticals per facilitar
alinear el text. No l'utilitzo per貌 qui sap si alguna vegada pot ser
煤til.

#+begin_src emacs-lisp :tangle yes
  (use-package highlight-indentation
    :ensure t
    :commands (highlight-indentation-mode
               highlight-indentation-current-column-mode))
#+end_src

*** =hippie-expand=                                      :builtin:desactivat:

Exemple de funci贸 que proveeix candidats a =hippie-expand= a partir
dels /TAGS/.

#+begin_src emacs-lisp :tangle no
  (defun try-expand-tags (old)
    "Funcio compatile amb `hippie-expand' per expandir tags.

  Argument OLD nil la primera vegada que es crida, t les seguents."
    ;; @NOTE: alex 2014-08-02 16:30:17: Aquesta funci贸 s'utilitza amb
    ;; `make-hippie-expand-function', en eixe punt el m貌dul
    ;; `hippie-expand' estar carregat, motiu pel que no es requereix el
    ;; m貌dul ni es defineix cap autoload. De la mateixa forma la funci贸
    ;; `tags-complete-tag' es carrega al inicialitzar emacs (m貌dul
    ;; `compat'), amb lo que est disponible.
    (unless old
      (let ((start-point (save-excursion
                           (backward-word 1)
                           (point))))
        (he-init-string start-point (point))
        (setq he-expand-list (sort
                              (tags-complete-tag he-search-string nil t)
                              'string-lessp))))
    (while (and he-expand-list
                (he-string-member (car he-expand-list) he-tried-table))
      (pop he-expand-list))
    (if (null he-expand-list)
        (progn
          (when old (he-reset-string))
          ())
      (he-substitute-string (car he-expand-list))
      (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
      (pop he-expand-list)
      t))
#+end_src

*** =hl-line=                                                       :builtin:
    :PROPERTIES:
    :ID:       ea3e7059-fedc-44b2-b1d6-55e3326d050e
    :END:

Ressalta la l铆nia on es troba el cursor actualment.

#+begin_src emacs-lisp :tangle yes
  (use-package hl-line
    :commands global-hl-line-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (global-hl-line-mode t)
#+end_src

Activar el mode probablement pertany a algun hook, o, al ser global, a
la configuraci贸 de un mode.

Aquesta funci贸 desactiva =global-hl-line-mode= en el buffer en que
s'executa. Est pensada per cridar-la des d'un /hook/.

#+begin_src emacs-lisp :tangle yes
  (defun my/disable-global-hl-mode-locally ()
    (setq-local global-hl-line-mode nil))
#+end_src

*** =hydra=

https://github.com/abo-abo/hydra

#+begin_src emacs-lisp :tangle yes
  (use-package hydra
    :ensure t
    :defer nil)
#+end_src


*** =ibuffer=                                                       :builtin:

=ibuffer= resulta especialment 煤til quan cal gestionar molts buffers.

Fins ara he estat utilitzant =ebuff-menu= i, al ser /el猫ctric/,
resulta una mica m茅s gil si hi ha pocs buffers.

Encara falta provar =buffer-menu=.

#+begin_src emacs-lisp :tangle yes
  (use-package ibuffer
    :commands ibuffer)
#+end_src

*** =ibuffer-vc=

https://github.com/purcell/ibuffer-vc

Permet agrupar els buffers en =ibuffer= pel repositori de control de
revisions al que pertanyen.

S'activa amb la comanda =ibuffer-vc-set-filter-groups-by-vc-root=.

#+begin_src emacs-lisp :tangle yes
  (use-package ibuffer-vc
    :ensure t)
#+end_src

He detectat un comportament estrany en que els buffers =*Help*=,
=*Buffer List*= i =*Flymake log*= apareixen dins un grup vc quan
sembla m茅s l貌gic que apareguin en el grup =[ Default ]=.

*** =ido=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :commands (ido-mode ido-everywhere)
    :config
    ;; Inhibit switching to other directory when no matches are found in
    ;; the current directory.
    (customize-set-value 'ido-auto-merge-work-directories-length -1)
    (customize-set-value 'ido-enable-flex-matching t)
    (customize-set-value 'ido-ignore-directories
                         '("\\`CVS/" "\\`\\.\\./" "\\`\\./" "\\`\\.svn/" "\\`\\.ropeproject/"))
    (customize-set-value 'ido-max-work-directory-list 10)
    (setq ido-save-directory-list-file "~/.emacs.d/ido.last")

    ;; Mostra el buffer en la finestra activa encara que sigui visible
    ;; en un altre frame.
    (setq ido-default-buffer-method 'select-window))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (ido-mode 1)
  (ido-everywhere 1)
#+end_src

Personalment prefereixo que els elements es mostrin verticalment
enlloc d'horitzontalment:

#+begin_src emacs-lisp :tangle yes
  (use-package ido-vertical-mode
    :ensure t
    :after ido
    :config
    (ido-vertical-mode 1)
    (add-hook 'ido-setup-hook
              (lambda ()
                ;; more intuitive keybinds for vertical-mode
                (my/bind-keys ido-completion-map
                              '(("<down>" ido-next-match)
                                ("<up>" ido-prev-match)
                                ("<left>" ido-prev-match-dir)
                                ("<right>" ido-next-match-dir)
                                ("M-<left>" ido-prev-work-directory)
                                ("M-<right>" ido-next-work-directory))))))
#+end_src

Tamb茅 m'agrada utilitzar =ido= all铆 on sigui possible, malauradament
~(ido-everywhere 1)~ 茅s limitat i nom茅s l'activa per seleccionar
buffers i arxius.

#+begin_src emacs-lisp :tangle yes
  (use-package ido-completing-read+
    :ensure t
    :after ido
    :config
    (ido-ubiquitous-mode 1))
#+end_src

*** =lorem-ipsum=                                                    :manual:

https://github.com/jschaf/emacs-lorem-ipsum

No est disponible als repositoris estable. No 茅s un tipus de codi que
hagi de canviar/millorar en el futur aix铆 que es clona:

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/jschaf/emacs-lorem-ipsum.git
  ./scripts/compile_package emacs-lorem-ipsum
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package lorem-ipsum
    :ensure nil
    :load-path "site-lisp/emacs-lorem-ipsum"
    :commands (lorem-ipsum-insert-paragraphs
               lorem-ipsum-insert-sentences
               lorem-ipsum-insert-list))
#+end_src

*** =magit=

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :commands (magit-status
               magit-dispatch
               magit-file-dispatch))
#+end_src

*** =minions=

https://github.com/tarsius/minions

Agrupa tots els /indicadors/ dels /minor-modes/ en un men煤. La
/modeline/ queda molt m茅s neta.

No m'agrada que no es puga deixar indicadors en la /modeline/, tots
van al men煤. Pel meu us afecta a =flymake= que mostra el nombre
d'errors en la modeline.

Llevat d'aquest detall m'agrada que no requreixi configuraci贸, al
contrari que =diminish=. Li donar茅 una oportunitat.

#+begin_src emacs-lisp :tangle yes
  (use-package minions
    :ensure t
    :config (minions-mode 1))
#+end_src

*** =modeline=                                                      :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; oculta el n煤mero de la columna
  (column-number-mode 0)
  ;; (line-number-mode 0)

  ;; no cal desaprofitar espai quan el gestor de finestres/escriptori ja
  ;; mostra la data
  (display-time-mode 0)
#+end_src

*** =mouse=                                                         :builtin:

Prefereixo que al clicar en la roda del ratol铆 s'enganxi en la posici贸
del /point/ enlloc de la del punter del ratol铆, d贸na m茅s control.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'mouse
    (setq mouse-yank-at-point t)

    (setq mouse-buffer-menu-maxlen 25)
    (setq mouse-buffer-menu-mode-mult 10))
#+end_src

*** =multi-line=

https://github.com/IvanMalison/multi-line

=multi-line= facilita formatar /llistes l'elements/ (parmetres d'una
funci贸, elements d'una llista etc.) en una o vries l铆nies, emprant
diferents formats.

#+begin_src emacs-lisp :tangle yes
  (use-package multi-line
    :ensure t
    :commands multi-line)
#+end_src

*** =mwheel=                                                        :builtin:

#+begin_src emacs-lisp :tangle yes
  ;; aparentment `mouse-wheel-mode' s'activa per defecte
  (mouse-wheel-mode t)

  ;; quantitat a moure quan es gira la roda en combinaci贸 amb una tecla
  ;; modificadora
  (setq mouse-wheel-scroll-amount
        '(5
          ((shift) . 1)
          ((control) . nil)))

  (setq mouse-wheel-follow-mouse t)
#+end_src

*** =outline=                                            :builtin:desactivat:

Codi tret de:

http://www.emacswiki.org/emacs/OutlineMinorMode

Defineix funcions que fan l'us del =outline-mode= m茅s intuitiu
(semblant al comportament de l'explorer de windows) i les assigna a
combinacions de tecles m茅s accesibles.

#+begin_src emacs-lisp :tangle no
  (defun arv/outline-body-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (and (not (eobp))
           (progn (forward-char 1)
                  (not (outline-on-heading-p))))))

  (defun arv/outline-body-visible-p ()
    (save-excursion
      (outline-back-to-heading)
      (outline-end-of-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-subheadings-p ()
    (save-excursion
      (outline-back-to-heading)
      (let ((level (funcall outline-level)))
        (outline-next-heading)
        (and (not (eobp))
             (< level (funcall outline-level))))))

  (defun arv/outline-subheadings-visible-p ()
    (interactive)
    (save-excursion
      (outline-next-heading)
      (not (outline-invisible-p))))

  (defun arv/outline-hide-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-body-p)
                  (arv/outline-body-visible-p))
             (hide-entry)
             (hide-leaves))
            (t
             (hide-subtree)))))

  (defun arv/outline-show-more ()
    (interactive)
    (when (outline-on-heading-p)
      (cond ((and (arv/outline-subheadings-p)
                  (not (arv/outline-subheadings-visible-p)))
             (show-children))
            ((and (not (arv/outline-subheadings-p))
                  (not (arv/outline-body-visible-p)))
             (show-subtree))
            ((and (arv/outline-body-p)
                  (not (arv/outline-body-visible-p)))
             (show-entry))
            (t
             (show-subtree)))))

  (with-eval-after-load "outline"
    (my/bind-keys outline-mode-map
                  '(("S-<left>" arv/outline-hide-more)
                    ("S-<right>" arv/outline-show-more)
                    ("S-<up>" outline-previous-visible-heading)
                    ("S-<down>" outline-next-visible-heading)))

    (my/bind-keys outline-minor-mode-map
                  '(("S-<left>" arv/outline-hide-more)
                    ("S-<right>" arv/outline-show-more)
                    ("S-<up>" outline-previous-visible-heading)
                    ("S-<down>" outline-next-visible-heading))
                  ;; prova per moure blocs, no acava de funcionar
                  ;;(define-key map (kbd "S-s-<up>") 'outline-move-subtree-up)
                  ;;(define-key map (kbd "S-s-<down>") 'outline-move-subtree-down)
                  ))
#+end_src

*** =projectile=                                                 :desactivat:

https://github.com/bbatsov/projectile

Gesti贸 de /projectes/ (en un sentit molt relaxat).

Vaig comen莽ar a utilitzar-lo per facilitar la navegaci贸 dins el codi
font de /Hera/ per貌 vaig acabar implementant una soluci贸 espec铆fica.

Pel moment es deixa desactivat, a l'espera de veure si trobo a faltar
cap funcionalitat.

#+begin_src emacs-lisp :tangle no
  (use-package projectile
    :ensure t
    :commands projectile-global-mode
    :config

    ;; native indexing is slower but allows for file/directory filtering
    (setq projectile-indexing-method 'native)

    ;; enable caching in order to speedup native indexing
    (setq projectile-enable-caching t)

    (setq projectile-mode-line '(:eval (format " PRJ[%s]" (projectile-project-name))))

    (projectile-global-mode))
#+end_src

*** =psvn=                                                           :manual:

http://www.xsteve.at/prg/emacs/psvn.el

Integraci贸 amb el control de versions /subversion/.

Aquesta comanda desf un /hunk/. Es pot obtindre el mateix efecte amb
la comanda =diff-apply-hunk= per貌 demana confirmaci贸 sobre si es vol
aplicar el /hunk/ a la inversa.

#+begin_src emacs-lisp :tangle yes
  (defun my/diff-undo-hunk ()
    "Desf un hunk."
    (interactive)
    (diff-apply-hunk t))
#+end_src

=svn-status-show-svn-diff= no modifica la finestra activa. Aquesta
funci贸 executa =svn-status-show-svn-diff= i despr茅s activa la finestra
que mostra el buffer =*svn diff*=.

#+begin_src emacs-lisp :tangle yes
  (defun my/svn-status-show-svn-diff (arg)
    "Consultar `svn-status-show-svn-diff'."
    (interactive "P")
    (svn-status-show-svn-diff arg)
    (when (get-buffer-window "*svn-diff*")
      (switch-to-buffer-other-window "*svn-diff*")))
#+end_src

No estic segur de si prefereixo aquest comportament, l'anterior o els
dos. El temps dir. Pel moment assignar茅 el nou comportament a ~=~ i
l'original a ~M-==~.

La comanda =svn-log-edit-erase-edit-buffer= esborra tot el contingut
del buffer, incloent els comentaris amb la llist d'arxius modificats.
Aquesta comanda 茅s mens agressiva i mant茅 els comentaris.

#+begin_src emacs-lisp :tangle yes
  (defun my/svn-log-edit-erase-edit-buffer ()
    (interactive)
    (set-buffer svn-log-edit-buffer-name)
    (save-excursion
      (goto-char (point-min))
      (keep-lines "^##.*")))
#+end_src

Configura el mode.

#+begin_src emacs-lisp :tangle yes
  (use-package psvn
    :load-path "conf.d/site-lisp"
    :commands (svn-status
               svn-file-show-svn-diff
               svn-status-show-svn-log)
    :config
    (customize-set-value 'svn-status-default-log-arguments
                         '("-v" "--stop-on-copy"))
    (customize-set-value 'svn-status-verbose t)
    (customize-set-value 'svn-status-hide-unmodified t)
    (my/bind-keys
     svn-status-diff-mode-map
     '(("a" diff-apply-hunk)
       ("u" my/diff-undo-hunk)))
    (my/bind-keys
     svn-status-mode-map
     '(("=" my/svn-status-show-svn-diff)
       ("M-=" svn-status-show-svn-diff)))
    (my/bind-keys
     svn-log-edit-mode-map
     '(("C-c C-z" my/svn-log-edit-erase-edit-buffer))))
#+end_src

Amb =magit= al executar la comanda =status= es fa des de l'arrel (el
directori que cont茅 =.git=) mentre que amb =psvn= es fa des del
directori actual. No tinc clar quin enfoc 茅s preferible.

Aquesta comanda implementa l'enfoc de git en subversion per veure si
el prefereixo.

#+begin_src emacs-lisp :tangle yes
  (defun x-my/svn-status ()
    ""
    (interactive)
    (let ((root (locate-dominating-file default-directory ".svn")))
      (if root
          (svn-status root)
        (user-error "No s'ha trobat '.svn'."))))
#+end_src

El buffer per editar els missatge de commit defineix comandes 煤tils
que mai recordo. Aquest 茅s un intent de recordar-les.

#+begin_src emacs-lisp :tangle yes
  (customize-set-value
   'svn-log-edit-header
   (concat "## Lines starting with '## ' will be removed from the log message.\n"
           "##\n"
           "## Partial list of commands\n"
           "## C-c C-d    svn-log-edit-svn-diff\n"
           "## C-c TAB    svn-log-edit-svn-status\n"
           "## C-c C-l    svn-log-edit-svn-log\n"
           "## C-c C-z    svn-log-edit-erase-edit-buffer\n"
           "## C-c C-c    log-edit-done\n"
           "## C-c C-k    log-edit-kill-buffer\n"
           "##\n"))
#+end_src

*** =rainbow=

https://elpa.gnu.org/packages/rainbow-mode.html

Afegeix un fons de color als noms dels colors.

#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode
    :diminish "")
#+end_src

*** =smex=

https://github.com/nonsequitur/smex

=smex= 茅s una versi贸 millorada de =M-x=. Basada en /ido/ facilita
l'acc茅s a les comandes utilitzades recentment i a les m茅s freq眉ents.

#+begin_src emacs-lisp :tangle yes
  (use-package smex
    :ensure t
    :commands smex
    :config
    (setq smex-save-file (arv/path-concat user-emacs-directory "smex-items"))
    (smex-initialize))
#+end_src

*** =sql=                                                           :builtin:

#+begin_src emacs-lisp :tangle yes
  (use-package sql-mode
    :commands sql-mode
    :config
    (add-hook 'sql-mode-hook
              (lambda ()
                (set-variable 'show-trailing-whitespace t)
                (sql-highlight-postgres-keywords))))
#+end_src

*** =subword=, =superword=                                          :builtin:

#+begin_src emacs-lisp :tangle yes
  (defun arv/wm-cycle ()
    "Cycle word-mode:
  subword-mode -> superword-mode -> nothing -> subword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (superword-mode
      (subword-mode 0)
      (superword-mode 0))
     (t
      (subword-mode 1)
      (superword-mode 0))))

  (defun arv/wm-cycle-2 ()
    "Cycle word-mode:
  subword-mode <-> superword-mode"
    (interactive)
    (cond
     (subword-mode
      (subword-mode 0)
      (superword-mode 1))
     (t
      (subword-mode 1)
      (superword-mode 0))))
#+end_src

*** =swiper=

#+begin_src emacs-lisp :tangle yes
  (use-package swiper
    :ensure t
    :commands swiper)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/swiper-symbol-with-prefix (p)
    "Like swiper, unless prefix argument is provided.
  With a prefix argument P, isearch for the symbol at point."
    (interactive "P")
    (let ((current-prefix-arg nil))
      (if p (swiper (thing-at-point 'symbol t))
        (swiper))))
#+end_src

*** =tab-mode=                                                      :builtin:

Suport per m煤ltiples pestanyes on cada pestanya t茅 el seu propi layout
de finestres.

#+begin_src emacs-lisp :tangle yes
  (when (version<= "27" emacs-version)
    (use-package tab-bar
      :config
      ;; TODO: aquesta configuraci贸 amaga la barra de pestanyes. Per
      ;; tindre una refer猫ncia estaria be mostrar el nom de la pestanya
      ;; activa en la modeline.
      ;; (customize-set-value 'tab-bar-show nil)

      ;; mentre m'acostumo al funcionament es mostren les pestanyes
      (customize-set-value 'tab-bar-show t)
      (customize-set-variable 'tab-bar-new-tab-choice #'ido-switch-buffer)
      (tab-bar-history-mode)))
#+end_src

*** =term=                                                          :builtin:

Desactiva =global-hl-line-mode= en la terminal.

#+begin_src emacs-lisp :tangle yes
  (add-hook 'term-mode-hook
            (lambda ()
              (my/disable-global-hl-mode-locally)))
#+end_src

*** =uniquify=                                                      :builtin:

=uniquify= 茅s responsable d'assignar noms 煤nics als buffers quan hi ha
conflictes. Suporta diferents estils.

#+begin_src emacs-lisp :tangle yes
  (use-package uniquify
    :defer t
    :config
    (customize-set-value 'uniquify-buffer-name-style 'reverse))
#+end_src

*** =which-key=

https://github.com/justbur/emacs-which-key

=which-key= mostra les combinacions de tecles disponibles.

#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :commands which-key-mode
    :config
    (setq which-key-idle-delay 0.75)
    (setq which-key-sort-order 'which-key-description-order)
    (which-key-setup-side-window-right)
    :diminish "")
#+end_src

#+begin_src emacs-lisp :tangle yes
  (which-key-mode 1)
#+end_src

*** =workgroups=                                                 :desactivat:

Permet definir /workgroups/ (distribucions de finestres emacs) i
alternar entre ells.

Mai vaig aconseguir integrar-lo en el meu workflow i el paquet ja no
茅s mantingut. Es mant茅 com un recordatori.

#+begin_src emacs-lisp :tangle no
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))
(workgroups-mode 1)
(setq wg-morph-on nil)

(set-face-attribute 'wg-mode-line-face nil
                    :foreground "black"
                    :background "#2fadff")
#+end_src

*** =xt-mouse=                                           :builtin:desactivat:

Afegeix suport m铆nim pel ratol铆 quan emacs s'executa en una terminal:

#+begin_src emacs-lisp :tangle no
  (unless (display-graphic-p)
    (use-package xt-mouse
      :config (xterm-mouse-mode)))
#+end_src

20190629: no aprofito la funcionalitat i en contrapartida perdo la
possibilitat que oferix X de seleccionar amb el ratoli.

*** =yasnippet=

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :commands (yas-global-mode yas-minor-mode)
    :config
    (add-to-list 'yas-snippet-dirs
                 (arv/path-concat arv/emacs-conf-dir "shared" "yasnippet"))
    (setq yas-prompt-functions '(yas-ido-prompt yas-x-prompt yas-completing-prompt))
    (add-to-list 'auto-mode-alist '("\\.yas$" . snippet-mode))
    :diminish yas-minor-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
    (yas-global-mode 1)
#+end_src

En la [[https://github.com/joaotavora/yasnippet/blob/5a29fe67d70de3749e30ebb37206395b4d1a51a8/NEWS][release 0.13]] es van eliminar tots els snippets del paquet, s'han
mogut al paquet =yasnippet-snippets=.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :ensure t)
#+end_src

** Modes

Aquesta secci贸 inclou la configuraci贸 dels /modes/ que utilitzo
habitualment.

L'estructura utilitzada per documentar/configurar els modes 茅s /work
in progress/ per貌 l'organitzaci贸 seg眉ent sembla raonable:

#+begin_src org :tangle no
  ,*** mode
  ,**** =paquet 1=
  ,**** =paquet 2=
  ...
  ,**** =paquet N=
  ,**** Funcions d'utilitat
  ,**** Combinacions de tecles
  ,**** /Hook/
#+end_src

Tot i que =use-package= permet definir les tecles emprant la directiva
=:bind= trobo m茅s prctic agrupar totes les definions en una
secci贸. Un avantatge de =:bind= 茅s que defineix automticament
=autoloads= pels simbols que no son funcions (segons =fboundp=).

*** ensamblador Z80

Recull de paquets i configuracions relacionades amb la programaci贸 en
ensamblador del Z80 i [[https://github.com/lronaldo/cpctelera][cpctelera]].

**** =sdz80-mode=

Amplia la funcionalitat de =asm-mode= afegint elements relacionats amb
el z80.

#+begin_src emacs-lisp :tangle yes
  (use-package sdz80-mode
    :ensure t
    :commands sdz80-mode)
#+end_src

L'activo per tots els arxius =.s=.

He provat de configurar-ho via =.dir_locals.el= associant a =asm-mode=
l'execuci贸 de =sdz80-mode= per貌 sembla que entra en un bucle infinit
(=sdz80-mode= es deriva de =asm-mode=). Pel moment no tinc previst
programar en altres ensambladors apart del Z80 aix铆 que pel moment no
茅s un problema.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.s\\'" . sdz80-mode))
#+end_src

**** =z80count=

Comptabilitza els cicles requererits per cada instrucci贸. Requereix la
comanda externa [[https://github.com/reidrac/z80count][=z80count=]].

#+begin_src emacs-lisp :tangle yes
  (use-package z80count
    :ensure t)
#+end_src

**** Associaci贸 d'arxius

Els arxius =.lst= generats per =asz80= s'obren per defecte en
=conf-mode=. Prefereixo utilitzar =fundamental-mode=.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.lst\\'" . fundamental-mode))
#+end_src

*** C

Idees per mirar:

- https://cestlaz.github.io/posts/using-emacs-32-cpp/

- https://www.youtube.com/watch?v=5FQwQ0QWBTU

- https://www.youtube.com/watch?v=GuEqRmCjy6E


**** gtk-doc

https://github.com/federicomenaquintero/gnome-emacs-utils

Funcions variades per facilitar el desenvolupament de/amb gnome.
M'interessa la funcionalitat per generar comentaris de les funcions.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/federicomenaquintero/gnome-emacs-utils
  ./scripts/compile_package gnome-emacs-utils
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package gtk-doc
    :ensure nil
    :load-path "site-lisp/gnome-emacs-utils"
    :commands (gtk-doc-insert
               gtk-doc-insert-section))
#+end_src

**** cc-mode

Configuraci贸 del c-mode.

#+begin_src emacs-lisp :tangle yes
  (use-package cc-mode
    :commands (c-mode c++-mode)
    :config
    (add-hook 'c-mode-common-hook
              (lambda ()
                (setq indent-tabs-mode nil)
                (setq c-default-style "k&r")
                (setq c-basic-offset 4)
                ;; alineaci贸 dels arguments d'una funci贸
                (c-set-offset 'arglist-intro '+)
                (c-set-offset 'arglist-close nil)
                ;; company-mode
                (company-mode t))))
#+end_src

**** lsp

=eglot= recomana(?) utilitzar [[https://github.com/MaskRay/ccls][ccls]] com /language server/:

#+begin_src sh :tangle no
  sudo apt install ccls
#+end_src

Es pot configurar per /projecte/ creant [[https://github.com/MaskRay/ccls/wiki/Project-Setup#ccls-file][l'arxiu .ccls]] en /l'arrel del
projecte/ (on est el directori =.git= o =.svn= imagino). Per la
cpctelera utilitzo:

#+begin_src text
aroda@turing:assault$ cat .ccls
clang
-I/home/aroda/.local/src/cpctelera/cpctelera/src/
#+end_src

A menys que s'utilitzin /includes/ en rutes no estndards crec que no
cal configurar res. No tinc clar si cal que existeixi l'arxiu encara
que estigui buid.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "cc-mode"
    (add-hook 'c-mode-common-hook
              (lambda ()
                (eglot-ensure))))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "cc-mode"
    (my/bind-keys
     c-mode-map
     '(("C-c m d f" gtk-doc-insert)
       ("C-c m d s" gtk-doc-insert-section)
       )))
#+end_src

*** css

**** Funcions d'utilitat

M'agrada que quan es guarda un arxiu =.scss= es recompili
automticament el codi CSS. Per fer-ho servir cal definir unes
variables (veure codi).

Per definir variables per projecte es poden utilitzar variables locals
de directori.

#+begin_src emacs-lisp :tangle yes
  (defvar sass-project-root nil
    "Arrel del projecte.")
  (defvar sass-project-main-file nil
    "Arxius arrel del projecte, relatiu a `sass-project-root'.")
  (defvar sass-project-output-file nil
    "Arxiu de sortida, relatiu a `sass-project-root'.")
  (defvar sass-command "sass --style compressed %s %d"
    "Comanda per executar sass.

  Permet interpolar alguns elements:

  - %r: directori arrel del projecte
  - %s: ruta absoluta de l'arxiu origen (source)
  - %d: ruta absoluta de l'arxiu de sortida (dest)
  ")

  (require 'format-spec)

  (defun arv/sass-compile-on-save ()
    "Compila el projecte SASS al guardar.

  Quan un arxiu amb extensi贸 '.scss' es guarda dins el directori
  `sass-project-root' o un subdirectori s'executa la comanda
  `sass-command' substituint:

  - %r: `sass-project-root'
  - %s: `sass-project-main-file'
  - %d: `sass-project-output-file'."
    (if (and (string-match-p "\.scss$" (buffer-file-name))
             (s-starts-with-p sass-project-root (buffer-file-name)))
        (compilation-start
         (format-spec
          sass-command
          (list
           (cons ?r sass-project-root)
           (cons ?s (arv/path-concat sass-project-root sass-project-main-file))
           (cons ?d (arv/path-concat sass-project-root sass-project-output-file))))
         t
         (lambda (mode) "*sass*"))))
#+end_src

**** Combinacions de tecles
**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'css-mode-hook
            (lambda ()
              (rainbow-mode t)
              (company-mode t)))
  (add-hook 'after-save-hook 'arv/sass-compile-on-save)
#+end_src

*** emacs-lisp, ielm
**** =elisp-slime-nav=

https://github.com/purcell/elisp-slime-nav

#+begin_src emacs-lisp :tangle yes
  (use-package elisp-slime-nav
    :ensure t
    :commands elisp-slime-nav-mode
    :diminish "")
#+end_src

**** =macrostep=

=macrostep= permet expandir macros /inline/.

#+begin_src emacs-lisp :tangle yes
  (use-package macrostep
    :ensure t
    :commands macrostep-mode)
#+end_src

**** =package-lint=

https://github.com/purcell/package-lint

This library provides a linter for the metadata in Emacs Lisp files
which are intended to be packages.

#+begin_src emacs-lisp :tangle yes
  (use-package package-lint
    :ensure t
    :commands (package-lint-current-buffer
               package-lint-buffer))
#+end_src

**** =paredit=

#+begin_src emacs-lisp :tangle yes
  (use-package paredit
    :ensure t
    :commands paredit-mode
    :diminish "")
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/scratch ()
    "Activa el buffer *scratch*, creant-lo si 茅s necessari."
    (interactive)
    (let ((current-mode major-mode))
      (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
      (if (memq current-mode lisp-mode)
          (funcall current-mode))))

  (defun arv/emacs-lisp-insert-grave ()
    "Inserts `' within a string or just ` otherwise."
    (interactive)
    (if (nth 8 (syntax-ppss))
        (progn
          (insert "`'")
          (backward-char 1))
      (insert "`")))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "lisp-mode"
    (my/bind-keys emacs-lisp-mode-map
                  '(("s-SPC" company-complete)
                    ("<f9>" (lambda () (interactive) (ert t)))
                    ("M-<f1>" (lambda () (interactive) (info "elisp")))
                    ("`" arv/emacs-lisp-insert-grave)
                    ("s-c" arv/startup-byte-recompile)
                    ("C-c m b" eval-buffer)
                    ("C-c m c" cancel-debug-on-entry)
                    ("C-c m d" debug-on-entry)
                    ("C-c m e" toggle-debug-on-error)
                    ("C-c m f" find-function)
                    ("C-c m F" emacs-lisp-byte-compile-and-load)
                    ("C-c m l" find-library)
                    ("C-c m m" macrostep-mode)
                    ("C-c m p" paredit-mode)
                    ("C-c m r" eval-region)
                    ("C-c m s" arv/scratch)
                    ("C-c m v" find-variable)
                    ("C-c m ?" elisp-slime-nav-describe-elisp-thing-at-point)
                    ("C-h e V" apropos-value)
                    ("C-c m z" byte-recompile-directory)
                    ("C-c C-z" ielm)))

    (let ((keywords '(("\\<ert-deftest\\>" . font-lock-keyword-face)
                      ("\\<should\\>" . font-lock-keyword-face)
                      ("\\<should-not\\>" . font-lock-keyword-face))))
      (font-lock-add-keywords 'emacs-lisp-mode keywords)
      (font-lock-add-keywords 'lisp-interaction-mode keywords)))

  (with-eval-after-load "paredit"
    (my/bind-keys paredit-mode-map
                  '(("C-<right>" nil)
                    ("C-<left>" nil)
                    ("M-<right>" paredit-forward-slurp-sexp)
                    ("M-<left>" paredit-forward-barf-sexp))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (paredit-mode 1)
              (elisp-slime-nav-mode 1)
              (prettify-symbols-mode 1)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (add-hook 'ielm-mode-hook
            (lambda ()
              (company-mode t)
              (eldoc-mode 1)
              (elisp-slime-nav-mode 1)))
#+end_src
*** go                                                      :desactivat:brut:

Aquest mode actualment no l'utilitzo. S'inclou la configuraci贸,
desactivada, per accelerar la migraci贸.

#+begin_src emacs-lisp :tangle no
  (require 'company)
  (require 'company-go)
  (require 'go-eldoc)
  (require 'go-mode)
  (require 'projectile)

  (defun arv/gobuild ()
    "Jumps to project root and runs 'go build -v'."
    (interactive)
    (compile (format "cd %s && go build -v" (projectile-project-root)) 't))

  (defun arv/goinstall ()
    "runs 'go install' on current package."
    (interactive)
    (compile (format "cd %s && go install" (file-name-directory (buffer-file-name))) 't))

  (defun arv/gotest ()
    "runs 'go test' on current package."
    (interactive)
    (compile (format "cd %s && go test" (file-name-directory (buffer-file-name))) 't))

  (eval-after-load "go-mode"
    '(progn
       (setq gofmt-command "goimports")
       ;; flymake
       (require 'flymake-go)
       ;; documentation
       (setq godoc-at-point-function 'godoc-gogetdoc)
       (define-key go-mode-map (kbd "C-c m d") 'godoc-at-point)
       ;; jumping around
       (define-key go-mode-map (kbd "C-c j a") 'go-goto-arguments)
       (define-key go-mode-map (kbd "C-c j d") 'go-goto-docstring)
       (define-key go-mode-map (kbd "C-c j i") 'go-goto-imports)
       (define-key go-mode-map (kbd "C-c j m") 'go-goto-method-receiver)
       (define-key go-mode-map (kbd "C-c j n") 'go-goto-function-name)
       (define-key go-mode-map (kbd "C-c j r") 'go-goto-return-values)
       (define-key go-mode-map (kbd "M-.") 'godef-jump)
       ;; compilation
       (define-key go-mode-map (kbd "<f9>") 'arv/gobuild)
       (define-key go-mode-map (kbd "C-<f9>") 'arv/gotest)
       (define-key go-mode-map (kbd "M-<f9>") 'arv/goinstall)
       ))

  (add-hook 'go-mode-hook
            (lambda ()
              (add-hook 'before-save-hook 'gofmt-before-save)
              ;; autocompletion. Depends on external command gocode
              (set (make-local-variable 'company-backends) '(company-go))
              (company-mode)
              ;; eldoc
              (go-eldoc-setup)))
#+end_src

*** haskell

#+begin_src emacs-lisp :tangle yes
  (use-package haskell-mode
    :ensure t
    :config
    (define-key haskell-mode-map (kbd "C->") (lambda () (interactive) (insert " -> ")))
    (define-key haskell-mode-map (kbd "C-<") (lambda () (interactive) (insert " <- "))))
#+end_src

*No revisat*: a [[https://sachachua.com/blog/2019/08/2019-08-26-emacs-news/][Sacha Chua 2019-08-26 Emacs news]] he trobat un enlla莽 a
[[https://github.com/soupi/minimal-haskell-emacs][minimal haskell emacs]] (a minimal emacs configuration for haskell
programming).

*** html
**** =emmet= (anteriorment =zencoding=)

https://github.com/smihica/emmet-mode

=emmet= facilita generar html (xml) a partir d'una especificaci贸 en un
format compacte. Tamb茅 suporta CSS per貌 resulta massa criptic i pel
meu cas d'us no aporta res.

#+begin_src emacs-lisp :tangle yes
  (use-package emmet-mode
    :ensure t
    :commands emmet-mode
    :config
    (setq emmet-indentation 2)
    (define-key emmet-mode-keymap (kbd "C-j") nil)
    :diminish "")
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'html-mode-hook
            (lambda ()
              (rainbow-mode t)
              (emmet-mode t)))
#+end_src

*** javascript
**** =tern=

http://ternjs.net/

Integra la comanda externa =tern= dins emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package tern
    :ensure t
    :commands tern-mode
    :diminish "")
#+end_src

**** =company-tern=

https://github.com/proofit404/company-tern

Implementa un /backend/ per =company-mode= basat en =tern=.

#+begin_src emacs-lisp :tangle no
  (use-package company-tern
    :ensure t
    :after tern
    :config
    (add-to-list 'company-backends 'company-tern))
#+end_src

**** =js2-refactor=

https://github.com/magnars/js2-refactor.el

Refactoritzaci贸 de codi js.

#+begin_src emacs-lisp :tangle yes
  (use-package js2-refactor
    :ensure t
    :after js2-mode
    :commands js2-refactor-mode
    :diminish "")
#+end_src

**** =js2-mode=

#+begin_src emacs-lisp :tangle yes
  (use-package js2-mode
    :ensure t
    :commands js2-mode)

  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src

**** =xref-js2=                                                  :desactivat:

https://github.com/NicolasPetton/xref-js2

Aquest apareix a una recepta que vaig trobar que explica com
configurar un entorn javascript. Depen de la comanda =ag=. Mai l'he
utilitzat. =tern= sembla prometedor.

#+begin_src emacs-lisp :tangle no
  (use-package xref-js2
    :ensure t)
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'js2-mode
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    (js2r-add-keybindings-with-prefix "C-c m r")
    (add-hook 'js2-mode-hook (lambda ()
                               (js2-imenu-extras-mode)
                               (js2-refactor-mode)
                               (tern-mode)
                               (company-mode))))
#+end_src

*** org
**** Instal路laci贸

Al instal路lar /org/ des d'ELPA el codi compilat m'ha donat problemes
([[https://emacs.stackexchange.com/questions/28441/org-mode-9-unable-to-eval-code-blocks][enlla莽]]) aix铆 que he optat per instal路lar-lo directament des del codi
font ([[https://orgmode.org/worg/dev/org-build-system.html][instruccions]]).

En =init.el= es modifica el valor de =load-path= per garantir que es
carrega la versi贸 correcta de /org/ abans de processar aquesta
configuraci贸.

Per instal路lar:

#+begin_src sh :tangle yes
  [ -d ~/.local/src ] || mkdir -p ~/.local/src
  pushd ~/.local/src
  if [ ! -d org-mode ] ; then
      echo "Descarregant i instal路lant 'org-mode'."
      git clone --quiet https://code.orgmode.org/bzg/org-mode.git
      cd org-mode
      make local.mk
      sed -i -r -e 's!^prefix\s+=.*$!prefix = $(HOME)/.local/share!' local.mk
      make
      make install
  fi
  popd
#+end_src

Per actualitzar la versi贸 instal路lada:

#+begin_src sh :tangle no
  cd ~/.local/src/org-mode
  git pull
  make
  make install
#+end_src

**** Ajuda

Mostra la refer猫ncia rpida de =org-mode= (=orgcard.pdf=) si est
disponible (dins el subdirectori =etc=).

#+begin_src emacs-lisp :tangle yes
  (defun my/org-refcard ()
    "Mostra la refer猫ncia rpida de org-mode."
    (interactive)
    (let ((org-refcard (arv/path-concat arv/emacs-conf-dir "etc" "orgcard.pdf")))
      (when (file-readable-p org-refcard)
        (find-file org-refcard))))
#+end_src

**** M貌duls extra

/org/ no carrega tots els m貌duls disponibles. Segons la documentaci贸
es pot modificar el valor de la variable =org-modules= per afegir nous
m貌duls, per貌 no tinc clar si modificar-la ac铆 tindr efecte, una
vegada carregat /org/, o cal fer-ho en =init.el=, abans de
carregar-lo.

Aparentment =org-modules= t茅 un /setter/ que fara algo al assignar-li
un valor amb =customize-set-value=, probablement carregar els m貌duls.

Mentre ho esbrino els m貌duls es carreguen manualment.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (when (string-greaterp org-version "9.2")
      (require 'org-tempo)))
#+end_src

**** Plantilles estructurals (temporals)

Plantilla que expandeix =<S= en un bloc de codi /emacs-lisp/ marcat
amb =:tangle yes=. Probablement es podr esborrar quan s'hagi
completat la migraci贸 de la configuraci贸.

En algun punt entre /org/ 8.2.10 i 9.1.7 s'ha canviat la forma en que
s'expandeixen les [[info:org#Structure%20templates][plantilles estructurals]].

#+begin_src emacs-lisp :tangle yes
  ;; No tinc clara la versi贸 en que a莽貌 va canviar. En el meu context
  ;; (emacs 25.3.1 + org 8.2.10 i org 9.1.7) "9" 茅s suficientment bo.

  (if (string-greaterp org-version "9")
      (add-to-list 'org-structure-template-alist
                   '("S" . "src emacs-lisp :tangle yes"))
    (add-to-list 'org-structure-template-alist
                 '("S"
                   "#+begin_src emacs-lisp :tangle yes\n?\n#+end_src"
                   "</src>\n?\n<src lang=\"emacs-lisp\" tangle=\"yes\">")))
#+end_src

Utilitzo els estats seg眉ents per gestionar les tasques.

#+begin_src plantuml :file estats_org.png
  [*] --> TODO
  TODO --> STRT
  TODO --> CANC
  STRT --> PAUS
  STRT --> WAIT
  STRT --> DONE
  STRT --> CANC
  PAUS --> STRT
  WAIT --> STRT
  DONE --> [*]
  CANC --> [*]
#+end_src

**** =babel=

Llista de llenguatges que es poden avaluar directament des d'un bloc
de codi.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     (let ((langs '((emacs-lisp . t)
                    (python . t)
                    (plantuml . t))))
       ;; https://lists.gnu.org/archive/html/emacs-orgmode/2015-11/msg00425.html
       (if (string-greaterp org-version "8.3")
           (cons '(shell . t) langs)
         (cons '(sh . t) langs)))))
#+end_src

Al exportar un document cada vegada demana confirmaci贸 per avaluar els
blocs de codi /plantuml/, resulta molest.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ob-core
    (setq org-confirm-babel-evaluate
          (lambda (lang body)
            (not (member lang '("plantuml"))))))
#+end_src

**** =emacs-htmlize=                                                 :manual:

L'exportaci贸 a HTML en org 9.1.8 requereix que estigui instal路lat
=emacs-htmlize=, el problema 茅s que no apareix a ELPA (melpa?):

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/hniksic/emacs-htmlize.git
  ./scripts/compile_package emacs-htmlize
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :after org
    :load-path "site-lisp/emacs-htmlize")
#+end_src

**** =ob-plantuml=

=ob-plantuml= permet integrar diagrames /plantuml/ dins els documents
/org/. Per exemple:

#+begin_src org
  ,#+begin_src plantuml :file tryout.png
    Alice -> Bob: synchronous call
    Alice ->> Bob: asynchronous call
  ,#+end_src
#+end_src

Requereix un /jar/ (java archive) que es pot descarregar des de
http://plantuml.com/download. Tamb茅 requereix el JRE. Provat amb la
versi贸 8.0.131.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ob-plantuml"
    (customize-set-value
     'org-plantuml-jar-path
     (expand-file-name "~/.local/lib/plantuml/plantuml.jar")))
#+end_src

**** =org=

Defineix el comportament quan s'edita un bloc plegat.

#+begin_src emacs-lisp :tangle yes
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

Les opcions disponibles es troben a l'[[help:org-catch-invisible-edits][ajuda]].

Defineix el nombre de l铆nies en blanc necessaries per mantindre una
l铆nia en blanc entre seccions col路lapsades. Personalment prefeixo que
les cap莽aleres apareguin juntes.

#+begin_src emacs-lisp :tangle yes
  (setq org-cycle-separator-lines 0)
#+end_src

Em resulta molest el comportament el猫ctric de la parella =<>=. El
comentari que figura en [[https://code.orgmode.org/bzg/org-mode/commit/886ab9c766][el commit de org]] diu:

#+begin_quote
lisp/org.el (org-mode): Let < and > be recognized as opening and
ending characters.

These characters are typically used in timestamps where it is useful
to use C-M-f and C-M-b to manipulate them.
#+end_quote

No manipulo /timestamps/ i s铆 que utilitzo =<= per expandir plantilles
estructurals i com operadors en blocs de codi, on el comportament
el猫ctric 茅s molest. Resetejo la sintaxi de =<= i =>= als valors per
defecte.

#+begin_src emacs-lisp :tangle yes
  (defun my/org-reset-<-syntax ()
    (modify-syntax-entry ?< "@" org-mode-syntax-table)
    (modify-syntax-entry ?> "@" org-mode-syntax-table))
#+end_src

La comanda =org-export-dispatch= (=C-c C-e=) reseteja la taula de
sintaxis (o algo semblant) i =<= recupera el comportament original.
Afegeixo un /advice/ al final de la comanda per revertir el canvi.

#+begin_src emacs-lisp :tangle yes
  (defun my/advice-org-export-dispatch (&optional arg)
    (my/org-reset-<-syntax))

  (advice-add 'org-export-dispatch :after #'my/advice-org-export-dispatch)
#+end_src

Prefereixo que els documents org s'obrin amb totes les cap莽aleres
plegades, em dona una visi贸 general del document.

#+begin_src emacs-lisp :tangle yes
  (setq org-startup-folded t)
#+end_src

A莽貌 es pot canviar document a document especificant una de les
opcions:

#+begin_src org
  ,#+STARTUP: overview
  ,#+STARTUP: content
  ,#+STARTUP: showall
  ,#+STARTUP: showeverything
#+end_src

Aquesta opci贸 es pot afegir amb la comanda =C-u C-u TAB=
(=org-set-startup-visibility=).

**** =org-id=

Al emmagatzemar l'enlla莽 a una secci贸 amb =C-c l= s'utilitza el t铆tol
de la secci贸. Si es modifica el t铆tol de la secci贸 els enlla莽os es
trenquen.

Amb aquesta configuraci贸 =C-c l= assigna un ID 煤nic globalment a la
secci贸.

#+begin_src emacs-lisp :tangle yes
  (use-package org-id
    :config
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id
          org-id-track-globally t))
#+end_src

**** =ox-twbs=

https://github.com/marsmining/ox-twbs

Exporta a HTML + bootstrap. No mata per貌 茅s m茅s agradable visualment
que el format per defecte.

Cal importar el paquet perqu猫 es registri i que aparegui en la
pantalla d'exportaci贸 (=C-c C-e=). Malauradament no hi ha cap /event/
que permeti retardar l'operaci贸 aix铆 que espera uns segons
d'inactivitat per carregar-lo.

#+begin_src emacs-lisp :tangle yes
  (use-package ox-twbs
    :ensure t
    :defer 4)
#+end_src

**** Funcions d'utilitat

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-emphasize (char)
    (if mark-active
        (org-emphasize char)
      (insert char)))
#+end_src

Afegeix automticament la data en que es creen les entrades =TODO=:

#+begin_src emacs-lisp :tangle yes
  (defun arv/org-add-creation-date (&rest ignore)
    "Log TODO creation time in the property drawer under the key 'CREATED'."
    (when (and (org-get-todo-state)
               (not (org-entry-get nil "CREATED")))
      (org-entry-put nil "CREATED" (format-time-string (cdr org-time-stamp-formats)))))

  (advice-add 'org-insert-todo-heading :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-heading-respect-content :after #'arv/org-add-creation-date)
  (advice-add 'org-insert-todo-subheading :after #'arv/org-add-creation-date)
#+end_src

**** Faces

Perqu猫 el valor de =org-todo-keyword-faces= tingui efecte sembla que
cal /declarar/ els estats amb algo tipus:

#+begin_src org
  ,#+TODO: TODO STRT PAUS(@) WAIT(@) DONE(@)
  ,#+TODO: | CANC(c@)
#+end_src

Pel que entenc 茅s necessari perqu猫 org spiga que s贸n estats finals i
que no. En funci贸 d'aix貌 s'aplica un estil.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
        (setq org-todo-keyword-faces
              '(("TODO" . arv/hi-red)
                ("STRT" . hi-blue)
                ("PAUS" . arv/hi-orange)
                ("WAIT" . arv/hi-pink)
                ("DONE" . arv/hi-green)
                ("CANC" . hi-green-b))))
#+end_src

**** Configuraci贸 de tecles                                      :desactivat:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
    (my/bind-keys org-mode-map
                  '(("M-<f1>" my/org-refcard))))
#+end_src

Cal revisar el paquet =arv/org=. Fins aleshores es desactiva.

#+begin_src emacs-lisp :tangle no
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "/") (lambda () (interactive) (arv/org-emphasize ?/)))
    (define-key org-mode-map (kbd "*") (lambda () (interactive) (arv/org-emphasize ?*)))
    (define-key org-mode-map (kbd "_") (lambda () (interactive) (arv/org-emphasize ?_)))
    (define-key org-mode-map (kbd "=") (lambda () (interactive) (arv/org-emphasize ?=)))
    (define-key org-mode-map (kbd "~") (lambda () (interactive) (arv/org-emphasize ?~)))
    (define-key org-mode-map (kbd "+") (lambda () (interactive) (arv/org-emphasize ?+)))
    (define-key org-mode-map (kbd "C-c M-q") 'arv/org-remove-reduntant-tags)
    (define-key org-mode-map (kbd "C-c q")   'arv/org-add-inherited-tags)
    (define-key org-mode-map (kbd "C-c $") 'arv/org-archive-subtree)
    (define-key org-mode-map (kbd "C-c C-w") 'arv/org-refile))
#+end_src

**** Plantilles de captura

Veure [[info:org#Capture%20templates][Capture templates]] per detalls.


Aquesta serveix per capturar notes relacionades amb la configuraci贸
d'emacs:

#+begin_src emacs-lisp :tangle yes
  (setq org-capture-templates
        `(("t"
           "TODO emacs"
           entry
           (file+headline "~/.emacs.d/conf.d/notes.org" "Bugs, mol猫sties, millores etc.")
           ,(concat "** TODO %^{Heading} %^g\n"
                    "   :PROPERTIES:\n"
                    "   :CREATED: %U\n"
                    "   :REFERER: %a\n"
                    "   :END:\n\n"
                    "%?")
           :empty-lines 1)))
#+end_src

Aquesta la utilitzo per capturar notes quan treballo en Hera. Potser
es podria generalitzar a notes per projecte.

#+begin_src emacs-lisp :tangle yes
  (when (getenv "HERA_ROOT")
    (push `("p"
            "TODO Hera"
            entry
            (file+headline ,(arv/path-concat (getenv "HERA_ROOT") "doc_dev" "TODO.org") "TODOs")
            ,(concat "** TODO %^{Heading} %^g\n"
                     "   :PROPERTIES:\n"
                     "   :CREATED: %U\n"
                     "   :REFERER: %a\n"
                     "   :END:\n\n"
                     "%?")
            :prepend t
            :empty-lines 1)
          org-capture-templates))
#+end_src

**** LaTeX

Classe basada en =report=. Defineix canvis en la presentaci贸 (font,
color dels enlla莽os i marges) i en l'estructura (el primer element 茅s
=chapter= no =part=).

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "ox-latex"
    (add-to-list 'org-latex-classes
                 '("informe"
                   "\\documentclass[paper=a4, fontsize=10pt]{report}
  \\usepackage{fourier}
  \\usepackage[]{babel}
  \\usepackage[margin=3.5cm]{geometry}
  \\usepackage[colorlinks=true,linkcolor=blue]{hyperref}
  \\linespread{1.5}
  \\setlength{\\parskip}{0.3cm}"
                   ("\\chapter{%s}" . "\\chapter*{%s}")
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (add-to-list 'org-latex-classes
                 '("beamer"
                   "\\documentclass[presentation]{beamer}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"
                    "\\begin{frame}[fragile]\\frametitle{%s}"
                    "\\end{frame}"))))
#+end_src

**** Configuracions desactivades

A莽貌 茅s part de la configuraci贸 original que mai vaig acabar d'integrar
en el meu workflow. Es mant茅 per si de cas.

#+begin_src emacs-lisp :tangle no
  ;; define 'ecfg:' links
  (eval-after-load "org"
    '(progn
       (org-add-link-type "ecfg" 'arv/org-ecfg-open)
       (add-hook 'org-store-link-functions 'arv/org-ecfg-store-link)
       (define-key org-mode-map (kbd "C-c M-l") 'arv/org-ecfg-insert-link-at-point)
       ))


  ;; capture
  (setq org-capture-templates
        '(("i" "Interrupcio" entry (file+headline "gtd.org" "Interrupcions")
           (file "templates/interrupt.tmpl")
           :empty-lines 1 :clock-in t :clock-resume nil)
          ("t" "Todo" entry (file+headline "gtd.org" "Tasks")
           (file "templates/todo.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t)
          ("f" "Todo followup" entry (clock)
           (file "templates/todo_followup.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)
          ("s" "Sibling" entry (function (lambda () (org-up-heading-safe) (org-end-of-subtree t)))
           (file "templates/sibling.tmpl")
           :empty-lines 1 :clock-in t :clock-resume t :prepend t)))


  ;; agenda
  (setq org-agenda-files "~/.emacs.d/org/agenda_files")

  (setq org-agenda-custom-commands
        '(("x" tags "TIPUS=\"error\"")
          ("v" todo "DONE|CANCELLED")))


  ;;; workflow
  ;;
  ;; TODO(t) STRT(s!) PAUS(p@) HOLD(i!) WAIT(w@) | DONE(d!) CANC(c@)
  ;;
  ;; - TODO: no action taken, just created the note.
  ;; - STRT: currently working on, there can be only one.
  ;; - PAUS: paused, still not finished.
  ;; - HOLD: interrupted, there can be only one.
  ;; - WAIT: paused, waiting for external feedback.
  ;; - DONE: finished, no further action is required.
  ;; - CANC: canceled, no further action is required.

  (eval-after-load "org"
    '(progn
       (setq org-todo-keywords
             '((sequence "TODO(t)" "STRT(s!)" "PAUS(p@)" "HOLD(i!)"
                         "WAIT(w@)" "|" "DONE(d!)" "CANC(c@)")))
       (setq org-directory "~/.emacs.d/org")
       (setq org-startup-folded t)
       (require 'arv-org)
       (setq arv/org-interrupt-resumed-state "STRT")
       (setq arv/org-interrupt-interrupted-state "HOLD")
       (setq arv/org-interrupt-capture-key "i")
       (setq arv/org-sctc-entering-state-clocking-actions
             '(("STRT" . nil)
               ("PAUS" . nil)
               ("WAIT" . nil)))
       (setq arv/org-sctc-paused-state "PAUS")
       (arv/org-sctc-setup)))
#+end_src

**** Hook

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "org"
    (add-hook
     'org-mode-hook
     (lambda ()
       (my/org-reset-<-syntax)
       ;; electric-pair: insereix parelles ==, // i ~~
       (let ((org-electric-pairs '((?= . ?=) (?/ . ?/) (?~ . ?~))))
         (setq-local electric-pair-pairs (append electric-pair-pairs org-electric-pairs))))))
#+end_src

*** perl                                                         :desactivat:

Fa anys que no programo en perl i espero no haver de tornar a fer-ho.
S'inclou la configuraci贸 per nostlgia.

#+begin_src emacs-lisp :tangle no
  (add-hook 'perl-mode-hook
            (lambda()
          (set-variable 'show-trailing-whitespace t)
          (setq perl-indent-level 4)
          (turn-on-font-lock)))
#+end_src

*** po

=po-mode= es distribueix com part del codi font de =gettext= que es
pot descarregar des de:

ftp://ftp.gnu.org/pub/gnu/gettext/gettext-latest.tar.xz

El fitxers =po-mode.el= i =po-compat.el= s'han copiat dins el
directori =site-lisp=. La inicialitzaci贸 seg眉ent 茅s una adaptaci贸 de
=start-po.el=.

#+begin_src emacs-lisp :tangle yes
  (use-package po-mode
    :load-path "conf.d/site-lisp"
    :commands po-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.po\\'\\|\\.po\\." . po-mode)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package po-compat
    :load-path "conf.d/site-lisp"

    ;; :command comprova si el s铆mbol est definit (fboundp), en cas
    ;; negatiu genera un autoload i en cas afirmatiu no fa res. A莽貌 es
    ;; equivalent al que fa start-po.el.
    :commands po-find-file-coding-system

    :init
    (modify-coding-system-alist 'file "\\.po[t]?\\'\\|\\.po\\."
                                'po-find-file-coding-system))
#+end_src

*** prog-mode

Mode base pels modes de programaci贸.

Aquesta configuraci贸 permet utilitzar etiquetes, normalment dins
comentaris, que es destacaran utilitzant colors. El significat 茅s el
seg眉ent:

- /FIXME/: roig, cal una acci贸 *immediata*. Falta implementar algo,
  algo est mal etc. El codi no funcionar com s'espera fins que es
  faci l'acci贸.

- /HACK/, /OPTIMIZE/, /REVIEW/, /TODO/: taronja, cal un acci贸. El codi
  funcionar per貌 podria funcionar millor, ser m茅s net etc.

- /IMPORTANT/, /NOTE/, /WARNING/: verd, no cal acci贸. S'utilitza per
  destacar certs tipus de comentaris.

**** Combinacions de tecles

Cap tecla definida.

**** /Hook/

#+name: target-prog-mode-hook
#+begin_src emacs-lisp :tangle yes
  ;; (eval-after-load "linum"
  ;;   '(progn
  ;;      (require 'relative-linum)))

  (add-hook 'prog-mode-hook
            (lambda ()
              (linum-mode 0)
              (show-paren-mode 1)
              (set-variable 'show-trailing-whitespace t)

              ;; (flyspell-prog-mode)
              ;; flyspell defineix C-, i C-. que ja tinc assignades i
              ;; interioritzades.
              ;; (define-key flyspell-mode-map (kbd "C-,") nil)
              ;; (define-key flyspell-mode-map (kbd "C-.") nil)

              ;; hi-lock

              ;; HACK: 20180818, no tinc clara la causa per貌, si no
              ;; s'activa font-lock, hi-lock no ressalta els nous
              ;; elements, nom茅s els existens en obrir l'arxiu. A莽貌
              ;; sembla consistent amb el que diu la documentaci贸:
              ;;
              ;;   In buffers where Font Lock mode is enabled, patterns
              ;;   are highlighted using font lock. In buffers where
              ;;   Font Lock mode is disabled, patterns are applied
              ;;   using overlays; in this case, the highlighting will
              ;;   not be updated as you type.
              ;;
              ;; font-lock s'activa globalment. La teoria 茅s que el hook
              ;; s'executa abans que s'hagi activat font-lock.

              (font-lock-mode 1)

              (hi-lock-mode 1)
              (hi-lock-face-buffer "\\bFIXME:" 'arv/hi-red)
              (hi-lock-face-buffer "\\bHACK:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bIMPORTANT:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bNOTE:" 'arv/hi-green)
              (hi-lock-face-buffer "\\bOPTIMIZE:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bREVIEW:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bTODO:" 'arv/hi-orange)
              (hi-lock-face-buffer "\\bWARNING:" 'arv/hi-green)))
#+end_src

*** python
**** =arv-py=                                                        :manual:

https://github.com/patxoca/arv-py

Funcions d'utilitat per treballar amb codi python.

#+begin_src emacs-lisp :tangle yes
  (use-package arv-py
    :ensure t
    :commands (pyx/add-setup-dependency
               pyx/electric-colon
               pyx/get-current-package-name
               pyx/insert-current-package-name
               pyx/make
               pyx/nav-goto-first-import
               pyx/nav-up-list
               pyx/refactor-wrap-for
               pyx/refactor-wrap-if-else
               pyx/refactor-wrap-try-except
               pyx/refactor-wrap-while
               pyx/refactor-wrap-with
               pyx/smart-grave
               pyx/visit-setup-py
               pyx/visit-test-module))
#+end_src

**** =elpy=

https://github.com/jorgenschaefer/elpy

Documentaci贸 https://elpy.readthedocs.io/en/latest/index.html

Pel seu funcionament requereix algunes comandes externes:

#+begin_src sh :tangle no
  pip install jedi flake8 autopep8 yapf
#+end_src

=M-x elpy-config= per veure si estan instal路lades.

#+begin_src emacs-lisp :tangle yes
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :config
    (defun arv/elpy-nav-forward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-forward-block))

    (defun arv/elpy-nav-backward_block ()
      ""
      (interactive "^")
      (back-to-indentation)
      (elpy-nav-backward-block))

    (my/bind-keys elpy-mode-map
                  '(("C-<down>" arv/elpy-nav-forward_block)
                    ("C-<up>" arv/elpy-nav-backward_block)
                    ("C-<left>" nil)
                    ("C-<right>" nil)
                    ("C-c m d" elpy-doc)))

    ;; Arxius de menys de 8K es transfereixen al backend via RPC, els
    ;; majors via un arxiu temporal. En la documentaci贸 diu que enviar
    ;; arxius "grans" per RPC pot ser lent per貌 no defineix que 茅s
    ;; "gran". Espero que 8K no qualifiqui com gran.
    (customize-set-value 'elpy-rpc-large-buffer-size 8192)

    (customize-set-value 'elpy-syntax-check-command "flake8")

    (customize-set-value 'elpy-modules
                         '(elpy-module-company
                           ;; elpy-module-django
                           elpy-module-eldoc
                           elpy-module-flymake
                           ;; elpy-module-highlight-indentation
                           elpy-module-pyvenv
                           elpy-module-sane-defaults
                           elpy-module-yasnippet))

    (when (boundp 'elpy-rpc-virtualenv-path)
      ;; Aquesta opci贸 s'ha introdu茂t en una refactoritzaci贸 de elpy amb
      ;; posterioritat a la versi贸 1.31.0. Enlloc de comparar versions
      ;; trobo m茅s robust comprovar si l'opci贸 existeix.
      (customize-set-value 'elpy-rpc-virtualenv-path 'current))
    (define-key elpy-mode-map (kbd "C-c C-g") nil)
    (define-key elpy-mode-map (kbd "C-c M-g") 'elpy-pdb-map))
#+end_src

La comanda =flake8= es pot configurar des de l'arxiu
=~/.config/flake8=.

***** snippets

El snippet =super= definit per =elpy= adapta la sintaxi del codi
generat a la versi贸 de l'interpret python /actiu/. A莽貌 resulta
inconvenient quan es desenvolupa amb python 3 per貌 el codi ha de
funcionar amb python 2 i 3.

Per resoldre-ho he redefinit localment el snippet i he introdu茂t la
variable =my/elpy-python-6= per controlar el comportament del snippet:

- si el valor 茅s /cert/ genera codi que funciona en python 2 i 3.

- si 茅s /fals/ genera codi espec铆fic

El valor per defecte 茅s =nil= i es pot canviar per projecte en
=.dir-locals.el=.

#+begin_warning
Perqu猫 a莽貌 funcioni cal que el directori dels snippets aparegui en
=yas-snippet-dirs= abans del directori de snippets de =elpy=.
#+end_warning

**** =pep8=                                                          :manual:

https://gist.github.com/ieure/302847

Pel seu funcionament requereix una comanda externa:

#+begin_src sh :tangle no
  pip install pycodestyle
#+end_src

La configuraci贸 detecta si =pycodestyle= est disponible. En cas
negatiu utiliza la comanda =pep8=.

#+begin_src emacs-lisp :tangle yes
  (use-package python-pep8
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands (python-pep8 pep8)
    :config
    (when (executable-find "pycodestyle")
      (customize-set-value 'python-pep8-command "pycodestyle"))
    (customize-set-value 'python-pep8-options '("--repeat" "--max-line-length=150")))
#+end_src

**** =pylookup=                                                  :desactivat:

https://github.com/tsgates/pylookup

Acc茅s a la documentaci贸. Sembla que cal baixar la documentaci贸 en
format HTML i executar un programa per indexar-la i crear una mena de
base de dades. Suposo que funcionaria per qualsevol documentaci贸, no
sols la de python.

Mai he aconseguit integrar-ho en el meu workflow, segons el que
necessito en cada cas tiro de /eldoc/, busco la definici贸 i miro el
codi font, accedeixo a la documentaci贸 online o tiro de google.

#+begin_src emacs-lisp :tangle no
  (autoload 'pylookup-lookup "pylookup")
  (autoload 'pylookup-update "pylookup")

  (eval-after-load "python"
    '(progn
       (define-key python-mode-map (kbd "C-c h") 'pylookup-lookup)))

  (add-hook 'python-mode-hook
            (lambda()
              (let ((pylookup-dir (arv/startup-get-absolute-path "site-lisp/pylookup")))
                (setq pylookup-program (arv/path-join pylookup-dir "pylookup.py"))
                (setq pylookup-db-file (arv/path-join pylookup-dir "pylookup.db"))
                )))
#+end_src

**** =pydoc info=                                                :desactivat:

https://bitbucket.org/jonwaltman/pydoc-info/

Acc茅s a la documentaci贸 en format /info/ (p.e. la generada per
/sphinx/ per python, django etc). Tampoc vaig aconseguir integrar-ho
en el workflow.

[[http://www.draketo.de/light/english/free-software/read-your-python-module-documentation-emacs][Guia de configuraci贸.]]

#+begin_src emacs-lisp :tangle no
  (autoload 'info-lookup-add-help "info-look" "" nil nil)

  (eval-after-load "python"
    '(progn
       (info-lookup-add-help
        :mode 'python-mode
        :parse-rule 'pydoc-info-python-symbol-at-point
        :doc-spec
        '(("(python)Index" pydoc-info-lookup-transform-entry)
          ("(django14)Index" pydoc-info-lookup-transform-entry)))))
#+end_src

**** =pylint=                                                        :manual:

https://github.com/PyCQA/pylint/tree/master/elisp

El paquet =pylint.el= no est disponible en /ELPA/. Forma part de la
distribuci贸 de =pylint= i s'ha copiat dins el directori
=site-packages=. Requereix la comanda externa =pylint=, prove茂da pel
paquet python =pylint=:

#+begin_src sh :tangle no
  pip install pylint
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pylint
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pylint)
#+end_src

**** =pytest=                                                        :manual:

Integra el paquet python =pytest= dins emacs. La implementaci贸
original 茅s de [[https://github.com/ionrock/pytest-el][ionrock]] per貌 utilitzo un [[https://github.com/patxoca/pytest-el][fork]] propi.

#+begin_src sh :tangle yes
  ./scripts/clone_git https://github.com/patxoca/pytest-el.git
  ./scripts/compile_package pytest-el
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package pytest
    :load-path "site-lisp/pytest-el"
    ;; 煤nicament es defineixen autoloads per les funcions utilitzades en
    ;; la configuraci贸.
    :commands (pytest-all
               pytest-one
               pytest-rerun-last
               pytest-mode-enable-if-test-module
               pytest-run-tests-for-current-module)

    :init
    ;; cal definir-la abans d'activar el mode
    (setq pytest-mode-keymap-prefix "C-c m t")
    (with-eval-after-load "python"
      (my/bind-keys python-mode-map '(("C-c m t a" pytest-all)))
      (my/bind-keys python-mode-map '(("C-c m t t" pytest-run-tests-for-current-module))))

    :config
    (my/bind-keys pytest-mode-map
                  '(("<f12>" pytest-one)))

    ;; WARNING: definir `pytest-cmd-flags' com segura per qualsevol
    ;; cadena 茅s potencialment perill贸s, deixa la porta oberta a valors
    ;; maliciosos com ara " ; rm -Rf $HOME/ #"
    (put 'pytest-cmd-flags 'safe-local-variable 'stringp))
#+end_src

**** =python=                                                       :builtin:

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (setq python-shell-virtualenv-path (getenv "VIRTUAL_ENV"))
    (setq python-indent-guess-indent-offset nil)

    ;; defineix l'interpret
    (customize-set-value 'python-shell-interpreter "ipython")
    (customize-set-value 'python-shell-interpreter-args "-i --simple-prompt")


    ;; activates source tracking when debugging with pdb from a shell
    ;; buffer
    (add-hook 'comint-output-filter-functions 'python-pdbtrack-comint-output-filter-function)

    (elpy-enable))
#+end_src

**** =sphinx-doc=

https://github.com/naiquevin/sphinx-doc.el

=sphinx-doc= is an emacs minor mode for inserting docstring skeleton
for Python functions and methods. The structure of the docstring is as
per the requirement of the Sphinx documentation generator.

#+begin_src emacs-lisp :tangle yes
  (use-package sphinx-doc
    :ensure t
    :commands sphinx-doc-mode)
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (my/bind-keys
     python-mode-map
     '(("C-c m 8" python-pep8)
       ("C-c m m" pyx/make)
       ("C-c m p" pylint)
       ("C-c m w f" pyx/refactor-wrap-for)
       ("C-c m w i" pyx/refactor-wrap-if-else)
       ("C-c m w t" pyx/refactor-wrap-try-except)
       ("C-c m w w" pyx/refactor-wrap-while)
       ("C-c m i s d " pyx/add-setup-dependency)
       ("C-c m i p n" pyx/insert-current-package-name)

       ;; pytest
       ("<f12>" pytest-all)
       ("C-<f12>" pytest-rerun-last)

       ("<f9>" pyx/make)
       ("s-<tab>" python-indent-shift-right)
       ("s-<iso-lefttab>" python-indent-shift-left)
       (":" pyx/electric-colon)
       ("`" pyx/smart-grave)
       ("C-m" newline-and-indent)
       ("C-c j i" pyx/nav-goto-first-import)
       ("C-c j S" pyx/visit-setup-py)
       ("C-c j T" pyx/visit-test-module)
       ("C-=" arv/rst-underline-header)
       ("C-," arv/wm-cycle-2)
       ("C->" indent-rigidly-right-to-tab-stop)
       ("C-<" indent-rigidly-left-to-tab-stop)
       ))
    (my/bind-keys
     elpy-mode-map
     '(("M-<up>" pyx/nav-up-list)
       ("M-<down>" pyx/nav-down-list)
       ("M-S-<down>" elpy-nav-move-line-or-region-down)
       ("M-S-<up>" elpy-nav-move-line-or-region-up)
       ))
    (define-key python-mode-map (kbd "C-<tab>")
      (make-hippie-expand-function
       '(try-expand-dabbrev
         ;; try-expand-tags
         try-expand-dabbrev-all-buffers)
       t)))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'python
    (add-hook 'python-mode-hook
              (lambda ()
                ;; outline
                (outline-minor-mode t)
                (set
                 (make-local-variable 'outline-regexp)
                 "[\t ]*\\(class\\|def\\|if\\|elsif\\|else\\|while\\|for\\|try\\|except\\|finally\\)\\>")

                ;; ressalta les l铆nies on hi ha un breakpoint
                (highlight-lines-matching-regexp "^[[:space:]]*import i?pdb")
                (highlight-lines-matching-regexp "^[[:space:]]*i?pdb.set_trace()")

                ;; company-mode
                (company-mode t)

                ;; afecta a indent-rigidly-(left|righ)-to-tab-stop
                (setq python-indent-offset 4)
                (setq tab-width python-indent-offset)

                ;; ressalta els nivell d'indentacio
                ;; (arv/highlight-indentation-mode 0)

                ;; pylint/flymake-pylint
                ;; (pylint-add-menu-items)
                ;; (flymake-mode 1)

                ;; sphinx-doc
                (sphinx-doc-mode t)

                (superword-mode 1)
                (pytest-mode-enable-if-test-module)
                )))
#+end_src

*** python-django

Configuracions per facilitar el treball en projectes django:

- introspecci贸: obtindre les apps, els models etc. (=djira-el=).

- operacions amb les /apps/: visitar un model, una vista, consultar la
  documentaci贸 etc. (=django-el=).

- edici贸 de plantilles (=pony-tpl=).

**** =django-el=                                                     :manual:

https://github.com/patxoca/django-el.git

Biblioteca que implementa funcions que faciliten la navegaci贸 dins un
projecte django.

#+begin_src emacs-lisp :tangle yes
  (use-package django-el
    :ensure t
    :init (setq django-el-prefix-key "C-c d")
    :commands (django-el-mode
               django-el-jump-to-javascript-controller
               django-el-jump-to-template
               django-el-autopair-template-tag))
#+end_src

**** =djira-el=                                                   :manual:

https://github.com/patxoca/djira-el

Biblioteca que permet accedir a la api definida per =djira= ([[https://github.com/patxoca/djira][github]]).
Aquest paquet substitueix a =python-django=, que ja no 茅s mantingut.

Pel seu funcionament requereix que django estigui executant-se i que
tingui instal路lada l'aplicaci贸 =djira=.

#+begin_src emacs-lisp :tangle yes
  (use-package djira-el
    :ensure t
    :commands (djira-buffer-belongs-in-app-p))
#+end_src

**** =pony-tpl=                                                      :manual:

https://github.com/davidmiller/pony-mode

=pony-tpl= defineix un mode menor per editar plantilles django. Forma
part de =pony-mode= (abandonat?).

S'ha incorporat una versi贸 local dins el directori =site-lisp= de la
configuraci贸 en la que s'han eliminat les depend猫ncies de =pony-mode=.

#+begin_src emacs-lisp :tangle yes
  (use-package pony-tpl
    :ensure nil
    :load-path "conf.d/site-lisp"
    :commands pony-tpl-mode)
#+end_src

**** Configuraci贸

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "python"
    (my/bind-keys python-mode-map
                  '(("C-c j t" django-el-jump-to-template)
                    ("C-c j j" django-el-jump-to-javascript-controller))))

  (with-eval-after-load "sgml-mode"
    (my/bind-keys html-mode-map
                  '(("C-c j t" django-el-jump-to-template)
                    ("%" django-el-autopair-template-tag)))
    (add-hook 'html-mode-hook
              (lambda ()
                (when (djira-buffer-belongs-in-app-p (current-buffer))
                  (pony-tpl-mode)))))
#+end_src

*** rst
**** Funcions auxiliars
***** Documents =rst=

Funcions per treballar amb documents =rst=.

#+begin_src emacs-lisp :tangle yes
  (defun arv/rst-underline-header (caracter)
    (interactive "cCaracter: ")
    (let ((l (length (buffer-substring-no-properties (progn
                                                       (back-to-indentation)
                                                       (point))
                                                     (progn
                                                       (end-of-line)
                                                       (point)))))
          (indentation-level (progn
                               (back-to-indentation)
                               (current-column))))
      (when l
        (end-of-line)
        (insert "\n")
        (insert (make-string indentation-level ?\s))
        (insert (make-string l caracter))
        (insert "\n\n")
        (insert (make-string indentation-level ?\s)))))

  (defun arv/-rst-after-role-p ()
    "Return t if point is after a role."
    (looking-back ":\\w+:" (line-beginning-position)))

  (defun arv/rst-smart-grave ()
    "Tries to be smart about common ` usage patterns.

  If point is after a role (like :xref:) inserts ``, elsewhere
  inserts ```` (inline code literal). Point is left in the middle.

  If the region is active surround it and point is left at the
  end."
    (interactive)
    (let ((begin (point))
          (end   (point))
          (active (region-active-p))
          (delimiter))
      (when active
        (setq begin (min (region-beginning) (region-end)))
        (setq end   (max (region-beginning) (region-end))))
      (goto-char begin)
      (setq delimiter (if (arv/-rst-after-role-p)
                          "`"
                        "``"))
      (insert delimiter)
      (goto-char (+ end (length delimiter)))
      (insert delimiter)
      (unless active
        (backward-char (length delimiter)))))

  (defun arv/rst-smart-asterisk ()
    "Tries to be smart about * usage.

  If there's only withespace before point it assumes that it's a
  list bullet and inserts '* ', otherwise it inserts '**' and
  leaves point in the middle."
    (interactive)
    (if (string-match-p "^\s*$"
                        (buffer-substring-no-properties (line-beginning-position) (point)))
        (insert "* ")
      (insert "**")
      (backward-char 1)))
#+end_src

***** /sphinx/

Comandes per facilitar el treball amb documentaci贸 processada amb
[[http://www.sphinx-doc.org/en/master/][sphinx]].

Les funcions per compilar el projecte operen amb el Makefile generat
per sphinx. El Makefile es busca en el directori actual (on est
l'arxiu del buffer actual) i en els directoris pare.

#+begin_src emacs-lisp :tangle yes
  (defun arv/-sphinx-locate-makefile ()
    "Busca l'arxiu Makefile comen莽ant en el directori on est el
  buffer actual i visitant els directoris pare.

  Si troba el Makefile retorna la ruta absoluta del directori que
  el conte. Retorna nil si no el troba."
    (let ((cwd (file-name-directory (expand-file-name (buffer-file-name)))))
      (while (and (not (string= cwd "/"))
                  (not (file-exists-p (concat cwd "Makefile"))))
        (setq cwd (file-name-directory (directory-file-name cwd))))
      (if (string= cwd "/")
          nil
        cwd)))

  (defun arv/-sphinx-build (target)
    "Intenta executar 'make <target>'"
    (let ((makefile (arv/-sphinx-locate-makefile)))
      (unless (null makefile)
        (compilation-start (format "make -k -C %s %s" makefile target)
                           t
                           (lambda (mode) "*sphinx*")))))

  (defun arv/sphinx-build-latexpdf ()
    "Genera PDF"
    (interactive)
    (arv/-sphinx-build "latexpdf"))

  (defun arv/sphinx-build-html ()
    "Genera HTML"
    (interactive)
    (arv/-sphinx-build "html"))

  (defun arv/sphinx-run-doctest ()
    "Executa els doctest"
    (interactive)
    (arv/-sphinx-build "doctest"))
#+end_src

**** Definicions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "rst"
    (my/bind-keys
     rst-mode-map
     '(("*" arv/rst-smart-asterisk)
       ("`" arv/rst-smart-grave)
       ("<f9>" arv/sphinx-build-latexpdf)
       ("C-<f9>" arv/sphinx-run-doctest)
       ("M-<f9>" arv/sphinx-build-html)
       ("C-=" arv/rst-underline-header))))
#+end_src

**** /Hook/

#+begin_src emacs-lisp :tangle yes
  (add-hook 'rst-mode-hook
            (lambda ()
              (auto-fill-mode 1)
              (flyspell-mode 0)
              ;; activa el resaltat d'espai en blanc al final de l铆nia
              (set-variable 'show-trailing-whitespace t)))
#+end_src

*** typescript

Configuraci贸 de =typescript=.

#+begin_src emacs-lisp :tangle yes
  (use-package typescript-mode
    :ensure t)
#+end_src

**** Funcions auxiliars

***** compilar

La comanda =compile= no mostra correctament els codis ANSI generants
durant la compilaci贸. Aquesta comanda supleix la mancan莽a.

#+begin_src emacs-lisp :tangle yes
  (defun my/typescript-compile ()
    "Intenta executar 'tsc'"
    (interactive)
    (let ((project-root (locate-dominating-file default-directory "tsconfig.json")))
      (if project-root
          (compilation-start (format "cd %s ; tsc" project-root)
                             t
                             (lambda (mode) "*tsc*"))
        (user-error "No es troba 'tsconfig.json'"))))
#+end_src

**** Combinacions de tecles

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "typescript-mode"
    (my/bind-keys
     typescript-mode-map
     '(("<f9>" my/typescript-compile))))
#+end_src

**** Hook

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load "typescript-mode"
    (add-hook
     'typescript-mode-hook
     (lambda ()
       ;; electric-pair: insereix <>
       (let ((ts-electric-pairs '((?< . ?>))))
         (setq-local electric-pair-pairs (append electric-pair-pairs ts-electric-pairs))
         ))))
#+end_src

*** vue                                                          :desactivat:

Actualment no l'utilitzo.

#+begin_src emacs-lisp :tangle no
(require 'mmm-mode)
(require 'vue-mode)
(mmm-add-mode-ext-class nil "\\.vue\\'" 'vue-mode)
#+end_src

*** zope

Associa modes als arxius relacionats amb zope:

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.pt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.cpt$" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.zpt$" . html-mode))

  (add-to-list 'auto-mode-alist '("\\.vpy$" . python-mode))
  (add-to-list 'auto-mode-alist '("\\.cpy$" . python-mode))

  (add-to-list 'auto-mode-alist '("\\.css.dtml$" . css-mode))
#+end_src

** Variat

Ressalta el par猫ntesi corresponent a l'actual.

#+begin_src emacs-lisp :tangle yes
  (show-paren-mode 1)
#+end_src

Esborra els espais en blanc al final de les l铆nies en el moment de
guardar l'arxiu.

#+begin_src emacs-lisp :tangle yes
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

Si estem en un GUI canvia el t铆tol de la finestra per mostrar el nom
del buffer actiu i la ruta de l'arxiu.

#+begin_src emacs-lisp :tangle yes
(when window-system
  (setq frame-title-format '("emacs %b (%f)")))
#+end_src

De vegades es guarda repetidament la mateixa marca. Aquest /advice/
elimina les repeticions, accelerant la navegaci贸.

http://endlessparentheses.com/faster-pop-to-mark-command.html

#+begin_src emacs-lisp :tangle yes
  (defadvice pop-to-mark-command (around ensure-new-position activate)
    (let ((p (point)))
      (dotimes (i 10)
        (when (= p (point)) ad-do-it))))
#+end_src

Per recuperar les marques de la pila cal utilitzr =C-u C-SPC= per cada
marca, poc gil. Aquest canvi permet utilitzar =C-u C-SPC C-SPC ...=

#+begin_src emacs-lisp :tangle yes
  (setq set-mark-command-repeat-pop t)
#+end_src

En el meu mon les frases es separen amb un espai, no dos.

#+begin_src emacs-lisp :tangle yes
  (customize-set-value 'sentence-end-double-space nil)
#+end_src

Prefereixo utilitzar espais pel sagnat, conserven el format.

#+begin_src emacs-lisp :tangle yes
  (customize-set-variable 'indent-tabs-mode nil)
  (customize-set-variable 'tab-width 4)
#+end_src

Algunes comandes, que es consideren /perilloses/ pels /novatos/, estan
desactivades. A aquestes al莽ades crec que puc activar-les totes:

#+begin_src emacs-lisp :tangle yes
  (setq disabled-command-function nil)
#+end_src

Ignora maj煤scules/min煤scules al ordenar l铆nies. Normalment ordeno per
facilitar-me la vida buscant elements. Segons a莽貌 sembla l貌gic ignorar
les difer猫ncies de maj煤scules/min煤scules.

#+begin_src emacs-lisp :tangle yes
  (setq sort-fold-case t)
#+end_src

Per classificar:

#+begin_src emacs-lisp :tangle yes
  (setq inhibit-eol-conversion nil)

  (setq text-scale-mode-step 1.1)

  ;; assorted
  (setq ansi-color-for-comint-mode t)
  (setq current-language-environment "UTF-8")

  ;; display-buffer-reuse-frames is a variable defined in `window.el'.
  ;; Its value is nil
  ;;
  ;;   This variable is obsolete since 24.3;
  ;;   use a `reusable-frames' alist entry in `display-buffer-alist'.
  ;;
  ;; Documentation:
  ;; Non-nil means `display-buffer' should reuse frames.
  ;; If the buffer in question is already displayed in a frame, raise
  ;; that frame.
  (setq display-buffer-reuse-frames t)

  (setq next-line-add-newlines nil)
  (setq scroll-preserve-screen-position t)
  (customize-set-value 'scroll-step 1)
  (customize-set-value 'scroll-conservatively 10000)
  (setq tooltip-mode t)
  (setq transient-mark-mode t)
  (setq visible-bell nil)
#+end_src

*** Backups

El 99% del temps els arxius de backup creats durant l'edici贸 s贸n m茅s
una mol猫stia que altra cosa. Es mouen a un directori de backup per si
cal recuperar-los.

#+begin_src emacs-lisp :tangle yes
  (let ((backup-dir (arv/path-concat user-emacs-directory "backups" "files")))
    (unless (file-directory-p backup-dir)
      (make-directory backup-dir t))
    (setq backup-directory-alist `(("." . ,backup-dir))))
#+end_src

*** Diferenciar modes /insert/ i /overwrite/

Es aquest apartat es configura el canvi del color del cursor per
indicar que ens troben en mode inserci贸 o sobreescriptura.

Guarda el color del cursor en mode /insert/ per poder restaurar-lo al
alternar entre /overwrite/ i /insert/.

#+begin_src emacs-lisp :tangle yes
  (when (null my/face-cursor-insert-background-color)
    (setq my/face-cursor-insert-background-color
          (face-attribute 'cursor :background)))
#+end_src

La soluci贸 original t茅 un problema, el color del cursor 茅s global
mentre que el mode insertar/sobreescriure 茅s local a cada buffer. Al
cambiar de buffer no s'ajusta el color del cursor.

#+begin_src emacs-lisp :tangle no
  (defadvice overwrite-mode (after overwrite-mode-adjust-cursor activate)
    "Change cursor color when enabling/disabling overwrite mode."
    (set-cursor-color (if overwrite-mode
                          "purple"
                        my/face-cursor-insert-background-color)))
#+end_src

No he trobat cap /hook/ que es dispari si es canvia de buffer (=C-x
b=) o de finestra (=C-x o=). Aquesta soluci贸 s'executa despr茅s de cada
comanda amb el que hauria de ser acurada.

#+begin_src emacs-lisp :tangle yes
  (defun my/update-cursor-color-for-insert-overwrite-mode ()
    (set-cursor-color (if overwrite-mode
                          my/face-cursor-overwrite-background-color
                        my/face-cursor-insert-background-color)))

  (add-hook 'post-command-hook #'my/update-cursor-color-for-insert-overwrite-mode)
#+end_src

No espero que suposi un problema pel rendiment. Si ralentitza
apreciablement l'execuci贸 una altra possibilitat (cutre) seria aplicar
/advice/ tamb茅 a les funcions que canvien de buffer i de finestra.

** Comandes
   :PROPERTIES:
   :ID:       02df8b30-de79-489f-b4c9-13162d5d2784
   :END:

Comandes que proveeixen funcionalitat a l'usuari (i poden estar
lligades a combinacions de tecles).

*** =arv/alternar-mida-font=

De vegades 茅s interessant augmentar temporalment la mida de la font
(una visita amb qui cal revisar codi). Fins ara utilitzava =C-+= i
=C--= per貌 no funciona b茅 amb =company-mode=, cal fer-ho buffer a
buffer i cada buffer acaba amb una mida de lletra diferent.

Aquesta funci贸 alterna entre una mida per defecte i una de gran.

Pel moment les mides estan fixades al cos de la funci贸. s frgil. He
provat guardant la mida inicial i comparant amb aquest valor per
determinar l'estat per貌 no funciona. El valor guardat 茅s 100 (el
assigant en la secci贸 [[*Faces][Faces]]) per貌 el llegit posteriormente en la
funci贸 茅s 98. No s茅 si el tema o algun paquet canvia el valor o si 茅s
algun tipus d'arrodoniment de la mida. Fins que esbrini una soluci贸
millor 茅s queda fixat i s'utilitza un /flag/ bi-estat per seguir la
pista de l'esta.

#+begin_src emacs-lisp :tangle yes
  (defvar arv/big-font-enabled nil)
  (defvar my/face-default-height (face-attribute 'default :height))
  (defvar my/face-default-big-height (truncate (* my/face-default-height 1.4)))

  (defun arv/alternar-mida-font ()
    "Alterna entre font 'normal' i 'gran'."
    (interactive)
    (set-face-attribute 'default nil
                        :height (if arv/big-font-enabled
                                    my/face-default-height
                                  my/face-default-big-height))
    (setq arv/big-font-enabled (not arv/big-font-enabled)))
#+end_src

*** =my/bash-terminal=

No m'acostumo a utilitzar la comanda =shell=, la meva teoria 茅s que no
permet utilizar les tecles nadiues. Provar茅 una temporada amb =term=.

#+begin_src emacs-lisp :tangle yes
  (defun my/bash-terminal ()
    "Obre una terminal executant bash."
    (interactive)
    (term "/bin/bash"))
#+end_src

*** =arv/downcase-word= i =arv/upcase-word=

Converteix a maj煤scules/min煤scules la paraula en el punt. A difer猫ncia
de =upcase-word= i =downcase-word=, no cal situar el punt al
comen莽ament de la paraula.

/Robat/ de http://oremacs.com/2014/12/23/upcase-word-you-silly/

#+begin_src emacs-lisp :tangle yes
  (defun arv/upcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'upcase-word))))

  (defun arv/downcase-word (arg)
    (interactive "P")
    (when (looking-at-p "\\sw")
      (save-excursion
        (unless (looking-back "\\b")
          (backward-word))
        (call-interactively 'downcase-word))))
#+end_src

*** =arv/duplicate-line-or-region-dwim=

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-dwim (arg)
    "Duplicate current line.

  - Without prefix argument duplicate current line.

  - Positive prefix ARG means include previous ARG lines plus the
    current one.

  - If ARG is negative include current line plus next ARG lines.

  - If the region is active duplicates all the complete lines
    intersecting with the region. ARG is ignored."
    (interactive "P")
    (let (start
          end
          where
          text)
      (cond
       ((region-active-p)
        (setq beg (save-excursion
                    (goto-char (min (point) (mark)))
                    (line-beginning-position)))
        (setq end (save-excursion
                    (goto-char (max (point) (mark)))
                    (forward-line)
                    (line-beginning-position)))
        (setq where end))
       ((null arg)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position 2))
        (setq where end))
       ((< arg 0)
        (setq beg (line-beginning-position))
        (setq end (line-beginning-position (+ (- arg) 2)))
        (setq where beg))
       (t
        (setq beg (line-beginning-position (+ (- arg) 1)))
        (setq end (line-beginning-position 2))
        (setq where end)))
      (save-excursion
        (goto-char end)
        (when (eobp)
          (newline)
          (setq end (1+ end))
          (unless (= where beg)
            (setq where end))))
      (setq text (buffer-substring-no-properties beg end))
      (goto-char where)
      (insert text)
      (goto-char where)
      (back-to-indentation)))
#+end_src

*** =arv/duplicate-line-or-region-and-comment-dwim=

#+begin_src emacs-lisp :tangle yes
  (defun arv/duplicate-line-or-region-and-comment-dwim (start stop)
    "Duplicate the whole lines i region and comment them.
  Mostly equivalent to select region, copy, paste, select again and
  comment region, but the region is not copied to the kill ring and
  the text properties are removed."
    (interactive "r")
    (let* ((beg (progn (goto-char start) (line-beginning-position)))
           (end (progn (goto-char stop) (line-end-position)))
           (text (buffer-substring-no-properties beg end)))
      (goto-char end)
      (newline)
      (insert text)
      (comment-region beg end)))
#+end_src

*** =arv/generate-random-uuid= i =arv/insert-random-uuid=

#+begin_src emacs-lisp :tangle yes
  (defun arv/generate-random-uuid ()
    (with-temp-buffer
      (shell-command "uuidgen -r" t)
      (beginning-of-buffer)
      (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun arv/insert-random-uuid ()
    "Insert random UUID"
    (interactive)
    (insert (arv/generate-random-uuid)))
#+end_src

*** =arv/goto-line=

Com =goto-line= per貌 activa =linum-mode= per facilitar identificar la
l铆nia.

No ho utilitzo gaire.

#+begin_src emacs-lisp :tangle yes
  (defun arv/goto-line ()
    "Like `goto-line' but temporarily display absolute line
  numbers."
    (interactive)
    (let ((linum-enabled linum-mode))
      (unwind-protect
          (let ((relative-linum-enabled nil))
            (linum-mode 1)
            (call-interactively 'goto-line))
        (unless linum-enabled
          (linum-mode -1)))))
#+end_src

*** =my/json-prettify=

https://coderwall.com/p/2vnxaw/beautify-json-in-emacs

#+begin_src emacs-lisp :tangle yes
  (defun my/json-prettify ()
    (interactive)
    (let ((b (if mark-active (min (point) (mark)) (point-min)))
          (e (if mark-active (max (point) (mark)) (point-max))))
      (shell-command-on-region
       b e
       "python -mjson.tool"
       (current-buffer) t)))
#+end_src

*** =my/kill-region=

De vegades premo =C-w= per error i esborro la regi贸 quan no est
marcada, resulta molest. Aquesta comanda executa =kill-region=
煤nicament si la regi贸 est activa.

#+begin_src emacs-lisp :tangle yes
  (defun my/kill-region (beg end &optional region)
    "kill-region nom茅s si la regi贸 est activa."
    (interactive (list (mark) (point) 'region))
    (when (region-active-p)
      (kill-region beg end region)))
#+end_src

*** =my/kill-to-beginning-of-line= i =my/kill-to-indentation=

Moltes vegades vull esborrar cap al principi de la l铆nia enlloc de cap
al final. =kill-line= permet esborrar cap enrere especificant un
prefix negatiu per貌 al especificar -1 esborra fins la l铆nia anterior.
No he trobat com fer el que vull.

Aquestes comandes implementen variants d'aquesta idea, esborren fins
el comen莽ament de la l铆nia, fins al sagnat o combinen les dos.

#+begin_src emacs-lisp :tangle yes
  (defun my/kill-to-beginning-of-line ()
    "Esborra enrere fins el comen莽ament de la l铆nia."
    (interactive)
    (kill-region (line-beginning-position) (point)))

  (defun my/kill-to-indentation ()
    "Esborra enrere fins el sagnat."
    (interactive)
    (let ((position (save-excursion
                      (back-to-indentation)
                      (point))))
      (kill-region position (point))))

  (defun my/kill-to-indentation-or-beginning-of-line ()
    "Esborra enrere fins el sagnat i si el punt ja est en el
  sagnat esborra fins al comen莽ament de la linia."
    (interactive)
    (let ((indentation (save-excursion
                         (back-to-indentation)
                         (point))))
      (if (= indentation (point))
          (kill-region (line-beginning-position) indentation)
        (kill-region indentation (point)))))
#+end_src

*** =arv/kill-ring-save-word-at-point=

#+begin_src emacs-lisp :tangle yes
  (defun arv/kill-ring-save-word-at-point ()
    "Copia un text en el kill ring. El seu comportament varia
  depenent de si la marca est o no activa:

  - si est activa delega en `kill-ring-save' i es copia el text
    seleccionat.

  - sin贸 es copia el s铆mbol sobre el que est situat el cursor."
    (interactive)
    (if mark-active
        (call-interactively 'kill-ring-save)
      (kill-new (thing-at-point 'symbol t))))
#+end_src

*** =arv/open-line-after-and-indent=, =arv/open-line-before-and-indent=

#+begin_src emacs-lisp :tangle yes
  (defun arv/open-line-before-and-indent (n)
    "Insereix una l铆nia abans de l'actual i indenta. Amb un prefix
  num猫ric N insereix N l铆nies."
    (interactive "*p")
    (open-line n)
    (indent-according-to-mode))

  (defun arv/open-line-after-and-indent (n)
    "Insereix una l铆nia despr茅s de l'actual i indenta. Amb un
  prefix num猫ric N insereix N l铆nies."
    (interactive "*p")
    (end-of-line)
    (newline n)
    (indent-according-to-mode))
#+end_src

*** =arv/query-replace=

#+begin_src emacs-lisp :tangle yes
  (defun arv/query-replace (&optional arg)
    "Replacement for `query-replace'.

  - It proposes the symbol at point as the initial value for the
    search string.

  - If the region is active it contraints the replacement,
    otherwise operate on the whole buffer.

  - Without prefix argument performs `query-replace'.

  - With C-u performs `replace-string'.

  In any case point is preserved."
    (interactive "*P")
    (let* ((old-string (read-string "Replace: " (thing-at-point 'symbol t)))
           (new-string (read-string (concat "Replace " old-string " with: ") ""))
           (start (if mark-active (min (mark) (point)) (point-min)))
           (end   (if mark-active (max (mark) (point)) (point-max))))
      (save-excursion
        (if (not arg)
            (query-replace old-string new-string nil start end)
          (goto-char start)
          (while (search-forward old-string end t)
            (replace-match new-string))))))
#+end_src

*** =my/compile-with-comint-enabled=

cpctelera inclou color en la sortida de les comandes, espec铆ficament
en la compilaci贸. La comanda =compile= per defecte mostra els codis
ANSI i la sortida resulta dif铆cil de llegir. Es pot invocar amb =C-u=
per activar =comint-mode= per貌 mai hi penso i requereix dos tecles.
Addicionalment cal escriure/confirmar la comanda de compilaci贸.

Aquesta funci贸 茅s la contraria de =compile=, per defecte activa
=comint-mode= i amb =C-u= el desactiva. No pregunta per la comanda de
compilaci贸, utilitza el valor de la variable =compile-command= (cal
assignar-li un valor en la configuraci贸 d'Emacs o en un arxiu
=.dir-locals.el=).

T茅 dos detalls que caldria polir:

- el buffer s'obre en mode escriptura

- no reconneix la comanda =q= per tancar el buffer (insereix una =q=
  o, si es canvia a =read-only-mode=, d贸na un error /buffer de sols
  lectura/).

#+begin_src emacs-lisp :tangle yes
  (defun my/compile-with-comint-enabled (&optional no-comint)
    ""
    (interactive "P")
    (compile (eval compile-command) (not no-comint)))
#+end_src

*** =my/dedent-to-point=
    :PROPERTIES:
    :CREATED:  <2021-01-05 dt. 10:18>
    :END:

Una necessitat habitual 茅s esborrar els espais des del punt fins el
comen莽ament del text situat a la dreta del punt. Les funcions
=just-one-space= i similars afecten als espais als dos costats del
punt. =zap-up-to-char= valdria per貌 requereix massa atenci贸.

=my/dedent-to-point= implementa aquesta funcionalitat. Tamb茅 permet
fussionar l铆nies de forma m茅s gil que amb la combinaci贸 =M-d C-_= que
utilitzo actualment.

#+begin_src emacs-lisp :tangle yes
  (defun my/dedent-to-point (arg)
    "Si el punt est sobre un espai o al final de la l铆nia esborra
  tots els espais situats a la dreta fins trobar el primer carcter
  que no 茅s un espai o arribar al final de l铆nia.

  Si es crida amb un prefix (C-u) la cerca continua fins el final
  del buffer."
    (interactive "p")
    (when (or (eolp) (looking-at-p "\s"))
      (let* ((begin (point))
             (limit (if (= arg 1) (point-at-eol) (point-max)))
             (end (save-excursion
                    (skip-syntax-forward " " limit)
                    (point))))
        (delete-region begin end))))
#+end_src

*** =my/display-line-numbers-mode=

Activa/desactiva la numeraci贸 de les l铆nies. Si est disponible
=display-line-numbers-mode= la utilitza, en cas contrari utilitza
=linum-mode=.

#+begin_src emacs-lisp :tangle yes
  (defun my/display-line-numbers-mode ()
    "Activa la numeraci贸 de les l铆nies."
    (interactive)
    (if (fboundp 'display-line-numbers-mode)
        (if display-line-numbers-mode
            (display-line-numbers-mode 0)
          (my/enable-line-numbers-mode))
      (if linum-mode
          (linum-mode 0)
        (linum-mode 1))))
#+end_src

*** =my/rename-file-and-buffer=

Renombrar l'arxiu actual des d'Emacs requereix obrir un buffer
=dired=, localitzar l'arxiu i renombrar-lo. No 茅s especialment gil.
Aquesta comanda ho simplifica.

Basat en http://steve.yegge.googlepages.com/my-dot-emacs-file

#+begin_src emacs-lisp :tangle yes
  (defun my/rename-file-and-buffer ()
    "Renames both current buffer and file it's visiting."
    (interactive)
    (if (not (buffer-file-name))
        (message "Buffer '%s' is not visiting a file!" (buffer-name))
      (let ((new-name (read-shell-command "New name: ")))
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (rename-file (buffer-file-name) new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))
#+end_src

*** =my/unfill-paragraph=
    :PROPERTIES:
    :ID:       3ec64e49-8906-49c2-9377-8c9b44ae6e61
    :END:

De vegades, al enganxar un pargraf, =M-q= no fal el que vull i l'he
de convertir en una 煤nica l铆nia (a base de =C-e SUPR SPC=) o corregir
el sagnat manualment per tornar a ajustar-lo. Per exemple:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
  facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
  quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
  Sed bibendum.
#+end_example

Aquesta comanda, copiada de la configuraci贸 de Sacha Chua, automatitza
aquesta transformaci贸:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum.
#+end_example

i el pargraf resultat ara es pot ajustar satisfactoriament amb =M-q=:

#+begin_example
  - Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec
    facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
    quis odio. Nunc porta vulputate tellus. Nunc rutrum turpis sed pede.
    Sed bibendum.
#+end_example

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn
                   (barf-if-buffer-read-only)
                   (list t)))
    (let ((fill-column (point-max)))
      (fill-paragraph nil region)))
#+end_src

En funci贸 de l'煤s que en fci potser valdria la pena definir una
comanda equivalment a =M-Q M-q=.

*** =my/visit-emacs-config= etc.

Comandes per visitar arxius i directoris relacionats amb la
configuraci贸 d'emacs:

#+begin_src emacs-lisp :tangle yes
  (defun my/visit-emacs-config ()
    "Visita l'arxiu de configuraci贸 d'emacs."
    (interactive)
    (let ((settings-org (arv/path-concat arv/emacs-conf-dir "settings.org")))
      (find-file settings-org)))

  (defun my/visit-emacs-notes ()
    "Visita l'arxiu de configuraci贸 d'emacs."
    (interactive)
    (let ((settings-org (arv/path-concat arv/emacs-conf-dir "notes.org")))
      (find-file settings-org)))

  (defun my/visit-emacs-config-directory ()
    "Visita el directori de configuraci贸 d'emacs."
    (interactive)
    (find-file arv/emacs-conf-dir))
#+end_src

*** =my/xml-prettify-buffer=

De vegades em cal formatejar un document XML que ve en una 煤nica
l铆nia. Aquesta funci贸 formateja un buffer amb contingut XML (o HTML).

#+begin_src emacs-lisp :tangle yes
  (defun my/xml-prettify-buffer ()
    "Formateja (pretty print) un buffer xml."
    (interactive)
    (save-mark-and-excursion
      (sgml-pretty-print (point-min) (point-max))))
#+end_src

*** Comentari dins rectangle

http://pragmaticemacs.com/emacs/comment-boxes/

Semblant a [[help:comment-box][=comment-box=]], fa que el retangle tingui una amplada m铆nima
igual a =fill-column=.

#+begin_src emacs-lisp :tangle yes
  (defun bjm-comment-box (b e)
    "Draw a box comment around the region but arrange for the
  region to extend to at least the fill column. Place the point
  after the comment box."

    (interactive "r")

    (let ((e (copy-marker e t)))
      (goto-char b)
      (end-of-line)
      (insert-char ?  (- fill-column (current-column)))
      (comment-box b e 1)
      (goto-char e)
      (set-marker e nil)))
#+end_src

[[https://github.com/lewang/rebox2/blob/master/rebox2.el][rebox2]] 茅s una alternativa aparentment m茅s flexible.

*** Partir finestres

Idea treta del v铆deo [[https://www.youtube.com/watch?v=nKCKuRuvAOw&t=252][Emacs microhabit - Switching windows]] de Sacha
Chua: parteix una finestra horitzontal/verticalment i mostra un buffer
diferent en la nova finestra.

La versi贸 de Sacha Chua selecciona automticament el buffer, no m'he
pogut acostumar. Aquesta versi贸 permet triar el buffer (o arxiu) que
es mostrar en la nova finestra.

#+begin_src emacs-lisp :tangle yes
  (defun arv/split-windows-bellow (prefix)
    "Parteix la finestra verticalment i tria el buffer a mostrar.

  Al partir una finestra permet seleccionar quin buffer es mostrar
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estndard estan disponibles. Especialment 煤tils s贸n:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel路la la selecci贸, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-below)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))

  (defun arv/split-windows-right (prefix)
    "Parteix la finestra horitzontalment i tria el buffer a mostar.

  Al partir una finestra permet seleccionar quin buffer es mostrar
  en la nova finestra. Amb un prefix conserva el comportament
  original.

  Per llegir el buffer utilitza `ido-switch-buffer' amb el que els
  keybindings estndard estan disponibles. Especialment 煤tils s贸n:

  - `C-f': permet seleccionar un arxiu enlloc d'un buffer.

  - `C-g': cancel路la la selecci贸, mostrant el mateix buffer en les
    dos finestres."

    (interactive "P")
    (let ((new-window (split-window-right)))
      (unless prefix
        (with-selected-window new-window
          (ido-switch-buffer)))))
#+end_src

*** conversi贸 d'entitats HTML <-> carcter

Modificacions menors al codi trobat en:

https://stackoverflow.com/questions/24085067/is-there-an-emacs-package-for-html-escaping

- afegit =save-excursion=

- fer expl铆cit que cal concondncia maj煤scules/min煤scules en les
  cerques.

#+begin_src emacs-lisp :tangle yes
  (setq ar-html2uml
    '(
      ("&AElig;" "")
      ("&Aacute;" "")
      ("&Acirc;" "")
      ("&Agrave;" "")
      ("&Aring;" "")
      ("&Atilde;" "")
      ("&Auml;" "")
      ("&Ccedil;" "")
      ("&ETH;" "")
      ("&Eacute;" "")
      ("&Ecirc;" "")
      ("&Egrave;" "")
      ("&Euml;" "")
      ("&Iacute;" "")
      ("&Icirc;" "")
      ("&Igrave;" "")
      ("&Iuml;" "")
      ("&Ntilde;" "")
      ("&Oacute;" "")
      ("&Ocirc;" "")
      ("&Ograve;" "")
      ("&Oslash;" "")
      ("&Otilde;" "")
      ("&Ouml;" "")
      ("&Ouml;" "")
      ("&THORN;" "")
      ("&Uacute;" "")
      ("&Ucirc;" "")
      ("&Ugrave;" "")
      ("&Uuml;" "")
      ("&Yacute;" "")
      ("&aacute;" "谩")
      ("&acirc;" "芒")
      ("&acute;" "\x{00B4}")
      ("&aelig;" "忙")
      ("&agrave;" "")
      ("&aring;" "氓")
      ("&atilde;" "茫")
      ("&auml;" "盲")
      ("&brvbar;" "\x{00A6}")
      ("&ccedil;" "莽")
      ("&cedil;" "\x{00B8}")
      ("&cent;" "垄")
      ("&copy;" "漏")
      ("&curren;" "\x{00A4}")
      ("&deg;" "掳")
      ("&divide;" "梅")
      ("&eacute;" "茅")
      ("&ecirc;" "锚")
      ("&egrave;" "猫")
      ("&eth;" "冒")
      ("&euml;" "毛")
      ("&frac12;" "\x{00BD}")
      ("&frac14;" "\x{00BC}")
      ("&frac34;" "\x{00BE}")
      ("&iacute;" "铆")
      ("&icirc;" "卯")
      ("&iexcl;" "隆")
      ("&igrave;" "矛")
      ("&iquest;" "驴")
      ("&iuml;" "茂")
      ("&laquo;" "芦")
      ("&macr;" "炉")
      ("&micro;" "碌")
      ("&middot;" "路")
      ;; ("&nbsp;" " ")
      ("&not;" "卢")
      ("&ntilde;" "帽")
      ("&oacute;" "贸")
      ("&ocirc;" "么")
      ("&ograve;" "貌")
      ("&ordf;" "陋")
      ("&ordm;" "潞")
      ("&oslash;" "酶")
      ("&otilde;" "玫")
      ("&ouml;" "枚")
      ("&para;" "露")
      ("&plusmn;" "卤")
      ("&pound;" "拢")
      ("&raquo;" "禄")
      ("&reg;" "庐")
      ("&sect;" "搂")
      ("&shy;" "颅")
      ("&sup1;" "鹿")
      ("&sup2;" "虏")
      ("&sup3;" "鲁")
      ("&szlig;" "")
      ("&thorn;" "镁")
      ("&times;" "")
      ("&uacute;" "煤")
      ("&ucirc;" "没")
      ("&ugrave;" "霉")
      ("&uml;" "\x{00A8}")
      ("&uuml;" "眉")
      ("&yacute;" "媒")
      ("&yen;" "楼")
      ("&yuml;" "每")
      ))

  (defun ar-uml2html ()
    "Translate chars into html entities"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil)
          erg)
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (cadr ele) nil t 1)
            (setq erg (car ele))
            ;; Replacing with code starting from & upcases
            ;; Emacs bug?
            (replace-match "")
            (insert erg))))))

  (defun ar-html2uml ()
    "Translate html entities into text"
    (interactive "*")
    (let ((liste ar-html2uml)
          (case-fold-search nil))
      (save-excursion
        (dolist (ele liste)
          (goto-char (point-min))
          (while (search-forward (car ele) nil t 1)
            (replace-match "")
            (insert (cadr ele)))))))

#+end_src

*** conversi贸 de format DOS <-> UNIX

#+begin_src emacs-lisp :tangle yes
  (defun unix-to-dos ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun dos-to-unix ()
    "Converteix el contingut del buffer actiu a format DOS."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix))
#+end_src

*** =endless/comment-line-or-region=

Comment or uncomment current line and leave point after it. With
positive prefix, apply to N lines including current one. With negative
prefix, apply to -N lines above. If region is active, apply to active
region instead.

http://endlessparentheses.com/implementing-comment-line.html

#+begin_src emacs-lisp :tangle yes
  (defun endless/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above.
  If region is active, apply to active region instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range)))
      (forward-line 1)
      (back-to-indentation)))
#+end_src

*** =endless/isearch-symbol-with-prefix=

Like isearch, unless prefix argument is provided. With a prefix
argument P, isearch for the symbol at point.

http://endlessparentheses.com/quickly-search-for-occurrences-of-the-symbol-at-point.html

#+begin_src emacs-lisp :tangle yes
(defun endless/isearch-symbol-with-prefix (p)
  "Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
  (interactive "P")
  (let ((current-prefix-arg nil))
    (call-interactively
     (if p #'isearch-forward-symbol-at-point
       #'isearch-forward))))
#+end_src

*** =zap-up-to-char=

Kill up to but not including ARGth occurrence of CHAR. Case is ignored
if `case-fold-search' is non-nil in the current buffer. Goes backward
if ARG is negative; error if CHAR not found.

#+begin_src emacs-lisp :tangle yes
(defun zap-up-to-char (arg char)
  "Kill up to but not including ARGth occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     (read-char "Zap up to char: " t)))
  (zap-to-char arg char)
  (insert char)
  (when (> arg 0)
    (forward-char -1)))
#+end_src

** Mini paquets

Implementaci贸 de funcionalitat que requereix m茅s que una funci贸 per貌
no t茅 un paquet pr貌pi.

*** =arv-org=                                               :desactivat:brut:

#+begin_src emacs-lisp :tangle no
  ;;; assorted utilities

  (autoload 'org-agenda-files "org" "" nil nil)

  (defun arv/org-visit-agenda-file ()
    ""
    (interactive)
    (find-file
     (ido-completing-read "Agenda file:" (org-agenda-files) nil t)))


  (defun arv/org--get-tags ()
    (delete "" (split-string (or (org-entry-get (point) "TAGS") "") ":")))

  (defun arv/org--get-parent-tags ()
    (save-excursion
      (save-restriction
        (widen)
        (if (org-up-heading-safe)
            (delete "" (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
          nil))))

  (defun arv/org-remove-reduntant-tags ()
    "Walks the tree-at-point removing redundant tags."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         (lambda ()
           (let ((tags    (arv/org--get-tags))
                 (alltags (arv/org--get-parent-tags)))
             (dolist (tag tags)
               (when (member tag alltags)
                 (org-toggle-tag tag 'off)))))
         nil 'tree)))
    ;; Something gets corrupted and tags are not displayed. That
    ;; happens in my real org file, in test.org (simplest) it works ok.
    ;; Collapsing works around the issue.
    (org-shifttab 2))

  (defun arv/org-add-inherited-tags ()
    "Add inherited tags to sutree-at-point."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-back-to-heading)
        (let ((tags    (arv/org--get-tags))
              (alltags (arv/org--get-parent-tags)))
          (dolist (tag alltags)
            (unless (member tag tags)
              (org-toggle-tag tag 'on))))
        nil 'tree)))

  (defun arv/org-refile (&rest args)
    "Like org-refile but updates tags."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-refile args)
    (save-excursion
      (org-refile '(16))                 ;goto insertion
      (arv/org-remove-reduntant-tags)))


  (defun arv/org-archive-subtree (&rest args)
    "Add inherited tags on archiving."
    (interactive)
    (arv/org-add-inherited-tags)
    (apply 'org-archive-subtree args))


  (defun arv/org-start ()
    "Start org agenda within emacs server."
    (interactive)
    (server-start)
    (org-agenda nil "a"))
#+end_src

**** Codi desactivat                                             :desactivat:

Els enlla莽os /ecfg/ permeten referenciar la configuraci贸 d'emacs. Al
moure la configuraci贸 dins un document /org/ probablement ja no s贸n
necessaris.

Es mant茅 com exemple.

#+begin_src emacs-lisp :tangle no
  ;;; 'ecfg:' links
  ;;
  ;; 'ecfg:' URLs point to files in my emacs configuration. The links
  ;; are relative to `emacs-startup-dir'. Useful for tasks/notes when
  ;; hacking my emacs configuration.

  (defun arv/org-ecfg--relativize-to-startup-dir-maybe (path)
    "Converts .PATH into a path relative to
  `emacs-startup-dir'. Returns the relative path or nil if PATH is
  outside `emacs-startup-dir'.

  PATH must be absolute."
    (let ((abs-startup-dir (file-name-as-directory (expand-file-name emacs-startup-dir))))
      (if (s-starts-with-p abs-startup-dir path)
          (s-chop-prefix abs-startup-dir path)
        nil)))

  (defun arv/org-ecfg--link-at-point-get-range ()
    "Returns a list with the start and end position for the link at
  point. A link is delimited by blanks and beggining/end of line."
    (let ((start (save-excursion
                   (skip-syntax-backward "^-" (line-beginning-position))
                   (point)))
          (end (save-excursion
                 (skip-syntax-forward "^-" (line-end-position))
                 (point))))
      (list start end)))

  (defun arv/org-ecfg-open (path)
    "Visit the file within `emacs-startup-dir'."
    (find-file (arv/path-join emacs-startup-dir path)))

  (defun arv/org-ecfg-store-link ()
    "Store a link to an emacs config file."
    (let ((link (arv/org-ecfg--relativize-to-startup-dir-maybe (buffer-file-name))))
      (when link
        (org-store-link-props
         :type "ecfg"
         :link (concat "ecfg:" link)
         :description (format "%s" link)))))

  (defvar arv/org-ecfg-insert-link-at-point-history nil)

  (defun arv/org-ecfg-insert-link-at-point (arg)
    "Insert a ecfg link using the text around the point. By default
  the description part is the same as the text. Use the prefix
  command in order to edit the description."
    (interactive "*P")
    (let* ((range (if mark-active
                      (list (point) (mark))
                    (arv/org-ecfg--link-at-point-get-range)))
           (text (apply 'buffer-substring-no-properties range))
           (link (if (s-starts-with-p "ecfg:" text)
                     text
                   (concat "ecfg:" text)))
           (description (if (s-starts-with-p "ecfg:" text)
                            (mapconcat 'identity (cdr (s-split ":" text)) ":")
                          text)))
      (if mark-active
          (deactivate-mark))
      (if arg
          (setq description (read-from-minibuffer "Description:" description
                                                  nil nil
                                                  'arv/org-ecfg-insert-link-at-point-history)))
      (apply 'delete-region range)
      (insert (format "[[%s][%s]]" link description))))
#+end_src

Funcionalitat relacionada amb el seguiment del temps invertit en
tasques, gesti贸 de interrupcions etc. Maig vaig aconsseguir
integrar-ho en el workflow.

#+begin_src emacs-lisp :tangle no
  ;;; state change and clock
  ;;
  ;; I want the clock to automatically start/stop clocking whenever a
  ;; task's state changes.
  ;;
  ;; Entering a state may trigger an action:
  ;;
  ;; - start: start clocking the current task. Clock-out the active task
  ;;   if any.
  ;;
  ;; - stop: stop clocking, but only if the current task is the active
  ;;   task. That's required in order to ensure that changing a task
  ;;   from a /paused/ state to other /paused/ state (from PAUSE to WAIT
  ;;   btw) does not clocks-out the active task,
  ;;
  ;; The mapping between states and actions is stored in the alist
  ;; `arv/org-sctc-entering-state-clocking-actions'. If an state is
  ;; missing or its associated action is nil then no action is performed
  ;; when it's entered.
  ;;
  ;; In case a task is being paused as a consequence of other being
  ;; started it will be put in the state defined in the variable
  ;; `arv/org-sctc-paused-state'.
  ;;
  ;; In order to enable that functionalitty call `arv/org-sctc-setup'
  ;; with no argument or nil. Passing an argument other than nil will
  ;; disable it.

  (defvar arv/org-sctc-entering-state-clocking-actions nil
    "alist mapping states to actions.")

  (defvar arv/org-sctc-paused-state nil
    "Stated for the task being paused.")


  (defvar arv/org-sctc--previous-active-task-marker nil)

  (defun arv/org-sctc--get-state-action (to)
    (cdr (assoc to arv/org-sctc-entering-state-clocking-actions)))

  (defun arv/org-sctc--pause-other-task ()
    (when arv/org-sctc--previous-active-task-marker
      (unwind-protect
          (save-excursion
            (goto-char arv/org-sctc--previous-active-task-marker)
            ;; IMPORTANT: calling org-todo may produce infinite
            ;; recursion, be careful when changing the code!!
            (org-todo arv/org-sctc-paused-state))
        (progn
          (set-marker arv/org-sctc--previous-active-task-marker nil)
          (setq arv/org-sctc--previous-active-task-marker nil)
          (remove-hook 'post-command-hook 'arv/org-sctc--pause-other-task)))))

  (defun arv/org-sctc--state-change (from to)
    (when (and (null arv/org-sctc--previous-active-task-marker)
               (not (string= from to)))
      (let ((action (arv/org-sctc--get-state-action to)))
        (unless (null action)
          (cond
           ((eq action 'start)
            (when (org-clock-is-active)
              (setq arv/org-sctc--previous-active-task-marker (copy-marker org-clock-marker))
              (org-clock-out)
              (add-hook 'post-command-hook 'arv/org-sctc--pause-other-task 'append))
            (org-clock-in))
           ((eq action 'stop)
            (let ((org-state "DONE") ;; hackish, review!!
                  (org-clock-out-when-done t))
              (org-clock-out-if-current)))
           (t (user-error "Unknown action.")))))))

  (defun arv/org-sctc--state-change-callback (p)
    (let ((type (plist-get p :type))
          (from (plist-get p :from))
          (to   (plist-get p :to)))
      (when (eq type 'todo-state-change)
        (arv/org-sctc--state-change from to))))

  (defun arv/org-sctc-setup (&optional disable)
    (if disable
        (remove-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)
      (add-hook 'org-trigger-hook 'arv/org-sctc--state-change-callback)))

  ;;; Interruption handling
  ;;
  ;; I want to be able to track interruptions and resume interrupted
  ;; tasks.
  ;;
  ;; Execute `arv/org-interrupt-interrupt-active-task' to put the active
  ;; task in hold, pause the clock and start capturing.
  ;;
  ;; Execute `arv/org-interrupt-resume-last-active-task' to resume the
  ;; last interrupted task, if any.

  (defvar arv/org-interrupt-resumed-state nil
    "State to put the task on when resuming after an
  interruption.")

  (defvar arv/org-interrupt-interrupted-state nil
    "State to put the task on when interrupted.")

  (defvar arv/org-interrupt-capture-key nil
    "Key for the capture template used by the interruption.")

  (defvar arv/org-interrupt--last-active-task nil
    "Private")

  (defun arv/org-interrupt-interrupt-active-task ()
    "Interrupts the active task (if any) and starts capturing an
  interruption.

  If there's an active task its ID is saved in the variable
  `arv/org-interrupt--last-active-task'."
    (interactive)
    (save-excursion
     (when (org-clock-is-active)
       (org-clock-goto)
       (setq arv/org-interrupt--last-active-task (org-id-get-create))
       (org-todo arv/org-interrupt-interrupted-state)))
    (org-capture nil arv/org-interrupt-capture-key))

  (defun arv/org-interrupt-resume-last-active-task ()
    "If there's an interrupted task jump to it and start it again.

  Currently this function relies on the value of the variable
  `arv/org-interrupt--last-active-task' in order to locate the
  interrupted task. The value of this variable won't survive
  restarting emacs and won't be saved."
    (interactive)
    (when arv/org-interrupt--last-active-task
      (org-id-goto arv/org-interrupt--last-active-task)
      (setq arv/org-interrupt--last-active-task nil)
      (org-todo arv/org-interrupt-resumed-state)))
#+end_src

*** =arv-template=

=arv-template= aprofita =yasnippet= per oferir plantilles amb
contingut inicial al crear nous arxius.

El funcionament es basa en que quan es crea un nou buffer, si compleix
certes condicions (estar buid, tindre associat un fitxer etc.),
s'insereix el text =header= (configurable en la variable
=arv/template-snippet-key=) i s'utilitza =yasnippet= per expandir-lo.

Per utilitzar-lo nom茅s cal crear /snippets/ amb la clau (=key=)
=header=.

**** Codi
     :PROPERTIES:
     :ID:       57ae3e72-5e9d-4d4c-ada6-c6a93594a458
     :END:

This works by letting =yasnippet= expand the value of the customizable
variable =arv/template-snippet-key= (=header= by default) whenever
visiting a new file.

Two questions arise:

- when to insert/expand the key?

- what to do if the expansion fails?

In order to find the right snippet the buffer must be already in the
right major mode. My first attempt was hooking a function to
=find-file-not-found-functions=, but this didn't work because at that
point the buffer is still in =fundamental-mode=.

So I have decided to track the mode changes using
=after-change-major-mode-hook=, this has a couple of drawbacks:

- apparently a newly created buffer is put in =fundamental-mode= and
  then switched to its final mode, so the functions hooked to
  =after-change-major-mode-hook= should account for being called at
  least twice.

- the function must determine by itself if the buffer is visiting a
  new file or an existing one.

Finally, if the expansion fails the key ("header") must be removed. At
first I tried with =undo= but emacs complained "no further undo
information" so I decided to explicitly delete the key.

#+begin_src emacs-lisp :tangle yes
  ;;; HACK: no s'hauria de requerir yasnippet. El problema 茅s que a莽貌 no
  ;;; 茅s un m貌dul que es pot carregar sota demanda.

  (require 'yasnippet)
  (defgroup arv/template nil
    "Insert documentation here."
    :group 'arv)

  (defcustom arv/template-snippet-key "header"
    "Name of the snippet."
    :group 'arv/template
    :type  'string
    :safe  'stringp)


  (defun arv/template-insert-header ()
    (when (and (not buffer-read-only)
               (not (eq major-mode 'fundamental-mode))
               (buffer-file-name)
               (save-excursion (goto-char (point-min))
                               (eobp)) ; empty buffer?
               (not (file-exists-p (buffer-file-name))))
      (let ((pos (point)))
        (insert arv/template-snippet-key)
        (unless (yas-expand-from-trigger-key)
          (goto-char pos)
          (delete-char (length arv/template-snippet-key) nil)
          (set-buffer-modified-p nil)))))


  (defun arv/template-setup ()
    (add-hook 'after-change-major-mode-hook 'arv/template-insert-header))
#+end_src

**** Instal路laci贸/activaci贸

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'yas-snippet-dirs
               (arv/path-concat arv/emacs-conf-dir "shared" "templates"))
  (arv/template-setup)
#+end_src

*** =arv-test=

Helpers per simplificar els tests. Molt probablement existir una
biblioteca que proveeixi aquesta funcionalitat.

#+begin_src emacs-lisp :tangle yes
  (defun arv-test--mk-buffer (&optional content mode point-marker)
    "Creates a buffer with the given content, mode and point."
    (let ((buffer (generate-new-buffer "*test_buffer*")))
      (with-current-buffer buffer
        (when content
          (insert content))
        (when point-marker
          (goto-char (point-min))
          (when (search-forward point-marker)
            (delete-char (- (length point-marker)))))
        buffer)))

  (defmacro arv-test-with-buffer (content mode point-marker &rest body)
    (declare (indent 1) (debug t))
    `(save-current-buffer
       (set-buffer (arv-test--mk-buffer ,content ,mode ,point-marker))
       ,@body
       (kill-buffer)))
#+end_src

*** =arv-yasnippet=

Colecci贸 ca貌tica de funcions (i una variable) que faciliten la
definici贸 de snippets.

#+begin_src emacs-lisp :tangle yes
  (defvar django-widget-types '("CheckboxInput"
                                "CheckboxSelectMultiple"
                                "DateInput"
                                "DateTimeInput"
                                "FileInput"
                                "HiddenInput"
                                "MultipleHiddenInput"
                                "NullBooleanSelect"
                                "PasswordInput"
                                "RadioSelect"
                                "Select"
                                "SelectMultiple"
                                "Textarea"
                                "TextInput"
                                "TimeInput"))
#+end_src

Operacions amb cadenes:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-uncamelize (text sep)
    "Retorna text sense 'camelitzar'.

  Si 'text' es 'CamelCase' i 'sep' es '-' retorna 'camel-case'.

  Es suposa que 'text' es un identificador valid escrit en
  CamelCase. 'sep' es un string.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'downcase (s-split-words text) sep)))

  (defalias 'arv-yas-uncamelize 'arv/yas-uncamelize)

  (defun arv/yas-camelize (text)
    "Retorna TEXT 'camelitzat'.
  "
    (with-syntax-table (standard-syntax-table)
      (mapconcat 'capitalize (s-split-words text) "")))

  (defun arv/yas-substring (text start end)
    "Retorna un substring.

  Esta versio de substring s'ajusta als limits i, a diferencia de
  substring, no produeix cap error si es sobrepassen.
  "
    (substring text (max 0 start) (min end (length text))))

  (defalias 'arv-yas-substring 'arv/yas-substring)

  (defun arv/string-strip-delimiters (text delimiters)
    "Strip trailing and leading chars from TEXT if they are equal
  and appear in the string DELIMITERS.

  \"+foo+\" \"$\" -> \"+foo+\"
  \"+foo+\" \"$+\" -> \"foo\"
  \"+foo-\" \"+-\" -> \"+foo-\"
  "
    (if (< (length text) 2)
        text
      (let ((delimiters (delete "" (split-string delimiters "")))
            (left-char (substring text 0 1))
            (right-char (substring text (1- (length text)))))
        (if (and (string= left-char right-char)
                 (member left-char delimiters))
            (substring text 1 (1- (length text)))
          text))))

  (defun arv/string-replace-unwanted-chars (value predicate &optional replacement)
    "Returns a string built replacing the chars from the string
  VALUE for whom the function PREDICATE returns nil with the string
  REPLACEMENT.

  If REPLACEMENT is omitted or nil the empty string is used as the
  replacement."
    (let ((replacement (or replacement "")))
      (mapconcat (lambda (x) (cond
                         ((string= x "") "")
                         ((funcall predicate x) x)
                         (t replacement)))
                 (split-string value "")
                 "")))
#+end_src

Funcions especialitzades en codi javascript:

#+begin_src emacs-lisp :tangle yes
  (defun arv/js-make-identifier (text)
    "Replace invalid chars from TEXT with an underscore in order to
  make a valid javascrip identifier."
    (let ((result (arv/string-replace-unwanted-chars
                   text (lambda (x) (string-match "[$a-zA-Z0-9_]" x)) "_")))
      (if (string-match "^[$a-zA-Z_]" result)
          result
        (concat "_" result))))

  (defun arv/yas-js-amd-params-from-modules (text)
    "Given the modules of and AMD `define' generates the names of
  the corresponding function parametres.

  '\"dojo/foo\", \"digit/a_plugin!parameters\"' -> 'foo, a_plugin'
  "
    (s-join ", " (mapcar (lambda (x) (arv/js-make-identifier (car (last (s-split "/" (car (s-split "!" (arv/string-strip-delimiters (s-trim x) "'\""))))))))
                         (s-split "," text))))

  (defun arv/yas-js-get-parameter-names (text)
    (delete "" (mapcar 's-trim (split-string text ","))))

  (defun arv/yas-js-function-parameters-documentation (text &optional header)
    (let ((header (or header "Parameters"))
          (params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (- (current-column) 2) 32) "// ")))
      (if params
          (concat indent
                  header
                  indent
                  (mapconcat (lambda (x) (format "- %s : " x)) params indent))
        "")))

  (defun arv/yas-js-function-store-parameters (text)
    (let ((params (arv/yas-js-get-parameter-names text))
          (indent (concat "\n" (make-string (current-column) 32))))
      (if params
          (concat indent
                  (mapconcat (lambda (x) (format "this._%s = %s;" x x)) params indent))
        "")))
#+end_src

Funcions especialitzades en codi python:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-py-parse-parameters (text)
   "Parseja els arguments d'una funci铆/m猫tode.

  'foo, bar=value' -> (('foo') ('bar' 'value'))"
     (mapcar (lambda (x)
               (mapcar 's-trim (split-string x "=")))
             (split-string text ",")))

  (defalias 'arv-yas-py-parse-parameters 'arv/yas-py-parse-parameters)


  (defun arv/yas-py-get-parameter-names (text &optional exclude)
    "Retorna el nom dels parmetres.

  Mira de netejar anomalies com parametres sense nom. Si
  s'especifica un valor diferent de `nil' per `exclude' s'exclouen
  el parmetres '*args' i '**kw' si estan presents (es comprova que
  comencin per * no el nom concret).

  'foo, bar=value' -> ('foo', 'bar')
  'foo,, bar=value' -> ('foo', 'bar')
  'foo, bar=value, *args' -> ('foo', 'bar', '*args')

  Especificant `exclude':

  'foo, bar=value, *args' -> ('foo', 'bar')"
    (delq nil
          (mapcar (lambda (x)
                    (let ((name (nth 0 x)))
                      (unless (or (string= name "")
                                  (and (not (null exclude))
                                       (s-starts-with-p "*" name)))
                        name)))
                  (arv-yas-py-parse-parameters text))))

  (defalias 'arv-yas-py-get-parameter-names 'arv/yas-py-get-parameter-names)


  (defun arv/yas-py-function-parameters-documentation (text)
    "Retorna la documentaci贸 pels parmetres d'una funci贸.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    :param foo:
    :param bar:
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat ":param " x ":"))
       (arv-yas-py-get-parameter-names text 't)
       indent)))

  (defalias 'arv-yas-py-function-parameters-documentation 'arv/yas-py-function-parameters-documentation)


  (defun arv/yas-py-constructor-store-arguments (text)
    "Retorna l'assignaci贸 a atributs en el constructor.

  Converteix:

    foo, bar=1234, *args, **kw

  en:

    self._foo = foo
    self._bar = bar
    self._args = args
    self._kw = kw
  "
    (let* ((indent (concat "\n" (make-string (current-column) 32))))
      (mapconcat
       (lambda (x)
         (concat "self._" x " = " x))
       (mapcar
        (lambda (x)
          (s-chop-prefix "*" (s-chop-prefix "*" x)))
        (arv-yas-py-get-parameter-names text))
       indent)))

  (defalias 'arv-yas-py-constructor-store-arguments 'arv/yas-py-constructor-store-arguments)
#+end_src

Funcions especialitzades en codi sh:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-sh-getopt-case-options (text)
    "Retorna les opcions de 'case'.

  Converteix:

      a:b

  en:

      a) OPT_A=$OPTARG ;;
      b) OPT_B=1 ;;
  "
    (let ((indent (concat "\n" (make-string (current-column) 32)))
          (result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (and (> (length text) 1) (char-equal (aref text 1) ?:))
              (progn
                (setq text (substring text 2))
                (setq result (cons (format "%s) OPT_%s=$OPTARG ;;" char CHAR) result)))
            (setq result (cons (format "%s) OPT_%s=1 ;;" char CHAR) result))
            (setq text (substring text 1))
            )))
      (concat indent
              (mapconcat (lambda (x) x) (reverse result) indent))))

  (defun arv/yas-sh-getopt-var-declaration (text)
    "Retorna les variables.

  Converteix:

      a:b

  en:

      OPT_A=
      OPT_B=
  "
    (let ((result ()))
      (while (not (string= text ""))
        (let* ((char (char-to-string (aref text 0)))
               (CHAR (upcase char)))
          (if (not (string-equal char ":"))
              (setq result (cons (format "OPT_%s=" CHAR) result)))
          (setq text (substring text 1))))
      (mapconcat (lambda (x) x) (reverse result) "\n")))
#+end_src

Funcions variades:

#+begin_src emacs-lisp :tangle yes
  (defun arv/yas-today (&optional fmt)
    (let ((fmt (or fmt "%Y-%m-%d")))
      (format-time-string fmt)))

  (defun arv/yas-year ()
    (format-time-string "%Y"))

  (defun arv/yas-buffer-name ()
    (file-name-nondirectory (buffer-file-name)))

  (defun arv/yas-buffer-name-upcase ()
    (upcase (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans ()
    (file-name-sans-extension (arv/yas-buffer-name)))

  (defun arv/yas-buffer-name-sans-upcase ()
    (upcase (arv/yas-buffer-name-sans)))

  (defun arv/yas-buffer-name-sans-camelcase ()
    (arv/yas-camelize (arv/yas-buffer-name-sans)))

  (defun arv/yas-author-name ()
    user-full-name)

  (defun arv/yas-author-email ()
    user-mail-address)
#+end_src

** Combinacions de tecles globals

Aquest apartat 茅s un copiar/enganxar de la configuraci贸 original. En
aquest punt moltes de les comandes no estan definides, d'altres s贸n
redundants o mai les he arribat a incorporar en el /workflow/.

#+begin_src emacs-lisp :tangle yes
  ;; disable some keybindings

  ;; disable arrow  keys
  ;; (progn
  ;;   (global-unset-key (kbd "<up>"))
  ;;   (global-unset-key (kbd "<down>"))
  ;;   (global-unset-key (kbd "<left>"))
  ;;   (global-unset-key (kbd "<right>"))
  ;;   (global-unset-key (kbd "C-<up>"))
  ;;   (global-unset-key (kbd "C-<down>"))
  ;;   (global-unset-key (kbd "C-<left>"))
  ;;   (global-unset-key (kbd "C-<right>"))
  ;;   (global-unset-key (kbd "M-<up>"))
  ;;   (global-unset-key (kbd "M-<down>"))
  ;;   (global-unset-key (kbd "M-<left>"))
  ;;   (global-unset-key (kbd "M-<right>")))

  ;; (progn
  ;;   (global-set-key (kbd "M-n") 'forward-paragraph)
  ;;   (global-set-key (kbd "M-p") 'backward-paragraph))

  ;; ocasionally I press C-x C-c by accident, define a more complex
  ;; keybinding to kill emacs
  (global-unset-key (kbd "C-x C-c"))
  (global-set-key (kbd "C-x r q") 'save-buffers-kill-terminal)

  ;; On X11 C-z serves no purpose since the wm defines keybindings to
  ;; minimize windows. OTOH is very annoying when pressed by
  ;; accident. In any case C-x C-z is still available.
  (when (display-graphic-p)
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z") 'my/bash-terminal))


  ;; emacs overrides
  ;; (global-set-key (kbd "C-s") #'endless/isearch-symbol-with-prefix)
  (global-set-key (kbd "C-x 2") #'arv/split-windows-bellow)
  (global-set-key (kbd "C-x 3") #'arv/split-windows-right)

  (global-set-key (kbd "C-S-k") #'my/kill-to-indentation-or-beginning-of-line)
  (global-set-key (kbd "C-o") #'arv/open-line-before-and-indent)
  (global-set-key (kbd "C-S-o") #'arv/open-line-after-and-indent)

  (global-set-key (kbd "C-w") #'my/kill-region)

  (global-set-key (kbd "M-D") #'my/dedent-to-point)

  ;; tab-bar
  (when (fboundp 'tab-bar-mode)
    (global-set-key (kbd "C-x t h <left>") #'tab-bar-history-back)
    (global-set-key (kbd "C-x t h p") #'tab-bar-history-back)
    (global-set-key (kbd "C-x t h <right>") #'tab-bar-history-forward)
    (global-set-key (kbd "C-x t h n") #'tab-bar-history-forward))

  ;; let's give a try to swiper
  (global-set-key (kbd "C-s") 'arv/swiper-symbol-with-prefix)
  (global-set-key (kbd "C-S-s") 'isearch-forward)

  (global-set-key (kbd "M-SPC") 'cycle-spacing)
  (global-set-key (kbd "M-z") 'zap-up-to-char)

  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "M-u") 'arv/upcase-word)
  (global-set-key (kbd "M-l") 'arv/downcase-word)
  (global-set-key (kbd "M-;") 'endless/comment-line-or-region)

  (global-set-key (kbd "M-Q") #'my/unfill-paragraph)

  (global-set-key (kbd "s-y") 'arv/duplicate-line-or-region-dwim)
  (global-set-key (kbd "C-M-y") 'arv/duplicate-line-or-region-and-comment-dwim)


  ;; other bindings

  (global-set-key (kbd "<f1>") (lambda () (interactive) (info)))
  (global-set-key (kbd "C-<f1>") (lambda () (interactive) (info "emacs")))
  (global-set-key (kbd "<f7>") 'next-error)
  (global-set-key (kbd "<f8>") 'previous-error)
  (global-set-key (kbd "<f9>") #'my/compile-with-comint-enabled)
  (global-set-key (kbd "C-<f9>") 'compile)

  (global-set-key (kbd "s-g") 'arv/goto-line)
  ;;; es un incordio tener que teclear yes para confirmar
  (global-set-key (kbd "C-<return>") "yes\C-m")

  (global-set-key (kbd "M-%") 'arv/query-replace)
  (global-set-key (kbd "M-w") 'arv/kill-ring-save-word-at-point)

  (global-set-key (kbd "C-<tab>") 'dabbrev-expand)

  (global-set-key (kbd "C-x C-b") 'ibuffer)
                                          ; Una altra alternativa si
                                          ; aquesta no em conven莽 茅s
                                          ; buffer-menu

  ;; insert map

  (global-set-key (kbd "C-c i l") 'lorem-ipsum-insert-paragraphs)
  (global-set-key (kbd "C-c i L") 'lorem-ipsum-insert-sentences)
  (global-set-key (kbd "C-c i f") 'figlet)
  (global-set-key (kbd "C-c i F") 'figlet-no-comment)
  (global-set-key (kbd "C-c i u") 'arv/insert-random-uuid)

  ;; jump map

  (global-set-key (kbd "C-c j c") 'avy-goto-char-2)
  (global-set-key (kbd "C-c j e e") #'my/visit-emacs-config)
  (global-set-key (kbd "C-c j e d") #'my/visit-emacs-config-directory)
  (global-set-key (kbd "C-c j e n") #'my/visit-emacs-notes)
  (global-set-key (kbd "C-c j h n") #'diff-hl-next-hunk)
  (global-set-key (kbd "C-c j h p") #'diff-hl-previous-hunk)
  (global-set-key (kbd "C-c j l") 'avy-goto-line)
  (global-set-key (kbd "C-c j s") 'imenu)
  (global-set-key (kbd "C-c j w") 'avy-goto-word-1)

  ;; embrace
  (global-set-key (kbd "C--") 'embrace-commander)

  ;; grin
  (global-set-key (kbd "C-莽") 'arv/grin)

  ;; keybindings per subversion: C-c s
  (global-set-key (kbd "C-c s =") 'svn-file-show-svn-diff)
  (global-set-key (kbd "C-c s l") 'svn-status-show-svn-log)
  (global-set-key (kbd "C-c s s") 'x-my/svn-status)

  ;; keybindings per magit: C-c g
  (global-set-key (kbd "C-c g s") #'magit-status)
  (global-set-key (kbd "C-c g d") #'magit-dispatch)
  (global-set-key (kbd "C-c g f") #'magit-file-dispatch)

  ;; expand-region
  (global-set-key (kbd "C-.") 'er/expand-region)

  ;; multi-line
  (global-set-key (kbd "C-c r m") 'multi-line)

  ;; find-file-in-project
  (global-set-key (kbd "C-x f") 'find-file-in-project)

  ;; org
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c o s") 'org-sort)

  ;; smex
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; toggle map
  (global-set-key (kbd "C-c t c") 'column-number-mode)
  (global-set-key (kbd "C-c t B") 'arv/alternar-mida-font)
  (global-set-key (kbd "C-c t f") 'auto-fill-mode)
  (global-set-key (kbd "C-c t F") 'toggle-fullscreen)
  (global-set-key (kbd "C-c t l") #'my/display-line-numbers-mode)
  (global-set-key (kbd "C-c t L") 'line-number-mode)
  (global-set-key (kbd "C-c t r") 'read-only-mode)

  ;; word-mode
  (global-set-key (kbd"C-,") 'arv/wm-cycle)

  (global-set-key (kbd "C-c b b") 'bjm-comment-box)

#+end_src

** hydras

Pel moment definir茅 les hidres ac铆. La idea 茅s utilitzar-les per fer
accessibles comandes relacionades que em resulten 煤tils per貌 utilitzo
tan ocasionalment que no recordo les tecles. Per facilitar-ho es
definiran dins el mapa =C-c h=.

*** outline minor mode

#+begin_src emacs-lisp :tangle yes
  (defhydra hydra-outline (:color pink :hint nil)
    "
  ^Hide^             ^Show^           ^Move
  ^^^^^^------------------------------------------------------
  _q_: sublevels     _a_: all         _u_: up
  _t_: body          _e_: entry       _n_: next visible
  _o_: other         _i_: children    _p_: previous visible
  _c_: entry         _k_: branches    _f_: forward same level
  _l_: leaves        _s_: subtree     _b_: backward same level
  _d_: subtree

  "
    ;; Hide
    ("q" hide-sublevels)    ; Hide everything but the top-level headings
    ("t" hide-body)         ; Hide everything but headings (all body lines)
    ("o" hide-other)        ; Hide other branches
    ("c" hide-entry)        ; Hide this entry's body
    ("l" hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" show-all)          ; Show (expand) everything
    ("e" show-entry)        ; Show this heading's body
    ("i" show-children)     ; Show this heading's immediate child sub-headings
    ("k" show-branches)     ; Show all sub-headings under this heading
    ("s" show-subtree)      ; Show (expand) everything in this heading & below
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("z" nil "leave"))

  (global-set-key (kbd "C-c h o") 'hydra-outline/body)
#+end_src

*** smerge

El paquet =smerge= facilita resoldre conflictes al fer un merge en un
control de revisions.

L'origen d'aquesta hydra 茅s un [[https://irreal.org/blog/?p=5651][post de Irreal]].

#+begin_src emacs-lisp :tangle yes
  (defhydra hydra-smerge
    (:color red :hint nil :pre (smerge-mode 1))
    "
  ^Move^    ^Keep^    ^Diff^    ^Pair^
  ------------------------------------------------------
  _n_ext    _b_ase    _R_efine  _<_: base-mine
  _p_rev    _m_ine    _E_diff   _=_: mine-other
  ^ ^       _o_ther   _C_ombine _>_: base-other
  ^ ^       _a_ll     _r_esolve
  _q_uit    _RET_: current
  "
    ("RET" smerge-keep-current)
    ("C" smerge-combine-with-next)
    ("E" smerge-ediff)
    ("R" smerge-refine)
    ("a" smerge-keep-all)
    ("b" smerge-keep-base)
    ("m" smerge-keep-mine)
    ("n" smerge-next)
    ("o" smerge-keep-other)
    ("p" smerge-prev)
    ("r" smerge-resolve)
    ("<" smerge-diff-base-mine)
    ("=" smerge-diff-mine-other)
    (">" smerge-diff-base-other)
    ("q" nil :color blue))

  (global-set-key (kbd "C-c h s") 'hydra-smerge/body)
#+end_src

* Parxes

Recull de parxes que resolen incompatibilitats etc. La idea 茅s
agrupar-los ac铆 per facilitar localitzar-los i eliminar-los quan
estiguin resolts.

Estaria b茅 afegir alarmes per comprovar si ja hi ha una soluci贸.

- 20180601: Corregeix [[https://github.com/jorgenschaefer/elpy/issues/1379][un error amb emacs 26.1 i elpy 1.21]]: =M-x= salta
  a un TAG, no utilitza la funcionalitat de =elpy=.

  #+begin_src emacs-lisp :tangle yes
    (with-eval-after-load 'elpy
      (when (and (string= emacs-version "26.1")
                 (string= elpy-version "1.21.0"))
        (defun elpy--xref-backend ()
          "Return the name of the elpy xref backend."
          (if (or (and (not (elpy-rpc--process-buffer-p elpy-rpc--buffer))
                       (elpy-rpc--get-rpc-buffer))
                  elpy-rpc--jedi-available)
              'elpy
            nil))))
  #+end_src

- 20180818: amb emacs 26 el comportament de =hi-lock= no 茅s el mateix
  que amb la versi贸 25: sembla que nom茅s ressalta els elements que hi
  ha al obrir l'arxiu, no els que s'afegeixen posteriorment.

  Veure comentari/soluci贸 en el [[target-prog-mode-hook][hook que configura =hi-lock=]].

  El parxe sembla /correcte/ per貌 no estic segur. Investigar-ho amb
  m茅s calma.

* Incubadora

Noves funcionalitats que estic provant. Si em convencen es mouen a
l'apartat /Configuraci贸/.

En aquest apartat l'organitzaci贸 茅s la inversa, tot va dins una
subsecci贸 per tractar cada nova funcionalitat com un tot. Si
s'accepta, el contingut es distribueix on correspongui.

All铆 on tingui sentit, el nom dels elements haurien de comen莽ar amb el
prefix =x-arv= per identificar que son experimentals. Probablement amb
la API p煤blica (comandes?) sigui suficient.

** =rotate-windows=

https://github.com/domtronn/emacs/blob/1b0bae5f146c8adb477ac4f7158c063ed45baeea/init/functions.el#L282

Rota els buffers entre les finestres:

#+begin_src emacs-lisp :tangle yes
  (defun x-arv/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond
     ((not (> (count-windows) 1))
      (message "You can't rotate a single window!"))
     (t
      (let  ((i 1)
             (numWindows (count-windows)))
        (while  (< i numWindows)
          (let* (
                 (w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i numWindows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1  b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i))))))))
#+end_src

S'afegeix la comanda al keymap de finestres:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c w r") #'x-arv/rotate-windows)
#+end_src

** =winner-mode=

En general no el veig prctic per貌 hi ha un cas d'煤s en que podria ser
煤til: quan s'obre una finestra tipus ajuda, compilaci贸 etc. i la vull
fer desapareixer.

#+begin_src emacs-lisp :tangle yes
  (use-package winner
    :commands winner-mode
    :config
    (setq winner-ring-size 50)
    (setq winner-boring-buffers '("*Apropos*"
                                  "*Buffer List*"
                                  "*Compile-Log*"
                                  "*Completions*"
                                  "*grep*"
                                  "*Help*"
                                  "*hera-events*"
                                  "*Occur*"
                                  "*pytest*"
                                  "*svn-diff*"
                                  "*svn-info*"
                                  "*svn-info-output*"
                                  "*svn-log*"
                                  "*svn-log-edit*"
                                  "*svn-property-edit*"
                                  )))
#+end_src

A莽貌 anir en alguna secci贸 /global/.

#+begin_src emacs-lisp :tangle yes
  (winner-mode t)
#+end_src

** =arv/camelize=

De vegades vull convertir =foo_bar= en =FooBar= i al rev茅s:

#+begin_src emacs-lisp :tangle yes
  (defun x-my/camelize ()
    (interactive)
    (when (looking-at-p "\\sw\\|\\s_")
      (let* ((begin (save-excursion
                      (while (and (not (bobp)) (looking-back "\\sw\\|\\s_"))
                        (backward-word))
                      (point)))
             (end (save-excursion
                    (while (and (not (eobp)) (looking-at "\\sw\\|\\s_"))
                      (forward-word))
                    (point)))
             (text (buffer-substring-no-properties begin end))
             (replacement (with-syntax-table (standard-syntax-table)
                            (if (and (string-match-p "^\\sw+$" text)
                                     (s-mixedcase-p text))
                                ;; CamelCase -> camel_case
                                (mapconcat 'downcase (s-split-words text) "_")
                              ;; camel_case -> CamelCase
                              (mapconcat 'capitalize (s-split-words text) "")
                              ))))
        (save-excursion
          (goto-char begin)
          (delete-region begin end)
          (insert replacement)
          )
        )))
#+end_src

El separador est fixat al codi per貌 pel moment 茅s suficientment b贸.
El provar茅 en =python-mode= per veure que tal. Si resulta 煤til acabar茅
de polir-la.

En certa forma a莽貌 茅s una generalitzaci贸 de =capitalize=:

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "M-c") 'x-my/camelize)
#+end_src

** repetici贸 de comandes

Pot resultar prctic per貌 no acabo de trobar un 煤s.

- [[https://github.com/myuhe/smartrep.el][smartrep.el]]: support sequential operation which omit prefix key.
  Latest commit f0ff5a6 on 9 May 2015.

  #+begin_src emacs-lisp :tangle no
    (smartrep-define-key
     global-map "M-g"
     '(("n" . next-line)
       ("p" . previous-line)))
  #+end_src

- [[https://github.com/abo-abo/hydra][hydra]]: make Emacs bindings that stick around. Latest commit 62e0f37
  on 27 Feb 2018.

  #+begin_src emacs-lisp :tangle no
    (use-package hydra
      :ensure t
      :config
      (defhydra hydra-zoom (global-map "C-c r")
        "multi-line"
        ("m" multi-line)))
  #+end_src

- configuraci贸 de Sacha Chuar: based on
  http://oremacs.com/2015/01/14/repeatable-commands/ . Modified to
  accept =nil= as the first value if you don't want the keymap to run
  a command by default, and to use =kbd= for the keybinding
  definitions.

  #+begin_src emacs-lisp :tangle no
    (defun my/def-rep-command (alist)
      "Return a lambda that calls the first function of ALIST.
    It sets the transient map to all functions of ALIST,
    allowing you to repeat those functions as needed."
      (let ((keymap (make-sparse-keymap))
            (func (cdar alist)))
        (mapc (lambda (x)
                (when x
                  (define-key keymap (kbd (car x)) (cdr x))))
              alist)
        (lambda (arg)
          (interactive "p")
          (when func
            (funcall func arg))
          (set-transient-map keymap t))))
  #+end_src

* Descartat

Funcionalitats experimental que no he acosseguit /interioritzar/.

** Inici de l铆nia

Copiat de
http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/:

#+begin_src emacs-lisp :tangle no
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+end_src

#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "C-a") #'my/smarter-move-beginning-of-line)
#+end_src

** Desactivar tecles del cursor

Porto massa anys utilitzant les tecles del cursor i he desenvolupat
habits per mourem rpidament amb elles. El canvi em trenca massa el
ritme de treball i resulta frustrant.

L'objectiu 茅s acostumar-me a no utilitzar les tecles del cursor pels
despla莽aments i no haver de moure la ma fora de la /fila principal/.

#+begin_src emacs-lisp :tangle no
  (defun comanda-desactivada ()
    (interactive)
    (let ((visible-bell t))
      (ding)))

  (global-set-key (kbd "<up>") #'comanda-desactivada)
  (global-set-key (kbd "<down>") #'comanda-desactivada)
  (global-set-key (kbd "<left>") #'comanda-desactivada)
  (global-set-key (kbd "<right>") #'comanda-desactivada)
#+end_src

* Per mirar
** =define-compilation-mode=

En alguns m貌duls utilitzo buffers de compilaci贸 per mostrar el
resultat d'executar una comanda externa (p.e. llistar events i
subscriptors en Hera). Mirar si aquesta macro aporta cap avantatge.

** ressaltar insert/overwrite en la modeline

Ressaltar el mode insert/overwrite en la modeline utiltizant un color
de fons. Actualment /insert/ no es visualitza.

** revisar les [[info:elisp#Coding%20Conventions][info:elisp#Coding Conventions]].
** [[https://melpa.org/#/redshank][redshank]]

Common Lisp Editing Extensions. Espec铆ficament m'interesa la part que
permet refactoritzar codi.

** lpy

https://github.com/abo-abo/lpy/blob/master/lpy.el

This is an attempt to implement a variant of `lispy-mode'
(https://github.com/abo-abo/lispy) for Python. Unfortunately, Python
isn't nearly as well-structured as LISP. But Python is ubiquitous, and
the less powerful `lpy-mode' is better than nothing at all.

The basic idea of `lpy-mode' is to increase the editing efficiency by
binding useful navigation, refactoring and evaluation commands to
unprefixed keys, e.g. "j" or "e". But only in certain point positions,
so that you are still able to use uprefixed keys to insert themselves.

Example, here "|" represents the point position:

  print |("2+2=%d" % (2 + 2))

Here, if you press the key "e", the whole line will be evaluated and
"2+2=4" will be printed in the Echo Area. Note that if `lpy-mode' was
off, pressing "e" would instead result in:

  print e|("2+2=%d" % (2 + 2))

So inserting any key isn't actually useful with that point position
and e.g. the "e" can be used for evaluating the current statement.

But, for instance, if you wanted to edit "print" into "printe", you
could do that in a straightforward way, just like you would with
`lpy-mode' off : with "C-b e".
